/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import{util as e,clone as t,env as a,scalar as n,keep as s,tensor as r,stack as o,concat as p,unstack as i,tidy as m,reshape as u,slice as d,io as c,Tensor as y}from"@tensorflow/tfjs-core";import{squaredDifference as l,pow as h,maximum as f,minimum as N,sub as g,floorDiv as x,divNoNan as b,div as T,mul as _,mod as S,addN as O,add as w,prelu as A,leakyRelu as E,prod as v,rsqrt as I,relu6 as D,clipByValue as M,tan as k,tanh as V,square as z,sqrt as C,softplus as L,sinh as F,sign as $,sin as R,sigmoid as j,selu as P,round as B,relu as H,real as W,reciprocal as U,neg as q,imag as G,log1p as Q,log as K,floor as X,expm1 as Z,exp as Y,erf as J,elu as ee,cosh as te,cos as ae,complex as ne,ceil as se,atanh as re,atan2 as oe,atan as pe,asinh as ie,asin as me,acosh as ue,acos as de,abs as ce,dilation2d as ye,maxPool3d as le,avgPool3d as he,maxPoolWithArgmax as fe,maxPool as Ne,avgPool as ge,conv3d as xe,depthwiseConv2d as be,conv2dTranspose as Te,fused as _e,conv2d as Se,conv1d as Oe,zerosLike as we,zeros as Ae,truncatedNormal as Ee,range as ve,randomUniform as Ie,onesLike as De,ones as Me,oneHot as ke,multinomial as Ve,linspace as ze,fill as Ce,setdiff1dAsync as Le,cast as Fe,whereAsync as $e,image as Re,unique as je,topk as Pe,scalar as Be,tensor1d as He,where as We,logicalOr as Ue,logicalNot as qe,logicalAnd as Ge,lessEqual as Qe,less as Ke,greaterEqual as Xe,greater as Ze,notEqual as Ye,equal as Je,transpose as et,matMul as tt,sparseToDense as at,logSoftmax as nt,softmax as st,localResponseNormalization as rt,batchNorm as ot,denseBincount as pt,bincount as it,cumsum as mt,argMin as ut,argMax as dt,any as ct,all as yt,sum as lt,min as ht,mean as ft,max as Nt,gatherND as gt,scatterND as xt,split as bt,tile as Tt,unstack as _t,squeeze as St,reshape as Ot,stack as wt,stridedSlice as At,slice as Et,reverse as vt,gather as It,concat as Dt,irfft as Mt,rfft as kt,ifft as Vt,fft as zt,broadcastTo as Ct,depthToSpace as Lt,batchToSpaceND as Ft,spaceToBatchND as $t,pad as Rt,mirrorPad as jt,expandDims as Pt}from"@tensorflow/tfjs-core/dist/ops/ops_for_converter";var Bt,Ht;!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(Bt||(Bt={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Ht||(Ht={}));const Wt={};function Ut(e,t){const a={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};Wt[e]=a}function qt(e){return Wt[e]}function Gt(e){delete Wt[e]}function Qt(t,a,n,s,r){const o=a.inputParams[t];if(o&&void 0!==o.inputIndexStart){const t=o.inputIndexStart,p=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?t+1:o.inputIndexEnd;if("tensor"===o.type)return Kt(a.inputNames[o.inputIndexStart],n,s,r);if("tensors"===o.type){return a.inputNames.slice(t,p).map(e=>Kt(e,n,s,r))}const i=Kt(a.inputNames.slice(t)[0],n,s,r),m=i.dataSync();return"number"===o.type?m[0]:e.toNestedArray(i.shape,m)}const p=a.attrParams[t];return p&&p.value}function Kt(e,t,a,n){const[s,r]=Yt(e);if(null!=n){const e=n.getHashTableHandleByName(s);if(null!=e)return e}const o=a.currentContextIds.find(e=>!!t[Zt(s,e)]);return void 0!==o?t[Zt(s,o)][r]:void 0}function Xt(e,t){const[a,n]=Yt(e);return[Zt(a,t&&t.currentContextId),n]}function Zt(e,t){return t?`${e}-${t}`:e}function Yt(e){const t=e.split(":");return 1===t.length?[e,0]:[t[0],Number(t[t.length-1])]}function Jt(e,t,a){let n=Qt("pad",e,t,a);if("explicit"===n){n=Qt("explicitPaddings",e,t,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=n[2*e],s[e][1]=n[2*e+1];return s}return n}function ea(e){return e.kept?e:t(e)}var ta=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var aa=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var na=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]});var sa=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var ra=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var oa=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var pa=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var ia=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var ma=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}]});var ua=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var da=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ca=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ya=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var la=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var ha=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var fa=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var Na=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class ga{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[ta,aa,na,sa,ra,oa,pa,da,ua,ia,ca,ya,la,ha,fa,Na,ma].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const a=e.node,n=[],s=[],r=[],o=a.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||r.push(e[t.name]),e),{});let p=[];const i=[];let m={},u={};null!=t&&(m=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach(e=>{const t=o[e];t.inputNames.forEach(e=>{const[a]=Xt(e);t.inputs.push(o[a]),o[a].children.push(t)})}),0===Object.keys(u).length?d.forEach(e=>{const t=o[e];0===t.children.length&&i.push(t)}):Object.keys(u).forEach(e=>{const[t]=Xt(e),a=o[t];null!=a&&(a.signatureKey=u[e],i.push(a))}),Object.keys(m).length>0?Object.keys(m).forEach(e=>{const[t]=Xt(e),a=o[t];a&&(a.signatureKey=m[e],p.push(a))}):p=n;let c={};null!=e.library&&null!=e.library.function&&(c=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const y={nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,signature:t,functions:c};return r.length>0&&(y.initNodes=r),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,a)=>(t[e[a].name]=a,t),{})}mapNode(e){const t=qt(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.substr(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return null!=t.inputs&&(a.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce((t,a)=>{const n=a.type;let s=void 0;switch(a.type){case"string":s=ba(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=ba(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=Da(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Da(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=_a(e.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=_a(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=Ia(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ia(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=Ta(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ta(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=ka(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=ka(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=va(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=va(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=Ma(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ma(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=wa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=wa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=Aa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Aa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=Oa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Oa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:s,type:n},t},{})),a}mapFunction(e){const t=e.nodeDef,a=[];let n={};null!=t&&(n=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e),{}));const s=[],r=[];e.signature.inputArg.forEach(e=>{const[t]=Xt(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Sa(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,s.push(a),n[t]=a}),Object.keys(n).forEach(e=>{const t=n[e];t.inputNames.forEach(e=>{const[a]=Xt(e);t.inputs.push(n[a]),n[a].children.push(t)})});const o=e.ret;e.signature.outputArg.forEach(e=>{const[t,a]=Xt(o[e.name]),s=n[t];null!=s&&(s.defaultOutput=a,r.push(s))});const p=this.mapArgsToSignature(e);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function xa(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=a().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function ba(e,t,a,n=!1){const s=e[t];return null!=s?xa(s.s,n):a}function Ta(e,t,a){const n=e[t];return n?n.b:a}function _a(e,t,a){const n=e[t]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function Sa(e){switch("string"==typeof e&&(e=Bt[e]),e){case Bt.DT_FLOAT:return"float32";case Bt.DT_INT32:case Bt.DT_INT64:case Bt.DT_INT8:case Bt.DT_UINT8:return"int32";case Bt.DT_BOOL:return"bool";case Bt.DT_DOUBLE:return"float32";case Bt.DT_STRING:return"string";default:return null}}function Oa(e,t,a){const n=e[t];return n&&n.func?n.func.name:a}function wa(e,t,a){const n=e[t];return n&&n.type?Sa(n.type):a}function Aa(e,t,a){const n=e[t];return n&&n.list&&n.list.type?n.list.type.map(e=>Sa(e)):a}function Ea(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function va(e,t,a){const n=e[t];return n&&n.shape?Ea(n.shape):a}function Ia(e,t,a){const n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):a}function Da(e,t,a,n=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>xa(e,n)):a}function Ma(e,t,a){const n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map(e=>Ea(e)):a}function ka(e,t,a){const n=e[t];return n&&n.list&&n.list.b?n.list.b:a}class Va{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return Kt(e,this.tensorMap,this.context)}getAttr(e,t){const a=this.node.rawAttrs[e];if(null!=a.tensor)return Kt(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return _a(this.node.rawAttrs,e,t);if(null!=a.s)return ba(this.node.rawAttrs,e,t);if(null!=a.b)return Ta(this.node.rawAttrs,e,t);if(null!=a.shape)return va(this.node.rawAttrs,e,t);if(null!=a.type)return wa(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return Ia(this.node.rawAttrs,e,t);if(null!=a.list.s)return Da(this.node.rawAttrs,e,t);if(null!=a.list.shape)return Ma(this.node.rawAttrs,e,t);if(null!=a.list.b)return ka(this.node.rawAttrs,e,t);if(null!=a.list.type)return Aa(this.node.rawAttrs,e,t)}return t}}function za(t,a,n=""){if("number"!=typeof t&&"number"!=typeof a){e.assert(t.length===a.length,()=>n+` Shapes ${t} and ${a} must match`);for(let s=0;s<t.length;s++){const r=t[s],o=a[s];e.assert(r<0||o<0||r===o,()=>n+` Shapes ${t} and ${a} must match`)}}}function Ca(e){return"number"!=typeof e&&!e.some(e=>e<0)}function La(e,t,a){let n=Fa(e,a);const s=!Ca(n);if(s&&0===t.length)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+n);if(s&&t.forEach(e=>{n=Fa(e.shape,n)}),!Ca(n))throw new Error("Non-fully-defined elementShape: "+n);return n}function Fa(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const a=[];for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(s>=0&&r>=0&&s!==r)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);a[n]=s>=0?s:r}return a}class $a{constructor(e,t,a,r,o,p,i){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=p,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=n(0),s(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),za(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,s(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,a)=>this.write(e,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return r([],[0].concat(this.elementShape));const a=this.readMany(e);return za(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),o(a,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return r([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const a=this.readMany(t);return za(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),p(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,i(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0;const n=e.map(e=>(a+=e,a));if(a!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===a?0:t.size/a,r=[];m(()=>{t=u(t,[1,a,s]);for(let a=0;a<e.length;++a){const o=[0,0===a?0:n[a-1],0],p=[1,e[a],s];r[a]=u(d(t,o,p),this.elementShape)}return r});const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,r)}}class Ra{constructor(e,t,a,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,null!=e&&e.forEach(e=>{if(a!==e.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${e.dtype}`);za(t,e.shape,"TensorList shape mismatch: "),s(e)}),this.idTensor=n(0),this.maxNumElements=r,s(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ra([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);za(e,this.elementShape,"TensorList shape mismatch: ");const n=La(this.elementShape,this.tensors,e);return m(()=>{const e=this.tensors.map(e=>u(e,n));return o(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=La(this.elementShape,this.tensors,e),n=this.tensors.pop();return za(n.shape,e,"TensorList shape mismatch: "),u(n,a)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(za(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");s(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+e);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);za(this.tensors[e].shape,t,"TensorList shape mismatch: ");const n=La(this.elementShape,this.tensors,t);return u(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);za(this.elementShape,t.shape,"TensorList shape mismatch: "),s(t),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);za(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());const n=La(this.elementShape,this.tensors,a);return 0===e.length?r([],[0].concat(n)):m(()=>{const t=e.map(e=>u(this.tensors[e],n));return o(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);za(this.elementShape,t,"TensorList shape mismatch: ");const a=La(this.elementShape,this.tensors,t);return 0===this.size()?r([],[0].concat(a)):m(()=>{const e=this.tensors.map(e=>u(e,a));return p(e,0)})}}const ja=async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{const n=Qt("thenBranch",e,t,a),s=Qt("elseBranch",e,t,a),r=Qt("cond",e,t,a),o=Qt("args",e,t,a);return(await r.data())[0]?a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap):a.functionMap[s].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const n=Qt("body",e,t,a),s=Qt("cond",e,t,a),r=Qt("args",e,t,a),o=await a.functionMap[s].executeFunctionAsync(r,a.tensorArrayMap,a.tensorListMap),p=r.map(e=>e.id);let i=await o[0].data();o.forEach(e=>{e.kept||-1!==p.indexOf(e.id)||e.dispose()});let m=r;for(;i[0];){const e=m;m=await a.functionMap[n].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);const t=m.map(e=>e.id);e.forEach(e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const r=await a.functionMap[s].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);i=await r[0].data(),r.forEach(e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return m}case"LoopCond":return[ea(Qt("pred",e,t,a))];case"Switch":{const n=Qt("pred",e,t,a);let s=Qt("data",e,t,a);return s.kept||(s=ea(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=e.inputNames.find(e=>void 0!==Kt(e,t,a));if(n){return[ea(Kt(n,t,a))]}return}case"Enter":{const n=Qt("frameName",e,t,a),s=Qt("tensor",e,t,a);return a.enterFrame(n),[ea(s)]}case"Exit":{const n=Qt("tensor",e,t,a);return a.exitFrame(),[ea(n)]}case"NextIteration":{const n=Qt("tensor",e,t,a);return a.nextIteration(),[ea(n)]}case"TensorArrayV3":{const s=Qt("size",e,t,a),r=Qt("dtype",e,t,a),o=Qt("elementShape",e,t,a),p=Qt("dynamicSize",e,t,a),i=Qt("clearAfterRead",e,t,a),m=Qt("identicalElementShapes",e,t,a),u=Qt("name",e,t,a),d=new $a(u,r,s,o,m,p,i);return a.addTensorArray(d),[d.idTensor,n(1)]}case"TensorArrayWriteV3":{const n=Qt("tensorArrayId",e,t,a),s=Qt("index",e,t,a),r=Qt("tensor",e,t,a),o=a.getTensorArray(n.id);return o.write(s,r),[o.idTensor]}case"TensorArrayReadV3":{const n=Qt("tensorArrayId",e,t,a),s=Qt("index",e,t,a);return[a.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=Qt("tensorArrayId",e,t,a),s=Qt("indices",e,t,a),r=Qt("dtype",e,t,a);return[a.getTensorArray(n.id).gather(s,r)]}case"TensorArrayScatterV3":{const n=Qt("tensorArrayId",e,t,a),s=Qt("indices",e,t,a),r=Qt("tensor",e,t,a),o=a.getTensorArray(n.id);return o.scatter(s,r),[o.idTensor]}case"TensorArrayConcatV3":{const n=Qt("tensorArrayId",e,t,a),s=a.getTensorArray(n.id),r=Qt("dtype",e,t,a);return[s.concat(r)]}case"TensorArraySplitV3":{const n=Qt("tensorArrayId",e,t,a),s=Qt("tensor",e,t,a),r=Qt("lengths",e,t,a),o=a.getTensorArray(n.id);return o.split(r,s),[o.idTensor]}case"TensorArraySizeV3":{const s=Qt("tensorArrayId",e,t,a),r=a.getTensorArray(s.id);return[n(r.size(),"int32")]}case"TensorArrayCloseV3":{const n=Qt("tensorArrayId",e,t,a),s=a.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=Qt("tensorListId",e,t,a),s=Qt("index",e,t,a),r=Qt("tensor",e,t,a),o=a.getTensorList(n.id);return o.setItem(s,r),[o.idTensor]}case"TensorListGetItem":{const n=Qt("tensorListId",e,t,a),s=Qt("index",e,t,a),r=Qt("elementShape",e,t,a),o=Qt("elementDType",e,t,a);return[a.getTensorList(n.id).getItem(s,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=Qt("indices",e,t,a),s=function(e,t,a,n){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=n&&-1!==n&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const r=new Ra([],a,e.dtype,n),o=i(e,0);return t.forEach((e,t)=>{r.setItem(e,o[t])}),r}(Qt("tensor",e,t,a),n,Qt("elementShape",e,t,a),Qt("numElements",e,t,a));return a.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=Qt("elementShape",e,t,a),s=Qt("elementDType",e,t,a);let r;r="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=function(e,t,a){return new Ra([],e,t,a)}(n,s,Qt(r,e,t,a));return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=Qt("tensorListId",e,t,a),s=Qt("indices",e,t,a),r=Qt("elementShape",e,t,a),o=Qt("elementDType",e,t,a);return[a.getTensorList(n.id).gather(s,o,r)]}case"TensorListStack":{const n=Qt("tensorListId",e,t,a),s=Qt("elementShape",e,t,a),r=Qt("elementDType",e,t,a),o=Qt("numElements",e,t,a);return[a.getTensorList(n.id).stack(s,r,o)]}case"TensorListFromTensor":{const n=function(e,t,a){const n=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+e.shape);if(e.dtype!==a)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);za(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=i(e);return new Ra(s,t,n)}(Qt("tensor",e,t,a),Qt("elementShape",e,t,a),Qt("elementDType",e,t,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":{const n=Qt("tensorListId",e,t,a),s=a.getTensorList(n.id),r=Qt("dtype",e,t,a),o=Qt("elementShape",e,t,a);return[s.concat(r,o)]}case"TensorListPushBack":{const n=Qt("tensorListId",e,t,a),s=Qt("tensor",e,t,a),r=a.getTensorList(n.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const n=Qt("tensorListId",e,t,a),s=Qt("elementShape",e,t,a),r=Qt("elementDType",e,t,a);return[a.getTensorList(n.id).popBack(s,r)]}case"TensorListSplit":{const n=Qt("tensor",e,t,a),s=Qt("elementShape",e,t,a),r=function(e,t,a){let n=0;const s=t.map(e=>(n+=e,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);const r=Fa(e.shape.slice(1),a),o=0===n?0:e.size/n,p=m(()=>{const a=[];e=u(e,[1,n,o]);for(let n=0;n<t.length;++n){const p=[0,0===n?0:s[n-1],0],i=[1,t[n],o];a[n]=u(d(e,p,i),r)}return e.dispose(),a}),i=new Ra([],a,e.dtype,t.length);for(let e=0;e<p.length;e++)i.setItem(e,p[e]);return i}(n,Qt("lengths",e,t,a),s);return a.addTensorList(r),[r.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Pa(e,t,a){const[n,s]=Qt("fusedOps",e,t,a),r="biasadd"===n,o="prelu"===s,p="fusedbatchnorm"===n,i=Qt("numArgs",e,t,a);if(r){if(o&&2!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const m=Qt("strides",e,t,a),u=Jt(e,t,a),d=Qt("dataFormat",e,t,a).toUpperCase(),c=Qt("dilations",e,t,a),[y,l]=Qt("args",e,t,a);return{stride:m,pad:u,dataFormat:d,dilations:c,biasArg:y,preluArg:l,activationFunc:s,leakyreluAlpha:Qt("leakyreluAlpha",e,t,a)}}function Ba(e,t,a){return{boxes:Qt("boxes",e,t,a),scores:Qt("scores",e,t,a),maxOutputSize:Qt("maxOutputSize",e,t,a),iouThreshold:Qt("iouThreshold",e,t,a),scoreThreshold:Qt("scoreThreshold",e,t,a),softNmsSigma:Qt("softNmsSigma",e,t,a)}}class Ha{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=n(0),this.tensorMap=new Map,s(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(t,a){this.checkKeyAndValueTensor(t,a);const n=await t.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),m(()=>{const t=i(a),r=n.length,o=t.length;e.assert(r===o,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${o} elements.`);for(let e=0;e<r;e++){const a=n[e],r=t[e];s(r),this.tensorMap.set(a,r)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const a=await e.data();return m(()=>{const e=[];for(let n=0;n<a.length;n++){const s=a[n],r=this.findWithDefault(s,t);e.push(r)}return o(e)})}findWithDefault(e,t){const a=this.tensorMap.get(e);return null!=a?a:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got `+e.dtype);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got `+t.dtype)}}function Wa(t,a,n,s){const r=((t,a,n)=>{switch(t.category){case"arithmetic":return m(()=>((e,t,a)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[w(Qt("a",e,t,a),Qt("b",e,t,a))];case"AddN":return[O(Qt("tensors",e,t,a))];case"FloorMod":case"Mod":return[S(Qt("a",e,t,a),Qt("b",e,t,a))];case"Mul":return[_(Qt("a",e,t,a),Qt("b",e,t,a))];case"RealDiv":case"Div":return[T(Qt("a",e,t,a),Qt("b",e,t,a))];case"DivNoNan":return[b(Qt("a",e,t,a),Qt("b",e,t,a))];case"FloorDiv":return[x(Qt("a",e,t,a),Qt("b",e,t,a))];case"Sub":return[g(Qt("a",e,t,a),Qt("b",e,t,a))];case"Minimum":return[N(Qt("a",e,t,a),Qt("b",e,t,a))];case"Maximum":return[f(Qt("a",e,t,a),Qt("b",e,t,a))];case"Pow":return[h(Qt("a",e,t,a),Qt("b",e,t,a))];case"SquaredDifference":return[l(Qt("a",e,t,a),Qt("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"basic_math":return m(()=>((e,t,a)=>{switch(e.op){case"Abs":case"ComplexAbs":return[ce(Qt("x",e,t,a))];case"Acos":return[de(Qt("x",e,t,a))];case"Acosh":return[ue(Qt("x",e,t,a))];case"Asin":return[me(Qt("x",e,t,a))];case"Asinh":return[ie(Qt("x",e,t,a))];case"Atan":return[pe(Qt("x",e,t,a))];case"Atan2":return[oe(Qt("x",e,t,a),Qt("y",e,t,a))];case"Atanh":return[re(Qt("x",e,t,a))];case"Ceil":return[se(Qt("x",e,t,a))];case"Complex":return[ne(Qt("real",e,t,a),Qt("imag",e,t,a))];case"Cos":return[ae(Qt("x",e,t,a))];case"Cosh":return[te(Qt("x",e,t,a))];case"Elu":return[ee(Qt("x",e,t,a))];case"Erf":return[J(Qt("x",e,t,a))];case"Exp":return[Y(Qt("x",e,t,a))];case"Expm1":return[Z(Qt("x",e,t,a))];case"Floor":return[X(Qt("x",e,t,a))];case"Log":return[K(Qt("x",e,t,a))];case"Log1p":return[Q(Qt("x",e,t,a))];case"Imag":return[G(Qt("x",e,t,a))];case"Neg":return[q(Qt("x",e,t,a))];case"Reciprocal":return[U(Qt("x",e,t,a))];case"Real":return[W(Qt("x",e,t,a))];case"Relu":return[H(Qt("x",e,t,a))];case"Round":return[B(Qt("x",e,t,a))];case"Selu":return[P(Qt("x",e,t,a))];case"Sigmoid":return[j(Qt("x",e,t,a))];case"Sin":return[R(Qt("x",e,t,a))];case"Sign":return[$(Qt("x",e,t,a))];case"Sinh":return[F(Qt("x",e,t,a))];case"Softplus":return[L(Qt("x",e,t,a))];case"Sqrt":return[C(Qt("x",e,t,a))];case"Square":return[z(Qt("x",e,t,a))];case"Tanh":return[V(Qt("x",e,t,a))];case"Tan":return[k(Qt("x",e,t,a))];case"ClipByValue":return[M(Qt("x",e,t,a),Qt("clipValueMin",e,t,a),Qt("clipValueMax",e,t,a))];case"Relu6":return[D(Qt("x",e,t,a))];case"Rsqrt":return[I(Kt(e.inputNames[0],t,a))];case"Prod":return[v(Qt("x",e,t,a),Qt("axes",e,t,a))];case"LeakyRelu":return[E(Qt("x",e,t,a),Qt("alpha",e,t,a))];case"Prelu":return[A(Qt("x",e,t,a),Qt("alpha",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"control":return ja(t,a,n);case"convolution":return m(()=>((e,t,a)=>{switch(e.op){case"Conv1D":{const n=Qt("stride",e,t,a),s=Qt("pad",e,t,a),r=Qt("dataFormat",e,t,a).toUpperCase(),o=Qt("dilation",e,t,a);return[Oe(Qt("x",e,t,a),Qt("filter",e,t,a),n,s,r,o)]}case"Conv2D":{const n=Qt("strides",e,t,a),s=Jt(e,t,a),r=Qt("dataFormat",e,t,a).toUpperCase(),o=Qt("dilations",e,t,a);return[Se(Qt("x",e,t,a),Qt("filter",e,t,a),[n[1],n[2]],s,r,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m,leakyreluAlpha:u}=Pa(e,t,a);return[_e.conv2d({x:Qt("x",e,t,a),filter:Qt("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m,leakyreluAlpha:u}=Pa(e,t,a);return[_e.depthwiseConv2d({x:Qt("x",e,t,a),filter:Qt("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=Qt("outputShape",e,t,a),s=Qt("strides",e,t,a),r=Jt(e,t,a);return[Te(Qt("x",e,t,a),Qt("filter",e,t,a),n,[s[1],s[2]],r)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=Qt("strides",e,t,a),s=Jt(e,t,a),r=Qt("dilations",e,t,a),o=Qt("dataFormat",e,t,a).toUpperCase();return[be(Qt("input",e,t,a),Qt("filter",e,t,a),[n[1],n[2]],s,o,[r[1],r[2]])]}case"Conv3D":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("dataFormat",e,t,a).toUpperCase(),o=Qt("dilations",e,t,a);return[xe(Qt("x",e,t,a),Qt("filter",e,t,a),[n[1],n[2],n[3]],s,r,[o[1],o[2],o[3]])]}case"AvgPool":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("kernelSize",e,t,a);return[ge(Qt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("kernelSize",e,t,a);return[Ne(Qt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("kernelSize",e,t,a),o=Qt("includeBatchInIndex",e,t,a),{result:p,indexes:i}=fe(Qt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s,o);return[p,i]}case"AvgPool3D":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("kernelSize",e,t,a);return[he(Qt("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("kernelSize",e,t,a);return[le(Qt("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=Qt("strides",e,t,a),s=Qt("pad",e,t,a),r=Qt("dilations",e,t,a),o=n[1],p=n[2],i=r[1],m=r[2];return[ye(Qt("x",e,t,a),Qt("filter",e,t,a),[o,p],s,[i,m],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"creation":return m(()=>((e,t,a)=>{switch(e.op){case"Fill":{const n=Qt("shape",e,t,a),s=Qt("dtype",e,t,a),r=Qt("value",e,t,a);return[Ce(n,r,s)]}case"LinSpace":{const n=Qt("start",e,t,a),s=Qt("stop",e,t,a),r=Qt("num",e,t,a);return[ze(n,s,r)]}case"Multinomial":{const n=Qt("logits",e,t,a),s=Qt("numSamples",e,t,a),r=Qt("seed",e,t,a);return[Ve(n,s,r)]}case"OneHot":{const n=Qt("indices",e,t,a),s=Qt("depth",e,t,a),r=Qt("onValue",e,t,a),o=Qt("offValue",e,t,a);return[ke(n,s,r,o)]}case"Ones":return[Me(Qt("shape",e,t,a),Qt("dtype",e,t,a))];case"OnesLike":return[De(Qt("x",e,t,a))];case"RandomUniform":return[Ie(Qt("shape",e,t,a),Qt("minval",e,t,a),Qt("maxval",e,t,a),Qt("dtype",e,t,a))];case"Range":{const n=Qt("start",e,t,a),s=Qt("stop",e,t,a),r=Qt("step",e,t,a);return[ve(n,s,r,Qt("dtype",e,t,a))]}case"TruncatedNormal":{const n=Qt("shape",e,t,a),s=Qt("mean",e,t,a),r=Qt("stdDev",e,t,a),o=Qt("seed",e,t,a);return[Ee(n,s,r,Qt("dtype",e,t,a),o)]}case"Zeros":return[Ae(Qt("shape",e,t,a),Qt("dtype",e,t,a))];case"ZerosLike":return[we(Qt("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"dynamic":return(async(e,t,a)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p,softNmsSigma:i}=Ba(e,t,a),m=await Re.nonMaxSuppressionWithScoreAsync(n,s,r,o,p,i);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=Ba(e,t,a),i=Qt("padToMaxOutputSize",e,t,a),m=await Re.nonMaxSuppressionPaddedAsync(n,s,r,o,p,i);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=Ba(e,t,a);return[await Re.nonMaxSuppressionAsync(n,s,r,o,p)]}case"Where":{const n=Fe(Qt("condition",e,t,a),"bool"),s=[await $e(n)];return n.dispose(),s}case"ListDiff":return Le(Qt("x",e,t,a),Qt("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n);case"evaluation":return m(()=>((e,t,a)=>{switch(e.op){case"TopKV2":{const n=Qt("x",e,t,a),s=Qt("k",e,t,a),r=Qt("sorted",e,t,a),o=Pe(n,s,r);return[o.values,o.indices]}case"Unique":{const n=Qt("x",e,t,a),s=je(n);return[s.values,s.indices]}case"UniqueV2":{const n=Qt("x",e,t,a),s=Qt("axis",e,t,a),r=je(n,s);return[r.values,r.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"image":return m(()=>((e,t,a)=>{switch(e.op){case"ResizeBilinear":{const n=Qt("images",e,t,a),s=Qt("size",e,t,a),r=Qt("alignCorners",e,t,a),o=Qt("halfPixelCenters",e,t,a);return[Re.resizeBilinear(n,[s[0],s[1]],r,o)]}case"ResizeNearestNeighbor":{const n=Qt("images",e,t,a),s=Qt("size",e,t,a),r=Qt("alignCorners",e,t,a),o=Qt("halfPixelCenters",e,t,a);return[Re.resizeNearestNeighbor(n,[s[0],s[1]],r,o)]}case"CropAndResize":{const n=Qt("image",e,t,a),s=Qt("boxes",e,t,a),r=Qt("boxInd",e,t,a),o=Qt("cropSize",e,t,a),p=Qt("method",e,t,a),i=Qt("extrapolationValue",e,t,a);return[Re.cropAndResize(n,s,r,o,p,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"graph":return m(()=>((e,t,a)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const n=Qt("default",e,t,a);return[Kt(e.name,t,a)||n];case"Placeholder":return[Kt(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[ea(Qt("x",e,t,a))];case"IdentityN":return Qt("x",e,t,a).map(e=>ea(e));case"Snapshot":return[ea(Qt("x",e,t,a))];case"Shape":return[He(Qt("x",e,t,a).shape,"int32")];case"ShapeN":return Qt("x",e,t,a).map(e=>He(e.shape));case"Size":return[Be(Qt("x",e,t,a).size,"int32")];case"Rank":return[Be(Qt("x",e,t,a).rank,"int32")];case"NoOp":return[Be(1)];case"Print":const s=Qt("x",e,t,a),r=Qt("data",e,t,a),o=Qt("message",e,t,a),p=Qt("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<r.length;e++)console.log(Array.prototype.slice.call(r[e].dataSync()).slice(0,p));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"logical":return m(()=>((e,t,a)=>{switch(e.op){case"Equal":return[Je(Qt("a",e,t,a),Qt("b",e,t,a))];case"NotEqual":return[Ye(Qt("a",e,t,a),Qt("b",e,t,a))];case"Greater":return[Ze(Qt("a",e,t,a),Qt("b",e,t,a))];case"GreaterEqual":return[Xe(Qt("a",e,t,a),Qt("b",e,t,a))];case"Less":return[Ke(Qt("a",e,t,a),Qt("b",e,t,a))];case"LessEqual":return[Qe(Qt("a",e,t,a),Qt("b",e,t,a))];case"LogicalAnd":return[Ge(Qt("a",e,t,a),Qt("b",e,t,a))];case"LogicalNot":return[qe(Qt("a",e,t,a))];case"LogicalOr":return[Ue(Qt("a",e,t,a),Qt("b",e,t,a))];case"Select":case"SelectV2":return[We(Qt("condition",e,t,a),Qt("a",e,t,a),Qt("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"matrices":return m(()=>((e,t,a)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[tt(Qt("a",e,t,a),Qt("b",e,t,a),Qt("transposeA",e,t,a),Qt("transposeB",e,t,a))];case"Transpose":return[et(Qt("x",e,t,a),Qt("perm",e,t,a))];case"_FusedMatMul":const[n,s]=Qt("fusedOps",e,t,a),r="biasadd"===n,o="prelu"===s,p=Qt("numArgs",e,t,a),i=Qt("leakyreluAlpha",e,t,a);if(r){if(o&&2!==p)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==p)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[m,u]=Qt("args",e,t,a);return[_e.matMul({a:Qt("a",e,t,a),b:Qt("b",e,t,a),transposeA:Qt("transposeA",e,t,a),transposeB:Qt("transposeB",e,t,a),bias:m,activation:s,preluActivationWeights:u,leakyreluAlpha:i})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"normalization":return m(()=>((e,t,a)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[ot(Qt("x",e,t,a),Qt("mean",e,t,a),Qt("variance",e,t,a),Qt("offset",e,t,a),Qt("scale",e,t,a),Qt("epsilon",e,t,a))];case"LRN":return[rt(Qt("x",e,t,a),Qt("radius",e,t,a),Qt("bias",e,t,a),Qt("alpha",e,t,a),Qt("beta",e,t,a))];case"Softmax":return[st(Qt("x",e,t,a))];case"LogSoftmax":return[nt(Qt("x",e,t,a))];case"SparseToDense":return[at(Qt("sparseIndices",e,t,a),Qt("outputShape",e,t,a),Qt("sparseValues",e,t,a),Qt("defaultValue",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"reduction":return m(()=>((e,t,a)=>{switch(e.op){case"Max":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[Nt(Qt("x",e,t,a),n,s)]}case"Mean":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[ft(Qt("x",e,t,a),n,s)]}case"Min":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[ht(Qt("x",e,t,a),n,s)]}case"Sum":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[lt(Qt("x",e,t,a),n,s)]}case"All":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[yt(Qt("x",e,t,a),n,s)]}case"Any":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[ct(Qt("x",e,t,a),n,s)]}case"ArgMax":{const n=Qt("axis",e,t,a);return[dt(Qt("x",e,t,a),n)]}case"ArgMin":{const n=Qt("axis",e,t,a);return[ut(Qt("x",e,t,a),n)]}case"Prod":{const n=Qt("axis",e,t,a),s=Qt("keepDims",e,t,a);return[v(Qt("x",e,t,a),n,s)]}case"Cumsum":{const n=Qt("axis",e,t,a),s=Qt("exclusive",e,t,a),r=Qt("reverse",e,t,a);return[mt(Qt("x",e,t,a),n,s,r)]}case"Bincount":const n=Qt("x",e,t,a),s=Qt("weights",e,t,a),r=Qt("size",e,t,a);return[it(n,s,r)];case"DenseBincount":{const n=Qt("x",e,t,a),s=Qt("weights",e,t,a),r=Qt("size",e,t,a),o=Qt("binaryOutput",e,t,a);return[pt(n,s,r,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"slice_join":return m(()=>((t,a,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const e=Qt("n",t,a,n),s=Qt("axis",t,a,n);let r=Qt("tensors",t,a,n);return r=r.slice(0,e),[Dt(r,s)]}case"Gather":{const e=Qt("x",t,a,n),s=Qt("indices",t,a,n);return[It(e,Fe(s,"int32"),0)]}case"GatherV2":{const e=Qt("axis",t,a,n),s=Qt("batchDims",t,a,n),r=Qt("x",t,a,n),o=Qt("indices",t,a,n);return[It(r,Fe(o,"int32"),e,s)]}case"Reverse":{const e=Qt("dims",t,a,n),s=[];for(let t=0;t<e.length;t++)e[t]&&s.push(t);const r=Qt("x",t,a,n);return[vt(r,s)]}case"ReverseV2":{const e=Qt("axis",t,a,n),s=Qt("x",t,a,n);return[vt(s,e)]}case"Slice":{const e=Qt("begin",t,a,n),s=Qt("size",t,a,n);return[Et(Qt("x",t,a,n),e,s)]}case"StridedSlice":{const e=Qt("begin",t,a,n),s=Qt("end",t,a,n),r=Qt("strides",t,a,n),o=Qt("beginMask",t,a,n),p=Qt("endMask",t,a,n),i=Qt("ellipsisMask",t,a,n),m=Qt("newAxisMask",t,a,n),u=Qt("shrinkAxisMask",t,a,n),d=Qt("x",t,a,n);return[At(d,e,s,r,o,p,i,m,u)]}case"Pack":return m(()=>{const s=Qt("axis",t,a,n),r=Qt("tensors",t,a,n),o=r[0].shape,p=St(r[0]).shape,i=r.map(t=>{const a=e.arraysEqual(t.shape,o);if(!a&&!e.arraysEqual(St(t).shape,p))throw new Error("the input tensors shape does not match");return a?t:Ot(t,o)});return[wt(i,s)]});case"Unpack":{const e=Qt("axis",t,a,n),s=Qt("tensor",t,a,n);return _t(s,e)}case"Tile":{const e=Qt("reps",t,a,n);return[Tt(Qt("x",t,a,n),e)]}case"Split":case"SplitV":{const e=Qt("axis",t,a,n),s=Qt("numOrSizeSplits",t,a,n),r=Qt("x",t,a,n);return bt(r,s,e)}case"ScatterNd":{const e=Qt("indices",t,a,n),s=Qt("values",t,a,n),r=Qt("shape",t,a,n);return[xt(e,s,r)]}case"GatherNd":{const e=Qt("x",t,a,n),s=Qt("indices",t,a,n);return[gt(e,s)]}case"SparseToDense":{const e=Qt("sparseIndices",t,a,n),s=Qt("outputShape",t,a,n),r=Qt("sparseValues",t,a,n),o=Qt("defaultValue",t,a,n);return[at(e,r,s,r.dtype===o.dtype?o:Fe(o,r.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"spectral":return m(()=>((e,t,a)=>{switch(e.op){case"FFT":return[zt(Qt("x",e,t,a))];case"IFFT":return[Vt(Qt("x",e,t,a))];case"RFFT":return[kt(Qt("x",e,t,a))];case"IRFFT":return[Mt(Qt("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"transformation":return m(()=>((e,t,a)=>{switch(e.op){case"Cast":return[Fe(Qt("x",e,t,a),Qt("dtype",e,t,a))];case"ExpandDims":{const n=Qt("axis",e,t,a);return[Pt(Qt("x",e,t,a),n)]}case"Squeeze":{const n=Qt("axis",e,t,a);return[St(Qt("x",e,t,a),n)]}case"Reshape":return[Ot(Qt("x",e,t,a),Qt("shape",e,t,a))];case"MirrorPad":return[jt(Qt("x",e,t,a),Qt("padding",e,t,a),Qt("mode",e,t,a))];case"PadV2":case"Pad":return[Rt(Qt("x",e,t,a),Qt("padding",e,t,a),Qt("constantValue",e,t,a))];case"SpaceToBatchND":{const n=Qt("blockShape",e,t,a),s=Qt("paddings",e,t,a);return[$t(Qt("x",e,t,a),n,s)]}case"BatchToSpaceND":{const n=Qt("blockShape",e,t,a),s=Qt("crops",e,t,a);return[Ft(Qt("x",e,t,a),n,s)]}case"DepthToSpace":{const n=Qt("blockSize",e,t,a),s=Qt("dataFormat",e,t,a).toUpperCase();return[Lt(Qt("x",e,t,a),n,s)]}case"BroadcastTo":return[Ct(Qt("x",e,t,a),Qt("shape",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n));case"hash_table":return(async(e,t,a,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=Qt("keyDType",e,t,a),r=Qt("valueDType",e,t,a),o=new Ha(s,r);return n.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=Qt("tableHandle",e,t,a,n),r=Qt("keys",e,t,a),o=Qt("values",e,t,a),p=n.getHashTableById(s.id);return[await p.import(r,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=Qt("tableHandle",e,t,a,n),r=Qt("keys",e,t,a),o=Qt("defaultValue",e,t,a),p=n.getHashTableById(s.id);return[await p.find(r,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n,s);case"custom":const r=qt(t.op);if(r&&r.customExecutor)return r.customExecutor(new Va(t,a,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,a,n);return e.isPromise(r)?r.then(e=>[].concat(e)):[].concat(r)}class Ua{constructor(e={},t={},a={},n={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function qa(e,t,a,n){const s=new Set,r=[];let o=null,p=null;const i=new Set,m=Object.keys(e).map(e=>Yt(e)[0]);let u=[];null!=n&&(u=n.map(e=>Yt(e.name)[0]));const d=[...t];for(;d.length>0;){const e=d.pop();(Xa(e)||Za(e)||Ya(e))&&null==o&&(o=e,p=o.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==a[e.name]&&(-1===m.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{i.has(e.name)||(i.add(e.name),d.push(e))}):r.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:o,syncInputs:p}}const Ga=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Qa=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Ka=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function Xa(e){return Ga.indexOf(e.op)>=0}function Za(e){return Qa.indexOf(e.op)>=0}function Ya(e){return Ka.indexOf(e.op)>=0}class Ja{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new Ja(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const a=e.map(e=>e.name).sort(),n=t.map(e=>e.name).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(e,t){const a=qa(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(e,t,a){const{usedNodes:n,inputs:s}=a,r=[],o=Object.keys(s).map(e=>Yt(e)[0]).map(t=>e.nodes[t]),p=e.initNodes;o.forEach(e=>{n.has(e.name)&&r.push(e)}),e.weights.forEach(e=>{n.has(e.name)&&r.push(e)}),null!=p&&p.forEach(e=>{n.has(e.name)&&r.push(e)});const i=new Set,m=[];for(;r.length>0;){const e=r.pop();i.add(e.name),t[e.name]||m.push(e),e.children.forEach(e=>{!i.has(e.name)&&n.has(e.name)&&e.inputs.every(e=>i.has(e.name))&&r.push(e)})}return m}(this.graph,this.weightMap,a)}execute(t,a){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),a=this.mapOutputs(a),this.checkOutputs(a);const s=n.map(e=>this.graph.nodes[Yt(e)[0]]),r=a.map(e=>Yt(e)[0]);let o=r.map(e=>this.graph.nodes[e]);0===o.length&&(o=this._outputs);const p=this.getCompilationKey(s,o);let i=this.compiledMap.get(p);null==i&&(i=this.compile(t,o),this.compiledMap.set(p,i));const u={},d={};return m(()=>{const n=new Ua(this.weightMap,u,d,this.functionExecutorMap),s=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[a,n]=Yt(e),r=[];r[n]=t[e],s[a]=r});const o=this.getFrozenTensorIds(s),p={};for(let t=0;t<i.length;t++){const a=i[t];if(!s[a.name]){const t=Wa(a,s,n,this._resourceManager);if(e.isPromise(t))throw new Error(`The execution of the op '${a.op}' returned a promise. Please use model.executeAsync() instead.`);s[a.name]=t,this.checkTensorForDisposal(a.name,a,s,n,o,r,p)}}return null==this.parent&&n.dispose(o),a.map(e=>Kt(e,s,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,a,n,s,r,o){"control"!==t.category&&-1===r.indexOf(e)&&(a[e].forEach(e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const t=function(e,t,a){return t[Zt(e,a.currentContextId)]}(e.name,a,n);null!=t&&t.forEach(e=>{if(e&&!s.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,a=!1,n={},s={}){a||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const r=new Ua(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(e,r,t,a),p=t.map(e=>Kt(e,o,r)),i=p.map(e=>e.id),m=Object.keys(e).map(t=>e[t].id),u=new Set([...i,...m,...this.weightIds]);return Object.keys(o).forEach(e=>{o[e].forEach(e=>{!e||e.isDisposed||u.has(e.id)||e.dispose()})}),null==this.parent&&r.dispose(u),p}async executeFunctionAsync(e,t,a){const n=e.reduce((e,t,a)=>(e[this.inputs[a].name]=t,e),{});return this._executeAsync(n,this.outputNodes,!0,t,a)}async executeWithControlFlow(e,t,a,n){const s=Object.keys(e),r=s.map(e=>this.graph.nodes[Yt(e)[0]]),o=a.map(e=>Yt(e)[0]);let p=o.map(e=>this.graph.nodes[e]);0===p.length&&(p=this._outputs);const{usedNodes:i,missingInputs:m,dynamicNode:u,syncInputs:d}=qa(e,p,this.weightMap,this._initNodes),c=[...r,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),y=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[a,n]=Yt(t),s=[];s[n]=e[t],y[a]=s});const l={},h=this.getFrozenTensorIds(y),f={};for(;c.length>0;){const e=this.processStack(r,c,t,y,f,h,o,l,i);await Promise.all(e)}null!=u||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=p.filter(e=>!Xa(e)&&!Kt(e.name,y,t)).map(e=>e.name);if(N.length>0){let e="";throw null!=u&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${e}`)}return y}processStack(t,a,n,s,r,o,p,i,m){const u=[];for(;a.length>0;){const t=a.pop();n.currentContext=t.contexts;let d="";if("Enter"===t.node.op&&Qt("isConstant",t.node,s,n)&&([d]=Xt(t.node.name,n)),null==s[t.node.name]){const c=Wa(t.node,s,n,this._resourceManager);d||([d]=Xt(t.node.name,n));const y=n.currentContext;e.isPromise(c)?u.push(c.then(e=>(s[d]=e,n.currentContext=y,this.checkTensorForDisposal(d,t.node,s,n,o,p,i),this.processChildNodes(t.node,a,n,s,r,m),e))):(s[d]=c,this.checkTensorForDisposal(d,t.node,s,n,o,p,i),this.processChildNodes(t.node,a,n,s,r,m))}else this.processChildNodes(t.node,a,n,s,r,m)}return u}processChildNodes(e,t,a,n,s,r){e.children.forEach(e=>{const[o]=Xt(e.name,a);!s[o]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!Kt(e,n,a))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(e=>!!Kt(e,n,a))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(a=>{const n=t[a],[s]=Yt(a),r=this.graph.nodes[s];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value,a=t.length===n.shape.length&&n.shape.every((e,a)=>-1===t[a]||t[a]===e);e.assert(a,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&e.assert(n.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const a in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]){t[this._signature.inputs[a].name]=e[a]}else t[a]=e[a];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=Yt(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e},{})}checkOutputs(e){e.forEach(e=>{const[t]=Yt(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class en{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class tn{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new en}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=c.browserHTTPRequest(e,this.loadOptions);else{const t=c.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(c.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let a;a=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=a,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const n=c.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Ja(ga.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=ga.Instance.transformGraph(e.modelInitializer);this.initializer=new Ja(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=c.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof y||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,a,n)=>(t[a]=e[n],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,a)=>(t[a]=[e[a]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function an(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e+="model.json?tfjs-format=file");const a=new tn(e,t);return await a.load(),a}const nn="3.1.0";export{tn as GraphModel,Gt as deregisterOp,an as loadGraphModel,Ut as registerOp,nn as version_converter};
//# sourceMappingURL=tf-converter.fesm.min.js.map
