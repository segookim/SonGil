{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as spectral from './op_list/spectral';\nimport * as transformation from './op_list/transformation';\nexport var OperationMapper = /*#__PURE__*/function () {\n  // Loads the op mapping from the JSON file.\n  function OperationMapper() {\n    var _ref;\n\n    _classCallCheck(this, OperationMapper);\n\n    var ops = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation, hashTable];\n\n    var mappersJson = (_ref = []).concat.apply(_ref, _toConsumableArray(ops.map(function (op) {\n      return op.json;\n    })));\n\n    this.opMappers = mappersJson.reduce(function (map, mapper) {\n      map[mapper.tfOpName] = mapper;\n      return map;\n    }, {});\n  } // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n\n\n  _createClass(OperationMapper, [{\n    key: \"transformGraph\",\n    value: function transformGraph(graph) {\n      var _this = this;\n\n      var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tfNodes = graph.node;\n      var placeholders = [];\n      var weights = [];\n      var initNodes = [];\n      var nodes = tfNodes.reduce(function (map, node) {\n        map[node.name] = _this.mapNode(node);\n\n        if (node.op.startsWith('Placeholder')) {\n          placeholders.push(map[node.name]);\n        } else if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        } else if (node.input == null || node.input.length === 0) {\n          initNodes.push(map[node.name]);\n        }\n\n        return map;\n      }, {});\n      var inputs = [];\n      var outputs = [];\n      var inputNodeNameToKey = {};\n      var outputNodeNameToKey = {};\n\n      if (signature != null) {\n        inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n        outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n      }\n\n      var allNodes = Object.keys(nodes);\n      allNodes.forEach(function (key) {\n        var node = nodes[key];\n        node.inputNames.forEach(function (name) {\n          var _getNodeNameAndIndex = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex2 = _slicedToArray(_getNodeNameAndIndex, 1),\n              nodeName = _getNodeNameAndIndex2[0];\n\n          node.inputs.push(nodes[nodeName]);\n          nodes[nodeName].children.push(node);\n        });\n      }); // if signature has not outputs set, add any node that does not have\n      // outputs.\n\n      if (Object.keys(outputNodeNameToKey).length === 0) {\n        allNodes.forEach(function (key) {\n          var node = nodes[key];\n\n          if (node.children.length === 0) {\n            outputs.push(node);\n          }\n        });\n      } else {\n        Object.keys(outputNodeNameToKey).forEach(function (name) {\n          var _getNodeNameAndIndex3 = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex4 = _slicedToArray(_getNodeNameAndIndex3, 1),\n              nodeName = _getNodeNameAndIndex4[0];\n\n          var node = nodes[nodeName];\n\n          if (node != null) {\n            node.signatureKey = outputNodeNameToKey[name];\n            outputs.push(node);\n          }\n        });\n      }\n\n      if (Object.keys(inputNodeNameToKey).length > 0) {\n        Object.keys(inputNodeNameToKey).forEach(function (name) {\n          var _getNodeNameAndIndex5 = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex6 = _slicedToArray(_getNodeNameAndIndex5, 1),\n              nodeName = _getNodeNameAndIndex6[0];\n\n          var node = nodes[nodeName];\n\n          if (node) {\n            node.signatureKey = inputNodeNameToKey[name];\n            inputs.push(node);\n          }\n        });\n      } else {\n        inputs = placeholders;\n      }\n\n      var functions = {};\n\n      if (graph.library != null && graph.library.function != null) {\n        functions = graph.library.function.reduce(function (functions, func) {\n          functions[func.signature.name] = _this.mapFunction(func);\n          return functions;\n        }, {});\n      }\n\n      var result = {\n        nodes: nodes,\n        inputs: inputs,\n        outputs: outputs,\n        weights: weights,\n        placeholders: placeholders,\n        signature: signature,\n        functions: functions\n      };\n\n      if (initNodes.length > 0) {\n        result.initNodes = initNodes;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"mapSignatureEntries\",\n    value: function mapSignatureEntries(entries) {\n      return Object.keys(entries || {}).reduce(function (prev, curr) {\n        prev[entries[curr].name] = curr;\n        return prev;\n      }, {});\n    }\n  }, {\n    key: \"mapNode\",\n    value: function mapNode(node) {\n      // Unsupported ops will cause an error at run-time (not parse time), since\n      // they may not be used by the actual execution subgraph.\n      var mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n\n      if (node.attr == null) {\n        node.attr = {};\n      }\n\n      var newNode = {\n        name: node.name,\n        op: node.op,\n        category: mapper.category,\n        inputNames: (node.input || []).map(function (input) {\n          return input.startsWith('^') ? input.substr(1) : input;\n        }),\n        inputs: [],\n        children: [],\n        inputParams: {},\n        attrParams: {},\n        rawAttrs: node.attr\n      };\n\n      if (mapper.inputs != null) {\n        newNode.inputParams = mapper.inputs.reduce(function (map, param) {\n          map[param.name] = {\n            type: param.type,\n            inputIndexStart: param.start,\n            inputIndexEnd: param.end\n          };\n          return map;\n        }, {});\n      }\n\n      if (mapper.attrs != null) {\n        newNode.attrParams = mapper.attrs.reduce(function (map, param) {\n          var type = param.type;\n          var value = undefined;\n\n          switch (param.type) {\n            case 'string':\n              value = getStringParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'string[]':\n              value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'number':\n              value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'number[]':\n              value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'bool':\n              value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'bool[]':\n              value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'shape':\n              value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'shape[]':\n              value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'dtype':\n              value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'dtype[]':\n              value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'func':\n              value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n\n              break;\n\n            case 'tensor':\n            case 'tensors':\n              break;\n\n            default:\n              throw new Error(\"Unsupported param type: \".concat(param.type, \" for op: \").concat(node.op));\n          }\n\n          map[param.name] = {\n            value: value,\n            type: type\n          };\n          return map;\n        }, {});\n      }\n\n      return newNode;\n    } // map the TFunctionDef to TFJS graph object\n\n  }, {\n    key: \"mapFunction\",\n    value: function mapFunction(functionDef) {\n      var _this2 = this;\n\n      var tfNodes = functionDef.nodeDef;\n      var placeholders = [];\n      var weights = [];\n      var nodes = {};\n\n      if (tfNodes != null) {\n        nodes = tfNodes.reduce(function (map, node) {\n          map[node.name] = _this2.mapNode(node);\n\n          if (node.op === 'Const') {\n            weights.push(map[node.name]);\n          }\n\n          return map;\n        }, {});\n      }\n\n      var inputs = [];\n      var outputs = [];\n      functionDef.signature.inputArg.forEach(function (arg) {\n        var _getNodeNameAndIndex7 = getNodeNameAndIndex(arg.name),\n            _getNodeNameAndIndex8 = _slicedToArray(_getNodeNameAndIndex7, 1),\n            nodeName = _getNodeNameAndIndex8[0];\n\n        var node = {\n          name: nodeName,\n          op: 'Placeholder',\n          inputs: [],\n          inputNames: [],\n          category: 'graph',\n          inputParams: {},\n          attrParams: {\n            dtype: {\n              value: parseDtypeParam(arg.type),\n              type: 'dtype'\n            }\n          },\n          children: []\n        };\n        node.signatureKey = arg.name;\n        inputs.push(node);\n        nodes[nodeName] = node;\n      });\n      var allNodes = Object.keys(nodes);\n      allNodes.forEach(function (key) {\n        var node = nodes[key];\n        node.inputNames.forEach(function (name) {\n          var _getNodeNameAndIndex9 = getNodeNameAndIndex(name),\n              _getNodeNameAndIndex10 = _slicedToArray(_getNodeNameAndIndex9, 1),\n              nodeName = _getNodeNameAndIndex10[0];\n\n          node.inputs.push(nodes[nodeName]);\n          nodes[nodeName].children.push(node);\n        });\n      });\n      var returnNodeMap = functionDef.ret;\n      functionDef.signature.outputArg.forEach(function (output) {\n        var _getNodeNameAndIndex11 = getNodeNameAndIndex(returnNodeMap[output.name]),\n            _getNodeNameAndIndex12 = _slicedToArray(_getNodeNameAndIndex11, 2),\n            nodeName = _getNodeNameAndIndex12[0],\n            index = _getNodeNameAndIndex12[1];\n\n        var node = nodes[nodeName];\n\n        if (node != null) {\n          node.defaultOutput = index;\n          outputs.push(node);\n        }\n      });\n      var signature = this.mapArgsToSignature(functionDef);\n      return {\n        nodes: nodes,\n        inputs: inputs,\n        outputs: outputs,\n        weights: weights,\n        placeholders: placeholders,\n        signature: signature\n      };\n    }\n  }, {\n    key: \"mapArgsToSignature\",\n    value: function mapArgsToSignature(functionDef) {\n      var _this3 = this;\n\n      return {\n        methodName: functionDef.signature.name,\n        inputs: functionDef.signature.inputArg.reduce(function (map, arg) {\n          map[arg.name] = _this3.mapArgToTensorInfo(arg);\n          return map;\n        }, {}),\n        outputs: functionDef.signature.outputArg.reduce(function (map, arg) {\n          map[arg.name] = _this3.mapArgToTensorInfo(arg, functionDef.ret);\n          return map;\n        }, {})\n      };\n    }\n  }, {\n    key: \"mapArgToTensorInfo\",\n    value: function mapArgToTensorInfo(arg, nameMap) {\n      var name = arg.name;\n\n      if (nameMap != null) {\n        name = nameMap[name];\n      }\n\n      return {\n        name: name,\n        dtype: arg.type\n      };\n    }\n  }], [{\n    key: \"Instance\",\n    get: // Singleton instance for the mapper\n    function get() {\n      return this._instance || (this._instance = new this());\n    }\n  }]);\n\n  return OperationMapper;\n}();\nexport function decodeBase64(text) {\n  var global = env().global;\n\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error('Unable to decode base64 in this environment. ' + 'Missing built-in atob() or Buffer()');\n  }\n}\nexport function parseStringParam(s, keepCase) {\n  var value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def) {\n  var keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var param = attrs[name];\n\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n\n  return def;\n}\nexport function getBoolParam(attrs, name, def) {\n  var param = attrs[name];\n  return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n  var param = attrs[name] || {};\n  var value = param['i'] != null ? param['i'] : param['f'] != null ? param['f'] : def;\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n  if (typeof value === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value];\n  }\n\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n      return 'float32';\n\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\nexport function getFuncParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.func) {\n    return param.func.name;\n  }\n\n  return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n\n  return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(function (v) {\n      return parseDtypeParam(v);\n    });\n  }\n\n  return def;\n}\nexport function parseTensorShapeParam(shape) {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n\n  if (shape.dim != null) {\n    return shape.dim.map(function (dim) {\n      return typeof dim.size === 'number' ? dim.size : parseInt(dim.size, 10);\n    });\n  }\n\n  return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n\n  return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(function (v) {\n      return typeof v === 'number' ? v : parseInt(v, 10);\n    });\n  }\n\n  return def;\n}\nexport function getStringArrayParam(attrs, name, def) {\n  var keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var param = attrs[name];\n\n  if (param && param.list && param.list.s) {\n    return param.list.s.map(function (v) {\n      return parseStringParam(v, keepCase);\n    });\n  }\n\n  return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map(function (v) {\n      return parseTensorShapeParam(v);\n    });\n  }\n\n  return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n  var param = attrs[name];\n\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n\n  return def;\n}","map":{"version":3,"sources":["../../src/operations/operation_mapper.ts"],"names":[],"mappings":";;;;;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkB,GAAlB,QAA4B,uBAA5B;AAEA,OAAO,KAAK,UAAZ,MAA4B,sBAA5B;AAEA,SAAQ,eAAR,QAA8B,sBAA9B;AACA,SAAQ,mBAAR,QAAkC,mBAAlC;AACA,OAAO,KAAK,UAAZ,MAA4B,sBAA5B;AACA,OAAO,KAAK,SAAZ,MAA2B,sBAA3B;AACA,OAAO,KAAK,OAAZ,MAAyB,mBAAzB;AACA,OAAO,KAAK,WAAZ,MAA6B,uBAA7B;AACA,OAAO,KAAK,QAAZ,MAA0B,oBAA1B;AACA,OAAO,KAAK,OAAZ,MAAyB,mBAAzB;AACA,OAAO,KAAK,UAAZ,MAA4B,sBAA5B;AACA,OAAO,KAAK,KAAZ,MAAuB,iBAAvB;AACA,OAAO,KAAK,SAAZ,MAA2B,sBAA3B;AACA,OAAO,KAAK,KAAZ,MAAuB,iBAAvB;AACA,OAAO,KAAK,OAAZ,MAAyB,mBAAzB;AACA,OAAO,KAAK,QAAZ,MAA0B,oBAA1B;AACA,OAAO,KAAK,aAAZ,MAA+B,yBAA/B;AACA,OAAO,KAAK,SAAZ,MAA2B,qBAA3B;AACA,OAAO,KAAK,SAAZ,MAA2B,sBAA3B;AACA,OAAO,KAAK,QAAZ,MAA0B,oBAA1B;AACA,OAAO,KAAK,cAAZ,MAAgC,0BAAhC;AAGA,WAAa,eAAb;AAUE;AACA,6BAAA;AAAA;;AAAA;;AACE,QAAM,GAAG,GAAG,CACV,UADU,EACE,SADF,EACa,OADb,EACsB,WADtB,EACmC,QADnC,EAC6C,OAD7C,EAEV,UAFU,EAEE,OAFF,EAEW,KAFX,EAEkB,KAFlB,EAEyB,QAFzB,EAEmC,aAFnC,EAEkD,SAFlD,EAGV,SAHU,EAGC,QAHD,EAGW,cAHX,EAG2B,SAH3B,CAAZ;;AAKA,QAAM,WAAW,GAAe,YAAG,MAAH,gCAAa,GAAG,CAAC,GAAJ,CAAQ,UAAA,EAAE;AAAA,aAAI,EAAE,CAAC,IAAP;AAAA,KAAV,CAAb,EAAhC;;AAEA,SAAK,SAAL,GAAiB,WAAW,CAAC,MAAZ,CACb,UAAC,GAAD,EAAM,MAAN,EAA0B;AACxB,MAAA,GAAG,CAAC,MAAM,CAAC,QAAR,CAAH,GAAuB,MAAvB;AACA,aAAO,GAAP;AACD,KAJY,EAKb,EALa,CAAjB;AAMD,GAzBH,CA2BE;AACA;;;AA5BF;AAAA;AAAA,WA6BE,wBACI,KADJ,EAE4C;AAAA;;AAAA,UAAxC,SAAwC,uEAAF,EAAE;AAC1C,UAAM,OAAO,GAAG,KAAK,CAAC,IAAtB;AACA,UAAM,YAAY,GAAW,EAA7B;AACA,UAAM,OAAO,GAAW,EAAxB;AACA,UAAM,SAAS,GAAW,EAA1B;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,MAAR,CAAsC,UAAC,GAAD,EAAM,IAAN,EAAc;AAChE,QAAA,GAAG,CAAC,IAAI,CAAC,IAAN,CAAH,GAAiB,KAAI,CAAC,OAAL,CAAa,IAAb,CAAjB;;AACA,YAAI,IAAI,CAAC,EAAL,CAAQ,UAAR,CAAmB,aAAnB,CAAJ,EAAuC;AACrC,UAAA,YAAY,CAAC,IAAb,CAAkB,GAAG,CAAC,IAAI,CAAC,IAAN,CAArB;AACD,SAFD,MAEO,IAAI,IAAI,CAAC,EAAL,KAAY,OAAhB,EAAyB;AAC9B,UAAA,OAAO,CAAC,IAAR,CAAa,GAAG,CAAC,IAAI,CAAC,IAAN,CAAhB;AACD,SAFM,MAEA,IAAI,IAAI,CAAC,KAAL,IAAc,IAAd,IAAsB,IAAI,CAAC,KAAL,CAAW,MAAX,KAAsB,CAAhD,EAAmD;AACxD,UAAA,SAAS,CAAC,IAAV,CAAe,GAAG,CAAC,IAAI,CAAC,IAAN,CAAlB;AACD;;AACD,eAAO,GAAP;AACD,OAVa,EAUX,EAVW,CAAd;AAYA,UAAI,MAAM,GAAW,EAArB;AACA,UAAM,OAAO,GAAW,EAAxB;AACA,UAAI,kBAAkB,GAA4B,EAAlD;AACA,UAAI,mBAAmB,GAA4B,EAAnD;;AACA,UAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,QAAA,kBAAkB,GAAG,KAAK,mBAAL,CAAyB,SAAS,CAAC,MAAnC,CAArB;AACA,QAAA,mBAAmB,GAAG,KAAK,mBAAL,CAAyB,SAAS,CAAC,OAAnC,CAAtB;AACD;;AACD,UAAM,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAjB;AACA,MAAA,QAAQ,CAAC,OAAT,CAAiB,UAAA,GAAG,EAAG;AACrB,YAAM,IAAI,GAAG,KAAK,CAAC,GAAD,CAAlB;AACA,QAAA,IAAI,CAAC,UAAL,CAAgB,OAAhB,CAAwB,UAAA,IAAI,EAAG;AAAA,qCACR,mBAAmB,CAAC,IAAD,CADX;AAAA;AAAA,cACtB,QADsB;;AAE7B,UAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,KAAK,CAAC,QAAD,CAAtB;AACA,UAAA,KAAK,CAAC,QAAD,CAAL,CAAgB,QAAhB,CAAyB,IAAzB,CAA8B,IAA9B;AACD,SAJD;AAKD,OAPD,EA1B0C,CAmC1C;AACA;;AACA,UAAI,MAAM,CAAC,IAAP,CAAY,mBAAZ,EAAiC,MAAjC,KAA4C,CAAhD,EAAmD;AACjD,QAAA,QAAQ,CAAC,OAAT,CAAiB,UAAA,GAAG,EAAG;AACrB,cAAM,IAAI,GAAG,KAAK,CAAC,GAAD,CAAlB;;AACA,cAAI,IAAI,CAAC,QAAL,CAAc,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,YAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AACD;AACF,SALD;AAMD,OAPD,MAOO;AACL,QAAA,MAAM,CAAC,IAAP,CAAY,mBAAZ,EAAiC,OAAjC,CAAyC,UAAA,IAAI,EAAG;AAAA,sCACzB,mBAAmB,CAAC,IAAD,CADM;AAAA;AAAA,cACvC,QADuC;;AAE9C,cAAM,IAAI,GAAG,KAAK,CAAC,QAAD,CAAlB;;AACA,cAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,YAAA,IAAI,CAAC,YAAL,GAAoB,mBAAmB,CAAC,IAAD,CAAvC;AACA,YAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AACD;AACF,SAPD;AAQD;;AAED,UAAI,MAAM,CAAC,IAAP,CAAY,kBAAZ,EAAgC,MAAhC,GAAyC,CAA7C,EAAgD;AAC9C,QAAA,MAAM,CAAC,IAAP,CAAY,kBAAZ,EAAgC,OAAhC,CAAwC,UAAA,IAAI,EAAG;AAAA,sCACxB,mBAAmB,CAAC,IAAD,CADK;AAAA;AAAA,cACtC,QADsC;;AAE7C,cAAM,IAAI,GAAG,KAAK,CAAC,QAAD,CAAlB;;AACA,cAAI,IAAJ,EAAU;AACR,YAAA,IAAI,CAAC,YAAL,GAAoB,kBAAkB,CAAC,IAAD,CAAtC;AACA,YAAA,MAAM,CAAC,IAAP,CAAY,IAAZ;AACD;AACF,SAPD;AAQD,OATD,MASO;AACL,QAAA,MAAM,GAAG,YAAT;AACD;;AAED,UAAI,SAAS,GAAG,EAAhB;;AACA,UAAI,KAAK,CAAC,OAAN,IAAiB,IAAjB,IAAyB,KAAK,CAAC,OAAN,CAAc,QAAd,IAA0B,IAAvD,EAA6D;AAC3D,QAAA,SAAS,GAAG,KAAK,CAAC,OAAN,CAAc,QAAd,CAAuB,MAAvB,CAA8B,UAAC,SAAD,EAAY,IAAZ,EAAoB;AAC5D,UAAA,SAAS,CAAC,IAAI,CAAC,SAAL,CAAe,IAAhB,CAAT,GAAiC,KAAI,CAAC,WAAL,CAAiB,IAAjB,CAAjC;AACA,iBAAO,SAAP;AACD,SAHW,EAGT,EAHS,CAAZ;AAID;;AAED,UAAM,MAAM,GACR;AAAC,QAAA,KAAK,EAAL,KAAD;AAAQ,QAAA,MAAM,EAAN,MAAR;AAAgB,QAAA,OAAO,EAAP,OAAhB;AAAyB,QAAA,OAAO,EAAP,OAAzB;AAAkC,QAAA,YAAY,EAAZ,YAAlC;AAAgD,QAAA,SAAS,EAAT,SAAhD;AAA2D,QAAA,SAAS,EAAT;AAA3D,OADJ;;AAGA,UAAI,SAAS,CAAC,MAAV,GAAmB,CAAvB,EAA0B;AACxB,QAAA,MAAM,CAAC,SAAP,GAAmB,SAAnB;AACD;;AAED,aAAO,MAAP;AACD;AAnHH;AAAA;AAAA,WAqHU,6BAAoB,OAApB,EAAkE;AACxE,aAAO,MAAM,CAAC,IAAP,CAAY,OAAO,IAAI,EAAvB,EACF,MADE,CAC8B,UAAC,IAAD,EAAO,IAAP,EAAe;AAC9C,QAAA,IAAI,CAAC,OAAO,CAAC,IAAD,CAAP,CAAc,IAAf,CAAJ,GAA2B,IAA3B;AACA,eAAO,IAAP;AACD,OAJE,EAIA,EAJA,CAAP;AAKD;AA3HH;AAAA;AAAA,WA6HU,iBAAQ,IAAR,EAAiC;AACvC;AACA;AACA,UAAM,MAAM,GACR,eAAe,CAAC,IAAI,CAAC,EAAN,CAAf,IAA4B,KAAK,SAAL,CAAe,IAAI,CAAC,EAApB,CAA5B,IAAuD,EAD3D;;AAEA,UAAI,IAAI,CAAC,IAAL,IAAa,IAAjB,EAAuB;AACrB,QAAA,IAAI,CAAC,IAAL,GAAY,EAAZ;AACD;;AAED,UAAM,OAAO,GAAS;AACpB,QAAA,IAAI,EAAE,IAAI,CAAC,IADS;AAEpB,QAAA,EAAE,EAAE,IAAI,CAAC,EAFW;AAGpB,QAAA,QAAQ,EAAE,MAAM,CAAC,QAHG;AAIpB,QAAA,UAAU,EACN,CAAC,IAAI,CAAC,KAAL,IACA,EADD,EACK,GADL,CACS,UAAA,KAAK;AAAA,iBAAI,KAAK,CAAC,UAAN,CAAiB,GAAjB,IAAwB,KAAK,CAAC,MAAN,CAAa,CAAb,CAAxB,GAA0C,KAA9C;AAAA,SADd,CALgB;AAOpB,QAAA,MAAM,EAAE,EAPY;AAQpB,QAAA,QAAQ,EAAE,EARU;AASpB,QAAA,WAAW,EAAE,EATO;AAUpB,QAAA,UAAU,EAAE,EAVQ;AAWpB,QAAA,QAAQ,EAAE,IAAI,CAAC;AAXK,OAAtB;;AAcA,UAAI,MAAM,CAAC,MAAP,IAAiB,IAArB,EAA2B;AACzB,QAAA,OAAO,CAAC,WAAR,GACI,MAAM,CAAC,MAAP,CAAc,MAAd,CACI,UAAC,GAAD,EAAM,KAAN,EAAe;AACb,UAAA,GAAG,CAAC,KAAK,CAAC,IAAP,CAAH,GAAkB;AAChB,YAAA,IAAI,EAAE,KAAK,CAAC,IADI;AAEhB,YAAA,eAAe,EAAE,KAAK,CAAC,KAFP;AAGhB,YAAA,aAAa,EAAE,KAAK,CAAC;AAHL,WAAlB;AAKA,iBAAO,GAAP;AACD,SARL,EASI,EATJ,CADJ;AAWD;;AACD,UAAI,MAAM,CAAC,KAAP,IAAgB,IAApB,EAA0B;AACxB,QAAA,OAAO,CAAC,UAAR,GACI,MAAM,CAAC,KAAP,CAAa,MAAb,CAAiD,UAAC,GAAD,EAAM,KAAN,EAAe;AAC9D,cAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;AACA,cAAI,KAAK,GAAG,SAAZ;;AACA,kBAAQ,KAAK,CAAC,IAAd;AACE,iBAAK,QAAL;AACE,cAAA,KAAK,GAAG,cAAc,CAClB,IAAI,CAAC,IADa,EACP,KAAK,CAAC,MADC,EACO,KAAK,CAAC,YADb,CAAtB;;AAGA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,cAAc,CAClB,IAAI,CAAC,IADa,EACP,KAAK,CAAC,gBADC,EAElB,KAAK,CAAC,YAFY,CAAtB;AAGD;;AACD;;AACF,iBAAK,UAAL;AACE,cAAA,KAAK,GAAG,mBAAmB,CACvB,IAAI,CAAC,IADkB,EACZ,KAAK,CAAC,MADM,EACE,KAAK,CAAC,YADR,CAA3B;;AAGA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,mBAAmB,CACvB,IAAI,CAAC,IADkB,EACZ,KAAK,CAAC,gBADM,EAEvB,KAAK,CAAC,YAFiB,CAA3B;AAGD;;AACD;;AACF,iBAAK,QAAL;AACE,cAAA,KAAK,GAAG,cAAc,CAClB,IAAI,CAAC,IADa,EACP,KAAK,CAAC,MADC,EAEjB,KAAK,CAAC,YAAN,IAAsB,CAFL,CAAtB;;AAGA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,cAAc,CAClB,IAAI,CAAC,IADa,EACP,KAAK,CAAC,gBADC,EAElB,KAAK,CAAC,YAFY,CAAtB;AAGD;;AACD;;AACF,iBAAK,UAAL;AACE,cAAA,KAAK,GAAG,oBAAoB,CACxB,IAAI,CAAC,IADmB,EACb,KAAK,CAAC,MADO,EACC,KAAK,CAAC,YADP,CAA5B;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,oBAAoB,CACxB,IAAI,CAAC,IADmB,EACb,KAAK,CAAC,gBADO,EAExB,KAAK,CAAC,YAFkB,CAA5B;AAGD;;AACD;;AACF,iBAAK,MAAL;AACE,cAAA,KAAK,GAAG,YAAY,CAChB,IAAI,CAAC,IADW,EACL,KAAK,CAAC,MADD,EACS,KAAK,CAAC,YADf,CAApB;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,YAAY,CAChB,IAAI,CAAC,IADW,EACL,KAAK,CAAC,gBADD,EAEhB,KAAK,CAAC,YAFU,CAApB;AAGD;;AACD;;AACF,iBAAK,QAAL;AACE,cAAA,KAAK,GAAG,iBAAiB,CACrB,IAAI,CAAC,IADgB,EACV,KAAK,CAAC,MADI,EACI,KAAK,CAAC,YADV,CAAzB;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,iBAAiB,CACrB,IAAI,CAAC,IADgB,EACV,KAAK,CAAC,gBADI,EAErB,KAAK,CAAC,YAFe,CAAzB;AAGD;;AACD;;AACF,iBAAK,OAAL;AACE,cAAA,KAAK,GAAG,mBAAmB,CACvB,IAAI,CAAC,IADkB,EACZ,KAAK,CAAC,MADM,EACE,KAAK,CAAC,YADR,CAA3B;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,mBAAmB,CACvB,IAAI,CAAC,IADkB,EACZ,KAAK,CAAC,gBADM,EAEvB,KAAK,CAAC,YAFiB,CAA3B;AAGD;;AACD;;AACF,iBAAK,SAAL;AACE,cAAA,KAAK,GAAG,wBAAwB,CAC5B,IAAI,CAAC,IADuB,EACjB,KAAK,CAAC,MADW,EACH,KAAK,CAAC,YADH,CAAhC;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,wBAAwB,CAC5B,IAAI,CAAC,IADuB,EACjB,KAAK,CAAC,gBADW,EAE5B,KAAK,CAAC,YAFsB,CAAhC;AAGD;;AACD;;AACF,iBAAK,OAAL;AACE,cAAA,KAAK,GAAG,aAAa,CACjB,IAAI,CAAC,IADY,EACN,KAAK,CAAC,MADA,EACQ,KAAK,CAAC,YADd,CAArB;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,aAAa,CACjB,IAAI,CAAC,IADY,EACN,KAAK,CAAC,gBADA,EAEjB,KAAK,CAAC,YAFW,CAArB;AAGD;;AACD;;AACF,iBAAK,SAAL;AACE,cAAA,KAAK,GAAG,kBAAkB,CACtB,IAAI,CAAC,IADiB,EACX,KAAK,CAAC,MADK,EACG,KAAK,CAAC,YADT,CAA1B;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,kBAAkB,CACtB,IAAI,CAAC,IADiB,EACX,KAAK,CAAC,gBADK,EAEtB,KAAK,CAAC,YAFgB,CAA1B;AAGD;;AACD;;AACF,iBAAK,MAAL;AACE,cAAA,KAAK,GAAG,YAAY,CAChB,IAAI,CAAC,IADW,EACL,KAAK,CAAC,MADD,EACS,KAAK,CAAC,YADf,CAApB;;AAEA,kBAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,CAAC,KAAK,CAAC,gBAAnC,EAAqD;AACnD,gBAAA,KAAK,GAAG,YAAY,CAChB,IAAI,CAAC,IADW,EACL,KAAK,CAAC,gBADD,EAEhB,KAAK,CAAC,YAFU,CAApB;AAGD;;AACD;;AACF,iBAAK,QAAL;AACA,iBAAK,SAAL;AACE;;AACF;AACE,oBAAM,IAAI,KAAJ,mCACyB,KAAK,CAAC,IAD/B,sBAC+C,IAAI,CAAC,EADpD,EAAN;AA3GJ;;AA8GA,UAAA,GAAG,CAAC,KAAK,CAAC,IAAP,CAAH,GAAkB;AAAC,YAAA,KAAK,EAAL,KAAD;AAAQ,YAAA,IAAI,EAAJ;AAAR,WAAlB;AACA,iBAAO,GAAP;AACD,SAnHD,EAmHG,EAnHH,CADJ;AAqHD;;AACD,aAAO,OAAP;AACD,KAzRH,CA2RE;;AA3RF;AAAA;AAAA,WA4RU,qBAAY,WAAZ,EAAgD;AAAA;;AACtD,UAAM,OAAO,GAAG,WAAW,CAAC,OAA5B;AACA,UAAM,YAAY,GAAW,EAA7B;AACA,UAAM,OAAO,GAAW,EAAxB;AACA,UAAI,KAAK,GAA0B,EAAnC;;AACA,UAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,QAAA,KAAK,GAAG,OAAO,CAAC,MAAR,CAAsC,UAAC,GAAD,EAAM,IAAN,EAAc;AAC1D,UAAA,GAAG,CAAC,IAAI,CAAC,IAAN,CAAH,GAAiB,MAAI,CAAC,OAAL,CAAa,IAAb,CAAjB;;AACA,cAAI,IAAI,CAAC,EAAL,KAAY,OAAhB,EAAyB;AACvB,YAAA,OAAO,CAAC,IAAR,CAAa,GAAG,CAAC,IAAI,CAAC,IAAN,CAAhB;AACD;;AACD,iBAAO,GAAP;AACD,SANO,EAML,EANK,CAAR;AAOD;;AACD,UAAM,MAAM,GAAW,EAAvB;AACA,UAAM,OAAO,GAAW,EAAxB;AAEA,MAAA,WAAW,CAAC,SAAZ,CAAsB,QAAtB,CAA+B,OAA/B,CAAuC,UAAA,GAAG,EAAG;AAAA,oCACtB,mBAAmB,CAAC,GAAG,CAAC,IAAL,CADG;AAAA;AAAA,YACpC,QADoC;;AAE3C,YAAM,IAAI,GAAS;AACjB,UAAA,IAAI,EAAE,QADW;AAEjB,UAAA,EAAE,EAAE,aAFa;AAGjB,UAAA,MAAM,EAAE,EAHS;AAIjB,UAAA,UAAU,EAAE,EAJK;AAKjB,UAAA,QAAQ,EAAE,OALO;AAMjB,UAAA,WAAW,EAAE,EANI;AAOjB,UAAA,UAAU,EAAE;AAAC,YAAA,KAAK,EAAE;AAAC,cAAA,KAAK,EAAE,eAAe,CAAC,GAAG,CAAC,IAAL,CAAvB;AAAmC,cAAA,IAAI,EAAE;AAAzC;AAAR,WAPK;AAQjB,UAAA,QAAQ,EAAE;AARO,SAAnB;AAUA,QAAA,IAAI,CAAC,YAAL,GAAoB,GAAG,CAAC,IAAxB;AACA,QAAA,MAAM,CAAC,IAAP,CAAY,IAAZ;AACA,QAAA,KAAK,CAAC,QAAD,CAAL,GAAkB,IAAlB;AACD,OAfD;AAiBA,UAAM,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAjB;AACA,MAAA,QAAQ,CAAC,OAAT,CAAiB,UAAA,GAAG,EAAG;AACrB,YAAM,IAAI,GAAG,KAAK,CAAC,GAAD,CAAlB;AACA,QAAA,IAAI,CAAC,UAAL,CAAgB,OAAhB,CAAwB,UAAA,IAAI,EAAG;AAAA,sCACR,mBAAmB,CAAC,IAAD,CADX;AAAA;AAAA,cACtB,QADsB;;AAE7B,UAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,KAAK,CAAC,QAAD,CAAtB;AACA,UAAA,KAAK,CAAC,QAAD,CAAL,CAAgB,QAAhB,CAAyB,IAAzB,CAA8B,IAA9B;AACD,SAJD;AAKD,OAPD;AASA,UAAM,aAAa,GAAG,WAAW,CAAC,GAAlC;AAEA,MAAA,WAAW,CAAC,SAAZ,CAAsB,SAAtB,CAAgC,OAAhC,CAAwC,UAAA,MAAM,EAAG;AAAA,qCACrB,mBAAmB,CAAC,aAAa,CAAC,MAAM,CAAC,IAAR,CAAd,CADE;AAAA;AAAA,YACxC,QADwC;AAAA,YAC9B,KAD8B;;AAE/C,YAAM,IAAI,GAAG,KAAK,CAAC,QAAD,CAAlB;;AACA,YAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,UAAA,IAAI,CAAC,aAAL,GAAqB,KAArB;AACA,UAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AACD;AACF,OAPD;AASA,UAAM,SAAS,GAAG,KAAK,kBAAL,CAAwB,WAAxB,CAAlB;AACA,aAAO;AAAC,QAAA,KAAK,EAAL,KAAD;AAAQ,QAAA,MAAM,EAAN,MAAR;AAAgB,QAAA,OAAO,EAAP,OAAhB;AAAyB,QAAA,OAAO,EAAP,OAAzB;AAAkC,QAAA,YAAY,EAAZ,YAAlC;AAAgD,QAAA,SAAS,EAAT;AAAhD,OAAP;AACD;AArVH;AAAA;AAAA,WAuVU,4BAAmB,WAAnB,EAAuD;AAAA;;AAE7D,aAAO;AACL,QAAA,UAAU,EAAE,WAAW,CAAC,SAAZ,CAAsB,IAD7B;AAEL,QAAA,MAAM,EAAE,WAAW,CAAC,SAAZ,CAAsB,QAAtB,CAA+B,MAA/B,CACJ,UAAC,GAAD,EAAM,GAAN,EAAa;AACX,UAAA,GAAG,CAAC,GAAG,CAAC,IAAL,CAAH,GAAgB,MAAI,CAAC,kBAAL,CAAwB,GAAxB,CAAhB;AACA,iBAAO,GAAP;AACD,SAJG,EAKJ,EALI,CAFH;AAQL,QAAA,OAAO,EAAE,WAAW,CAAC,SAAZ,CAAsB,SAAtB,CAAgC,MAAhC,CACL,UAAC,GAAD,EAAM,GAAN,EAAa;AACX,UAAA,GAAG,CAAC,GAAG,CAAC,IAAL,CAAH,GAAgB,MAAI,CAAC,kBAAL,CAAwB,GAAxB,EAA6B,WAAW,CAAC,GAAzC,CAAhB;AACA,iBAAO,GAAP;AACD,SAJI,EAKL,EALK;AARJ,OAAP;AAeD;AAxWH;AAAA;AAAA,WA0WU,4BACJ,GADI,EAEJ,OAFI,EAE6B;AACnC,UAAI,IAAI,GAAG,GAAG,CAAC,IAAf;;AACA,UAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,QAAA,IAAI,GAAG,OAAO,CAAC,IAAD,CAAd;AACD;;AACD,aAAO;AAAC,QAAA,IAAI,EAAJ,IAAD;AAAO,QAAA,KAAK,EAAE,GAAG,CAAC;AAAlB,OAAP;AACD;AAlXH;AAAA;AAAA,SAKE;AACO,mBAAmB;AACxB,aAAO,KAAK,SAAL,KAAmB,KAAK,SAAL,GAAiB,IAAI,IAAJ,EAApC,CAAP;AACD;AARH;;AAAA;AAAA;AAqXA,OAAM,SAAU,YAAV,CAAuB,IAAvB,EAAmC;AACvC,MAAM,MAAM,GAAG,GAAG,GAAG,MAArB;;AACA,MAAI,OAAO,MAAM,CAAC,IAAd,KAAuB,WAA3B,EAAwC;AACtC,WAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAP;AACD,GAFD,MAEO,IAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACxC,WAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,QAAjB,EAA2B,QAA3B,EAAP;AACD,GAFM,MAEA;AACL,UAAM,IAAI,KAAJ,CACF,kDACA,qCAFE,CAAN;AAGD;AACF;AAED,OAAM,SAAU,gBAAV,CAA2B,CAA3B,EAAyC,QAAzC,EAA0D;AAC9D,MAAM,KAAK,GACP,KAAK,CAAC,OAAN,CAAc,CAAd,IAAmB,MAAM,CAAC,YAAP,CAAoB,KAApB,CAA0B,IAA1B,EAAgC,CAAhC,CAAnB,GAAwD,YAAY,CAAC,CAAD,CADxE;AAEA,SAAO,QAAQ,GAAG,KAAH,GAAW,KAAK,CAAC,WAAN,EAA1B;AACD;AAED,OAAM,SAAU,cAAV,CACF,KADE,EAC6C,IAD7C,EAC2D,GAD3D,EAEc;AAAA,MAAhB,QAAgB,uEAAL,KAAK;AAClB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAO,gBAAgB,CAAC,KAAK,CAAC,CAAP,EAAU,QAAV,CAAvB;AACD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,YAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEU;AACd,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;AACA,SAAO,KAAK,GAAG,KAAK,CAAC,CAAT,GAAa,GAAzB;AACD;AAED,OAAM,SAAU,cAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAES;AACb,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAL,IAAe,EAA7B;AACA,MAAM,KAAK,GACP,KAAK,CAAC,GAAD,CAAL,IAAc,IAAd,GAAqB,KAAK,CAAC,GAAD,CAA1B,GAAmC,KAAK,CAAC,GAAD,CAAL,IAAc,IAAd,GAAqB,KAAK,CAAC,GAAD,CAA1B,GAAkC,GADzE;AAEA,SAAQ,OAAO,KAAP,KAAiB,QAAlB,GAA8B,KAA9B,GAAsC,QAAQ,CAAC,KAAD,EAAQ,EAAR,CAArD;AACD;AAED,OAAM,SAAU,eAAV,CAA0B,KAA1B,EAA2D;AAC/D,MAAI,OAAQ,KAAR,KAAmB,QAAvB,EAAiC;AAC/B;AACA,IAAA,KAAK,GAAG,UAAU,CAAC,QAAX,CAAoB,KAApB,CAAR;AACD;;AACD,UAAQ,KAAR;AACE,SAAK,UAAU,CAAC,QAAX,CAAoB,QAAzB;AACE,aAAO,SAAP;;AACF,SAAK,UAAU,CAAC,QAAX,CAAoB,QAAzB;AACA,SAAK,UAAU,CAAC,QAAX,CAAoB,QAAzB;AACA,SAAK,UAAU,CAAC,QAAX,CAAoB,OAAzB;AACA,SAAK,UAAU,CAAC,QAAX,CAAoB,QAAzB;AACE,aAAO,OAAP;;AACF,SAAK,UAAU,CAAC,QAAX,CAAoB,OAAzB;AACE,aAAO,MAAP;;AACF,SAAK,UAAU,CAAC,QAAX,CAAoB,SAAzB;AACE,aAAO,SAAP;;AACF,SAAK,UAAU,CAAC,QAAX,CAAoB,SAAzB;AACE,aAAO,QAAP;;AACF;AACE;AACA;AACA,aAAO,IAAP;AAjBJ;AAmBD;AAED,OAAM,SAAU,YAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAES;AACb,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,IAAnB,EAAyB;AACvB,WAAO,KAAK,CAAC,IAAN,CAAW,IAAlB;AACD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,aAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEW;AACf,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,IAAnB,EAAyB;AACvB,WAAO,eAAe,CAAC,KAAK,CAAC,IAAP,CAAtB;AACD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,kBAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEa;AACjB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,IAAf,IAAuB,KAAK,CAAC,IAAN,CAAW,IAAtC,EAA4C;AAC1C,WAAO,KAAK,CAAC,IAAN,CAAW,IAAX,CAAgB,GAAhB,CAAoB,UAAA,CAAC;AAAA,aAAI,eAAe,CAAC,CAAD,CAAnB;AAAA,KAArB,CAAP;AACD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,qBAAV,CAAgC,KAAhC,EAA8D;AAElE,MAAI,KAAK,CAAC,WAAV,EAAuB;AACrB,WAAO,SAAP;AACD;;AACD,MAAI,KAAK,CAAC,GAAN,IAAa,IAAjB,EAAuB;AACrB,WAAO,KAAK,CAAC,GAAN,CAAU,GAAV,CACH,UAAA,GAAG;AAAA,aACE,OAAO,GAAG,CAAC,IAAX,KAAoB,QAArB,GAAiC,GAAG,CAAC,IAArC,GAA4C,QAAQ,CAAC,GAAG,CAAC,IAAL,EAAW,EAAX,CADrD;AAAA,KADA,CAAP;AAGD;;AACD,SAAO,EAAP;AACD;AAED,OAAM,SAAU,mBAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEY;AAChB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,KAAnB,EAA0B;AACxB,WAAO,qBAAqB,CAAC,KAAK,CAAC,KAAP,CAA5B;AACD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,oBAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEW;AACf,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAJ,EAAW;AACT,WAAO,CAAC,CAAC,KAAK,CAAC,IAAN,CAAW,CAAX,IAAgB,KAAK,CAAC,IAAN,CAAW,CAAX,CAAa,MAA7B,GAAsC,KAAK,CAAC,IAAN,CAAW,CAAjD,GACsC,KAAK,CAAC,IAAN,CAAW,CADlD,KAEA,EAFD,EAGF,GAHE,CAGE,UAAA,CAAC;AAAA,aAAK,OAAO,CAAP,KAAa,QAAd,GAA0B,CAA1B,GAA8B,QAAQ,CAAC,CAAD,EAAI,EAAJ,CAA1C;AAAA,KAHH,CAAP;AAID;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,mBAAV,CACF,KADE,EAC6C,IAD7C,EAC2D,GAD3D,EAEc;AAAA,MAAhB,QAAgB,uEAAL,KAAK;AAClB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,IAAf,IAAuB,KAAK,CAAC,IAAN,CAAW,CAAtC,EAAyC;AACvC,WAAO,KAAK,CAAC,IAAN,CAAW,CAAX,CAAa,GAAb,CAAiB,UAAC,CAAD,EAAM;AAC5B,aAAO,gBAAgB,CAAC,CAAD,EAAI,QAAJ,CAAvB;AACD,KAFM,CAAP;AAGD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,wBAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEa;AACjB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,IAAf,IAAuB,KAAK,CAAC,IAAN,CAAW,KAAtC,EAA6C;AAC3C,WAAO,KAAK,CAAC,IAAN,CAAW,KAAX,CAAiB,GAAjB,CAAqB,UAAC,CAAD,EAAM;AAChC,aAAO,qBAAqB,CAAC,CAAD,CAA5B;AACD,KAFM,CAAP;AAGD;;AACD,SAAO,GAAP;AACD;AAED,OAAM,SAAU,iBAAV,CACF,KADE,EAC6C,IAD7C,EAEF,GAFE,EAEY;AAChB,MAAM,KAAK,GAAG,KAAK,CAAC,IAAD,CAAnB;;AACA,MAAI,KAAK,IAAI,KAAK,CAAC,IAAf,IAAuB,KAAK,CAAC,IAAN,CAAW,CAAtC,EAAyC;AACvC,WAAO,KAAK,CAAC,IAAN,CAAW,CAAlB;AACD;;AACD,SAAO,GAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as spectral from './op_list/spectral';\nimport * as transformation from './op_list/transformation';\nexport class OperationMapper {\n    // Singleton instance for the mapper\n    static get Instance() {\n        return this._instance || (this._instance = new this());\n    }\n    // Loads the op mapping from the JSON file.\n    constructor() {\n        const ops = [\n            arithmetic, basicMath, control, convolution, creation, dynamic,\n            evaluation, logical, image, graph, matrices, normalization, reduction,\n            sliceJoin, spectral, transformation, hashTable\n        ];\n        const mappersJson = [].concat(...ops.map(op => op.json));\n        this.opMappers = mappersJson.reduce((map, mapper) => {\n            map[mapper.tfOpName] = mapper;\n            return map;\n        }, {});\n    }\n    // Converts the model inference graph from Tensorflow GraphDef to local\n    // representation for TensorFlow.js API\n    transformGraph(graph, signature = {}) {\n        const tfNodes = graph.node;\n        const placeholders = [];\n        const weights = [];\n        const initNodes = [];\n        const nodes = tfNodes.reduce((map, node) => {\n            map[node.name] = this.mapNode(node);\n            if (node.op.startsWith('Placeholder')) {\n                placeholders.push(map[node.name]);\n            }\n            else if (node.op === 'Const') {\n                weights.push(map[node.name]);\n            }\n            else if (node.input == null || node.input.length === 0) {\n                initNodes.push(map[node.name]);\n            }\n            return map;\n        }, {});\n        let inputs = [];\n        const outputs = [];\n        let inputNodeNameToKey = {};\n        let outputNodeNameToKey = {};\n        if (signature != null) {\n            inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n            outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n        }\n        const allNodes = Object.keys(nodes);\n        allNodes.forEach(key => {\n            const node = nodes[key];\n            node.inputNames.forEach(name => {\n                const [nodeName,] = getNodeNameAndIndex(name);\n                node.inputs.push(nodes[nodeName]);\n                nodes[nodeName].children.push(node);\n            });\n        });\n        // if signature has not outputs set, add any node that does not have\n        // outputs.\n        if (Object.keys(outputNodeNameToKey).length === 0) {\n            allNodes.forEach(key => {\n                const node = nodes[key];\n                if (node.children.length === 0) {\n                    outputs.push(node);\n                }\n            });\n        }\n        else {\n            Object.keys(outputNodeNameToKey).forEach(name => {\n                const [nodeName,] = getNodeNameAndIndex(name);\n                const node = nodes[nodeName];\n                if (node != null) {\n                    node.signatureKey = outputNodeNameToKey[name];\n                    outputs.push(node);\n                }\n            });\n        }\n        if (Object.keys(inputNodeNameToKey).length > 0) {\n            Object.keys(inputNodeNameToKey).forEach(name => {\n                const [nodeName,] = getNodeNameAndIndex(name);\n                const node = nodes[nodeName];\n                if (node) {\n                    node.signatureKey = inputNodeNameToKey[name];\n                    inputs.push(node);\n                }\n            });\n        }\n        else {\n            inputs = placeholders;\n        }\n        let functions = {};\n        if (graph.library != null && graph.library.function != null) {\n            functions = graph.library.function.reduce((functions, func) => {\n                functions[func.signature.name] = this.mapFunction(func);\n                return functions;\n            }, {});\n        }\n        const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };\n        if (initNodes.length > 0) {\n            result.initNodes = initNodes;\n        }\n        return result;\n    }\n    mapSignatureEntries(entries) {\n        return Object.keys(entries || {})\n            .reduce((prev, curr) => {\n            prev[entries[curr].name] = curr;\n            return prev;\n        }, {});\n    }\n    mapNode(node) {\n        // Unsupported ops will cause an error at run-time (not parse time), since\n        // they may not be used by the actual execution subgraph.\n        const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n        if (node.attr == null) {\n            node.attr = {};\n        }\n        const newNode = {\n            name: node.name,\n            op: node.op,\n            category: mapper.category,\n            inputNames: (node.input ||\n                []).map(input => input.startsWith('^') ? input.substr(1) : input),\n            inputs: [],\n            children: [],\n            inputParams: {},\n            attrParams: {},\n            rawAttrs: node.attr\n        };\n        if (mapper.inputs != null) {\n            newNode.inputParams =\n                mapper.inputs.reduce((map, param) => {\n                    map[param.name] = {\n                        type: param.type,\n                        inputIndexStart: param.start,\n                        inputIndexEnd: param.end\n                    };\n                    return map;\n                }, {});\n        }\n        if (mapper.attrs != null) {\n            newNode.attrParams =\n                mapper.attrs.reduce((map, param) => {\n                    const type = param.type;\n                    let value = undefined;\n                    switch (param.type) {\n                        case 'string':\n                            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'string[]':\n                            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number':\n                            value = getNumberParam(node.attr, param.tfName, (param.defaultValue || 0));\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number[]':\n                            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool':\n                            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool[]':\n                            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape':\n                            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape[]':\n                            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype':\n                            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype[]':\n                            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'func':\n                            value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'tensor':\n                        case 'tensors':\n                            break;\n                        default:\n                            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);\n                    }\n                    map[param.name] = { value, type };\n                    return map;\n                }, {});\n        }\n        return newNode;\n    }\n    // map the TFunctionDef to TFJS graph object\n    mapFunction(functionDef) {\n        const tfNodes = functionDef.nodeDef;\n        const placeholders = [];\n        const weights = [];\n        let nodes = {};\n        if (tfNodes != null) {\n            nodes = tfNodes.reduce((map, node) => {\n                map[node.name] = this.mapNode(node);\n                if (node.op === 'Const') {\n                    weights.push(map[node.name]);\n                }\n                return map;\n            }, {});\n        }\n        const inputs = [];\n        const outputs = [];\n        functionDef.signature.inputArg.forEach(arg => {\n            const [nodeName,] = getNodeNameAndIndex(arg.name);\n            const node = {\n                name: nodeName,\n                op: 'Placeholder',\n                inputs: [],\n                inputNames: [],\n                category: 'graph',\n                inputParams: {},\n                attrParams: { dtype: { value: parseDtypeParam(arg.type), type: 'dtype' } },\n                children: []\n            };\n            node.signatureKey = arg.name;\n            inputs.push(node);\n            nodes[nodeName] = node;\n        });\n        const allNodes = Object.keys(nodes);\n        allNodes.forEach(key => {\n            const node = nodes[key];\n            node.inputNames.forEach(name => {\n                const [nodeName,] = getNodeNameAndIndex(name);\n                node.inputs.push(nodes[nodeName]);\n                nodes[nodeName].children.push(node);\n            });\n        });\n        const returnNodeMap = functionDef.ret;\n        functionDef.signature.outputArg.forEach(output => {\n            const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n            const node = nodes[nodeName];\n            if (node != null) {\n                node.defaultOutput = index;\n                outputs.push(node);\n            }\n        });\n        const signature = this.mapArgsToSignature(functionDef);\n        return { nodes, inputs, outputs, weights, placeholders, signature };\n    }\n    mapArgsToSignature(functionDef) {\n        return {\n            methodName: functionDef.signature.name,\n            inputs: functionDef.signature.inputArg.reduce((map, arg) => {\n                map[arg.name] = this.mapArgToTensorInfo(arg);\n                return map;\n            }, {}),\n            outputs: functionDef.signature.outputArg.reduce((map, arg) => {\n                map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n                return map;\n            }, {}),\n        };\n    }\n    mapArgToTensorInfo(arg, nameMap) {\n        let name = arg.name;\n        if (nameMap != null) {\n            name = nameMap[name];\n        }\n        return { name, dtype: arg.type };\n    }\n}\nexport function decodeBase64(text) {\n    const global = env().global;\n    if (typeof global.atob !== 'undefined') {\n        return global.atob(text);\n    }\n    else if (typeof Buffer !== 'undefined') {\n        return new Buffer(text, 'base64').toString();\n    }\n    else {\n        throw new Error('Unable to decode base64 in this environment. ' +\n            'Missing built-in atob() or Buffer()');\n    }\n}\nexport function parseStringParam(s, keepCase) {\n    const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n    return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def, keepCase = false) {\n    const param = attrs[name];\n    if (param != null) {\n        return parseStringParam(param.s, keepCase);\n    }\n    return def;\n}\nexport function getBoolParam(attrs, name, def) {\n    const param = attrs[name];\n    return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n    const param = attrs[name] || {};\n    const value = param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n    return (typeof value === 'number') ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n    if (typeof (value) === 'string') {\n        // tslint:disable-next-line:no-any\n        value = tensorflow.DataType[value];\n    }\n    switch (value) {\n        case tensorflow.DataType.DT_FLOAT:\n            return 'float32';\n        case tensorflow.DataType.DT_INT32:\n        case tensorflow.DataType.DT_INT64:\n        case tensorflow.DataType.DT_INT8:\n        case tensorflow.DataType.DT_UINT8:\n            return 'int32';\n        case tensorflow.DataType.DT_BOOL:\n            return 'bool';\n        case tensorflow.DataType.DT_DOUBLE:\n            return 'float32';\n        case tensorflow.DataType.DT_STRING:\n            return 'string';\n        default:\n            // Unknown dtype error will happen at runtime (instead of parse time),\n            // since these nodes might not be used by the actual subgraph execution.\n            return null;\n    }\n}\nexport function getFuncParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.func) {\n        return param.func.name;\n    }\n    return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.type) {\n        return parseDtypeParam(param.type);\n    }\n    return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.list && param.list.type) {\n        return param.list.type.map(v => parseDtypeParam(v));\n    }\n    return def;\n}\nexport function parseTensorShapeParam(shape) {\n    if (shape.unknownRank) {\n        return undefined;\n    }\n    if (shape.dim != null) {\n        return shape.dim.map(dim => (typeof dim.size === 'number') ? dim.size : parseInt(dim.size, 10));\n    }\n    return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.shape) {\n        return parseTensorShapeParam(param.shape);\n    }\n    return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param) {\n        return ((param.list.f && param.list.f.length ? param.list.f :\n            param.list.i) ||\n            [])\n            .map(v => (typeof v === 'number') ? v : parseInt(v, 10));\n    }\n    return def;\n}\nexport function getStringArrayParam(attrs, name, def, keepCase = false) {\n    const param = attrs[name];\n    if (param && param.list && param.list.s) {\n        return param.list.s.map((v) => {\n            return parseStringParam(v, keepCase);\n        });\n    }\n    return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.list && param.list.shape) {\n        return param.list.shape.map((v) => {\n            return parseTensorShapeParam(v);\n        });\n    }\n    return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.list && param.list.b) {\n        return param.list.b;\n    }\n    return def;\n}\n//# sourceMappingURL=operation_mapper.js.map"]},"metadata":{},"sourceType":"module"}