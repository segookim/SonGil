{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { MirrorPad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function mirrorPad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x;\n  var paddings = attrs.paddings,\n      mode = attrs.mode;\n  assertNotComplex(x, 'mirrorPad');\n  var outShape = paddings.map(function (p, i) {\n    return p[0]\n    /* beforePad */\n    + x.shape[i] + p[1];\n  }\n  /* afterPad */\n  );\n  var start = paddings.map(function (p) {\n    return p[0];\n  });\n  var end = paddings.map(function (p, i) {\n    return p[0] + x.shape[i];\n  });\n  var offset = mode === 'reflect' ? 0 : 1;\n  var xVals = backend.data.get(x.dataId).values;\n  var xRank = x.shape.length;\n  var xStrides = util.computeStrides(x.shape);\n  var resultSize = util.sizeFromShape(outShape);\n  var resultRank = outShape.length;\n  var resultStrides = util.computeStrides(outShape);\n  var resVals = util.getTypedArrayFromDType(x.dtype, resultSize);\n\n  for (var i = 0; i < resultSize; i++) {\n    var coords = util.indexToLoc(i, resultRank, resultStrides);\n\n    for (var _i = 0; _i < resultRank; _i++) {\n      if (coords[_i] < start[_i]) {\n        coords[_i] = start[_i] * 2 - coords[_i] - offset;\n      } else if (coords[_i] >= end[_i]) {\n        coords[_i] = (end[_i] - 1) * 2 - coords[_i] + offset;\n      }\n    }\n\n    coords = coords.map(function (c, i) {\n      return c - start[i];\n    });\n    var inIndex = util.locToIndex(coords, xRank, xStrides);\n    resVals[i] = xVals[inIndex];\n  }\n\n  var outId = backend.write(resVals, outShape, x.dtype);\n  return {\n    dataId: outId,\n    shape: outShape,\n    dtype: x.dtype\n  };\n}\nexport var mirrorPadConfig = {\n  kernelName: MirrorPad,\n  backendName: 'cpu',\n  kernelFunc: mirrorPad\n};","map":{"version":3,"sources":["../../src/kernels/MirrorPad.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkC,SAAlC,EAAuH,IAAvH,QAAkI,uBAAlI;AAGA,SAAQ,gBAAR,QAA+B,aAA/B;AAEA,OAAM,SAAU,SAAV,CAAoB,IAApB,EAIL;AAAA,MACQ,MADR,GACkC,IADlC,CACQ,MADR;AAAA,MACgB,OADhB,GACkC,IADlC,CACgB,OADhB;AAAA,MACyB,KADzB,GACkC,IADlC,CACyB,KADzB;AAAA,MAEQ,CAFR,GAEa,MAFb,CAEQ,CAFR;AAAA,MAGQ,QAHR,GAG0B,KAH1B,CAGQ,QAHR;AAAA,MAGkB,IAHlB,GAG0B,KAH1B,CAGkB,IAHlB;AAKC,EAAA,gBAAgB,CAAC,CAAD,EAAI,WAAJ,CAAhB;AAEA,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAT,CACb,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,CAAC,CAAD;AAAI;AAAL,MAAuB,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAvB,GAAoC,CAAC,CAAC,CAAD,CAA/C;AAAA;AAAmD;AADtC,GAAjB;AAGA,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAT,CAAa,UAAA,CAAC;AAAA,WAAI,CAAC,CAAC,CAAD,CAAL;AAAA,GAAd,CAAd;AACA,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAT,CAAa,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAjB;AAAA,GAAb,CAAZ;AACA,MAAM,MAAM,GAAG,IAAI,KAAK,SAAT,GAAqB,CAArB,GAAyB,CAAxC;AAEA,MAAM,KAAK,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,CAAC,CAAC,MAAnB,EAA2B,MAAzC;AACA,MAAM,KAAK,GAAG,CAAC,CAAC,KAAF,CAAQ,MAAtB;AACA,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAL,CAAoB,CAAC,CAAC,KAAtB,CAAjB;AAEA,MAAM,UAAU,GAAG,IAAI,CAAC,aAAL,CAAmB,QAAnB,CAAnB;AACA,MAAM,UAAU,GAAG,QAAQ,CAAC,MAA5B;AACA,MAAM,aAAa,GAAG,IAAI,CAAC,cAAL,CAAoB,QAApB,CAAtB;AACA,MAAM,OAAO,GACT,IAAI,CAAC,sBAAL,CAA4B,CAAC,CAAC,KAA9B,EAAwD,UAAxD,CADJ;;AAGA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,QAAI,MAAM,GAAG,IAAI,CAAC,UAAL,CAAgB,CAAhB,EAAmB,UAAnB,EAA+B,aAA/B,CAAb;;AACA,SAAK,IAAI,EAAC,GAAG,CAAb,EAAgB,EAAC,GAAG,UAApB,EAAgC,EAAC,EAAjC,EAAqC;AACnC,UAAI,MAAM,CAAC,EAAD,CAAN,GAAY,KAAK,CAAC,EAAD,CAArB,EAA0B;AACxB,QAAA,MAAM,CAAC,EAAD,CAAN,GAAY,KAAK,CAAC,EAAD,CAAL,GAAW,CAAX,GAAe,MAAM,CAAC,EAAD,CAArB,GAA2B,MAAvC;AACD,OAFD,MAEO,IAAI,MAAM,CAAC,EAAD,CAAN,IAAa,GAAG,CAAC,EAAD,CAApB,EAAyB;AAC9B,QAAA,MAAM,CAAC,EAAD,CAAN,GAAY,CAAC,GAAG,CAAC,EAAD,CAAH,GAAS,CAAV,IAAe,CAAf,GAAmB,MAAM,CAAC,EAAD,CAAzB,GAA+B,MAA3C;AACD;AACF;;AACD,IAAA,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,UAAC,CAAD,EAAI,CAAJ;AAAA,aAAU,CAAC,GAAG,KAAK,CAAC,CAAD,CAAnB;AAAA,KAAX,CAAT;AAEA,QAAM,OAAO,GAAG,IAAI,CAAC,UAAL,CAAgB,MAAhB,EAAwB,KAAxB,EAA+B,QAA/B,CAAhB;AAEA,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,KAAK,CAAC,OAAD,CAAlB;AACD;;AAED,MAAM,KAAK,GAAG,OAAO,CAAC,KAAR,CAAc,OAAd,EAAuB,QAAvB,EAAiC,CAAC,CAAC,KAAnC,CAAd;AAEA,SAAO;AAAC,IAAA,MAAM,EAAE,KAAT;AAAgB,IAAA,KAAK,EAAE,QAAvB;AAAiC,IAAA,KAAK,EAAE,CAAC,CAAC;AAA1C,GAAP;AACD;AAED,OAAO,IAAM,eAAe,GAAiB;AAC3C,EAAA,UAAU,EAAE,SAD+B;AAE3C,EAAA,WAAW,EAAE,KAF8B;AAG3C,EAAA,UAAU,EAAE;AAH+B,CAAtC","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { MirrorPad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function mirrorPad(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { paddings, mode } = attrs;\n    assertNotComplex(x, 'mirrorPad');\n    const outShape = paddings.map((p, i) => p[0] /* beforePad */ + x.shape[i] + p[1] /* afterPad */);\n    const start = paddings.map(p => p[0]);\n    const end = paddings.map((p, i) => p[0] + x.shape[i]);\n    const offset = mode === 'reflect' ? 0 : 1;\n    const xVals = backend.data.get(x.dataId).values;\n    const xRank = x.shape.length;\n    const xStrides = util.computeStrides(x.shape);\n    const resultSize = util.sizeFromShape(outShape);\n    const resultRank = outShape.length;\n    const resultStrides = util.computeStrides(outShape);\n    const resVals = util.getTypedArrayFromDType(x.dtype, resultSize);\n    for (let i = 0; i < resultSize; i++) {\n        let coords = util.indexToLoc(i, resultRank, resultStrides);\n        for (let i = 0; i < resultRank; i++) {\n            if (coords[i] < start[i]) {\n                coords[i] = start[i] * 2 - coords[i] - offset;\n            }\n            else if (coords[i] >= end[i]) {\n                coords[i] = (end[i] - 1) * 2 - coords[i] + offset;\n            }\n        }\n        coords = coords.map((c, i) => c - start[i]);\n        const inIndex = util.locToIndex(coords, xRank, xStrides);\n        resVals[i] = xVals[inIndex];\n    }\n    const outId = backend.write(resVals, outShape, x.dtype);\n    return { dataId: outId, shape: outShape, dtype: x.dtype };\n}\nexport const mirrorPadConfig = {\n    kernelName: MirrorPad,\n    backendName: 'cpu',\n    kernelFunc: mirrorPad\n};\n//# sourceMappingURL=MirrorPad.js.map"]},"metadata":{},"sourceType":"module"}