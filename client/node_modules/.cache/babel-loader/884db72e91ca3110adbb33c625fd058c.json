{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from './util';\n/**\n * Serializable defines the serialization contract.\n *\n * TFJS requires serializable classes to return their className when asked\n * to avoid issues with minification.\n */\n\nexport class Serializable {\n  /**\n   * Return the class name for this class to use in serialization contexts.\n   *\n   * Generally speaking this will be the same thing that constructor.name\n   * would have returned.  However, the class name needs to be robust\n   * against minification for serialization/deserialization to work properly.\n   *\n   * There's also places such as initializers.VarianceScaling, where\n   * implementation details between different languages led to different\n   * class hierarchies and a non-leaf node is used for serialization purposes.\n   */\n  getClassName() {\n    return this.constructor.className;\n  }\n  /**\n   * Creates an instance of T from a ConfigDict.\n   *\n   * This works for most descendants of serializable.  A few need to\n   * provide special handling.\n   * @param cls A Constructor for the class to instantiate.\n   * @param config The Configuration for the object.\n   */\n\n  /** @nocollapse */\n\n\n  static fromConfig(cls, config) {\n    return new cls(config);\n  }\n\n}\n/**\n * Maps string keys to class constructors.\n *\n * Used during (de)serialization from the cross-language JSON format, which\n * requires the class name in the serialization format matches the class\n * names as used in Python, should it exist.\n */\n\nexport class SerializationMap {\n  constructor() {\n    this.classNameMap = {};\n  }\n  /**\n   * Returns the singleton instance of the map.\n   */\n\n\n  static getMap() {\n    if (SerializationMap.instance == null) {\n      SerializationMap.instance = new SerializationMap();\n    }\n\n    return SerializationMap.instance;\n  }\n  /**\n   * Registers the class as serializable.\n   */\n\n\n  static register(cls) {\n    SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];\n  }\n\n}\n/**\n * Register a class with the serialization map of TensorFlow.js.\n *\n * This is often used for registering custom Layers, so they can be\n * serialized and deserialized.\n *\n * Example:\n *\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer);\n * ```\n *\n * @param cls The class to be registered. It must have a public static member\n *   called `className` defined and the value must be a non-empty string.\n *\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\n */\n\nexport function registerClass(cls) {\n  assert(cls.className != null, () => `Class being registered does not have the static className ` + `property defined.`);\n  assert(typeof cls.className === 'string', () => `className is required to be a string, but got type ` + typeof cls.className);\n  assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, ` + `which is disallowed.`);\n  SerializationMap.register(cls);\n}","map":{"version":3,"sources":["../src/serialization.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAqB,QAArB;AAuCA;;;;;AAKG;;AACH,OAAM,MAAgB,YAAhB,CAA4B;AAChC;;;;;;;;;;AAUG;AACH,EAAA,YAAY,GAAA;AACV,WAAQ,KAAK,WAAL,CACH,SADL;AAED;AAOD;;;;;;;AAOG;;AACH;;;AACiB,SAAV,UAAU,CACb,GADa,EACoB,MADpB,EACsC;AACrD,WAAO,IAAI,GAAJ,CAAQ,MAAR,CAAP;AACD;;AAlC+B;AAqClC;;;;;;AAMG;;AACH,OAAM,MAAO,gBAAP,CAAuB;AAO3B,EAAA,WAAA,GAAA;AACE,SAAK,YAAL,GAAoB,EAApB;AACD;AAED;;AAEG;;;AACU,SAAN,MAAM,GAAA;AACX,QAAI,gBAAgB,CAAC,QAAjB,IAA6B,IAAjC,EAAuC;AACrC,MAAA,gBAAgB,CAAC,QAAjB,GAA4B,IAAI,gBAAJ,EAA5B;AACD;;AACD,WAAO,gBAAgB,CAAC,QAAxB;AACD;AAED;;AAEG;;;AACY,SAAR,QAAQ,CAAyB,GAAzB,EAAwD;AACrE,IAAA,gBAAgB,CAAC,MAAjB,GAA0B,YAA1B,CAAuC,GAAG,CAAC,SAA3C,IACI,CAAC,GAAD,EAAM,GAAG,CAAC,UAAV,CADJ;AAED;;AA3B0B;AA8B7B;;;;;;;;;;;;;;;;;;;;;;;AAuBG;;AACH,OAAM,SAAU,aAAV,CACF,GADE,EAC6B;AACjC,EAAA,MAAM,CACF,GAAG,CAAC,SAAJ,IAAiB,IADf,EAEF,MAAM,4DAAA,GACF,mBAHF,CAAN;AAIA,EAAA,MAAM,CACF,OAAO,GAAG,CAAC,SAAX,KAAyB,QADvB,EAEF,MAAM,qDAAA,GACF,OAAO,GAAG,CAAC,SAHb,CAAN;AAIA,EAAA,MAAM,CACF,GAAG,CAAC,SAAJ,CAAc,MAAd,GAAuB,CADrB,EAEF,MAAM,+DAAA,GACF,sBAHF,CAAN;AAKA,EAAA,gBAAgB,CAAC,QAAjB,CAA0B,GAA1B;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from './util';\n/**\n * Serializable defines the serialization contract.\n *\n * TFJS requires serializable classes to return their className when asked\n * to avoid issues with minification.\n */\nexport class Serializable {\n    /**\n     * Return the class name for this class to use in serialization contexts.\n     *\n     * Generally speaking this will be the same thing that constructor.name\n     * would have returned.  However, the class name needs to be robust\n     * against minification for serialization/deserialization to work properly.\n     *\n     * There's also places such as initializers.VarianceScaling, where\n     * implementation details between different languages led to different\n     * class hierarchies and a non-leaf node is used for serialization purposes.\n     */\n    getClassName() {\n        return this.constructor\n            .className;\n    }\n    /**\n     * Creates an instance of T from a ConfigDict.\n     *\n     * This works for most descendants of serializable.  A few need to\n     * provide special handling.\n     * @param cls A Constructor for the class to instantiate.\n     * @param config The Configuration for the object.\n     */\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls(config);\n    }\n}\n/**\n * Maps string keys to class constructors.\n *\n * Used during (de)serialization from the cross-language JSON format, which\n * requires the class name in the serialization format matches the class\n * names as used in Python, should it exist.\n */\nexport class SerializationMap {\n    constructor() {\n        this.classNameMap = {};\n    }\n    /**\n     * Returns the singleton instance of the map.\n     */\n    static getMap() {\n        if (SerializationMap.instance == null) {\n            SerializationMap.instance = new SerializationMap();\n        }\n        return SerializationMap.instance;\n    }\n    /**\n     * Registers the class as serializable.\n     */\n    static register(cls) {\n        SerializationMap.getMap().classNameMap[cls.className] =\n            [cls, cls.fromConfig];\n    }\n}\n/**\n * Register a class with the serialization map of TensorFlow.js.\n *\n * This is often used for registering custom Layers, so they can be\n * serialized and deserialized.\n *\n * Example:\n *\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer);\n * ```\n *\n * @param cls The class to be registered. It must have a public static member\n *   called `className` defined and the value must be a non-empty string.\n *\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\n */\nexport function registerClass(cls) {\n    assert(cls.className != null, () => `Class being registered does not have the static className ` +\n        `property defined.`);\n    assert(typeof cls.className === 'string', () => `className is required to be a string, but got type ` +\n        typeof cls.className);\n    assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, ` +\n        `which is disallowed.`);\n    SerializationMap.register(cls);\n}\n//# sourceMappingURL=serialization.js.map"]},"metadata":{},"sourceType":"module"}