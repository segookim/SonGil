{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n  const inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` + `match the rank of the array (${inputRank}).`);\n  util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` + `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\n\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\n\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\n\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  const newStrides = [...strides];\n\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0\n      /* num elements to delete */\n      , 1\n      /* element to add */\n      );\n      newStrides.pop();\n    }\n  }\n\n  return newStrides;\n}\n\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  const elidedAxes = [];\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n\n  return elidedAxes;\n} // Normalize the start, end and strides.\n\n\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0]; // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\n\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  return newIndices;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\n\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  let stride = strides[axis];\n\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  } // Clamping\n\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  } // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n\n\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\n\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  let begin_;\n  const xRank = x.shape.length;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  // make a copy because it may be modified further down.\n  let $begin = begin.slice();\n  let $end = end.slice();\n  let $strides = strides;\n\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n\n  const numInterpolatedAxes = xShape.length - $begin.length; // Expand the dims of x based on the newAxisMask.\n\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = xShape.slice();\n  expandAxes.forEach(axis => {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n  const {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n  const shrinkAxes = maskToAxes(shrinkAxisMask); // Adjust the ends based on the shrink mask.\n\n  shrinkAxes.forEach(axis => {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  }); // Figure out the output shape.\n\n  const size = computeOutShape($begin, $end, $strides); // Remove the axes based on shrinkMask.\n\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n  const nonStrided = $strides.every(v => v === 1);\n  return {\n    nonStrided,\n    $begin,\n    $end,\n    $strides,\n    size,\n    newShape,\n    outShape\n  };\n}","map":{"version":3,"sources":["../../src/ops/slice_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n    const inputRank = input.shape.length;\n    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${inputRank}).`);\n    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n        `match the rank of the array (${inputRank}).`);\n    for (let i = 0; i < inputRank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n    const inputRank = inputShape.length;\n    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions\n        // that are interpolated.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n        normalizedStrides =\n            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n    }\n    else {\n        for (let axis = 0; axis < inputRank; axis++) {\n            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n            normalizedEnd[axis] =\n                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n        }\n    }\n    return {\n        begin: normalizedBegin,\n        end: normalizedEnd,\n        strides: normalizedStrides\n    };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    const xRank = x.shape.length;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n    }\n    else if (begin.length < xRank) {\n        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(xRank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(xRank - 1).fill(-1)];\n    }\n    else if (size.length < xRank) {\n        size_ = size.concat(new Array(xRank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    // make a copy because it may be modified further down.\n    let $begin = begin.slice();\n    let $end = end.slice();\n    let $strides = strides;\n    if (strides == null) {\n        $strides = new Array($begin.length);\n    }\n    const ellipsisAxes = maskToAxes(ellipsisMask);\n    if (ellipsisAxes.length > 1) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n    const numInterpolatedAxes = xShape.length - $begin.length;\n    // Expand the dims of x based on the newAxisMask.\n    const expandAxes = maskToAxes(newAxisMask);\n    const newShape = xShape.slice();\n    expandAxes.forEach(axis => {\n        $begin[axis] = 0;\n        $end[axis] = 1;\n        newShape.splice(axis, 0, 1);\n    });\n    const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n    $begin = normalizedBegin;\n    $end = normalizedEnd;\n    $strides = normalizedStrides;\n    const shrinkAxes = maskToAxes(shrinkAxisMask);\n    // Adjust the ends based on the shrink mask.\n    shrinkAxes.forEach(axis => {\n        $end[axis] = $begin[axis] + 1;\n        $strides[axis] = 1;\n    });\n    // Figure out the output shape.\n    const size = computeOutShape($begin, $end, $strides);\n    // Remove the axes based on shrinkMask.\n    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n    const nonStrided = $strides.every(v => v === 1);\n    return { nonStrided, $begin, $end, $strides, size, newShape, outShape };\n}\n//# sourceMappingURL=slice_util.js.map"]},"metadata":{},"sourceType":"module"}