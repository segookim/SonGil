{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n  const inputParam = node.inputParams[paramName];\n\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n    }\n\n    if (inputParam.type === 'tensors') {\n      const inputs = node.inputNames.slice(start, end);\n      return inputs.map(name => getTensor(name, tensorMap, context, resourceManager));\n    }\n\n    const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : util.toNestedArray(tensor.shape, data);\n  }\n\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\n\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n  const [nodeName, index] = parseNodeName(name);\n\n  if (resourceManager != null) {\n    const tensor = resourceManager.getHashTableHandleByName(nodeName);\n\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\n\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n */\n\nexport function getNodeNameAndIndex(inputName, context) {\n  const [nodeName, index] = parseNodeName(inputName);\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index];\n}\n\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? `${name}-${contextId}` : name;\n}\n\nexport function parseNodeName(name) {\n  const parts = name.split(':');\n\n  if (parts.length === 1) {\n    return [name, 0];\n  }\n\n  const nodeName = parts[0];\n  return [nodeName, Number(parts[parts.length - 1])];\n}\nexport function split(arr, size) {\n  const res = [];\n\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  let pad = getParamValue('pad', node, tensorMap, context);\n\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n\n    return explicitPadding;\n  }\n\n  return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\n\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : clone(tensor);\n}","map":{"version":3,"sources":["../../../src/operations/executors/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n    const inputParam = node.inputParams[paramName];\n    if (inputParam && inputParam.inputIndexStart !== undefined) {\n        const start = inputParam.inputIndexStart;\n        const end = inputParam.inputIndexEnd === 0 ?\n            undefined :\n            (inputParam.inputIndexEnd === undefined ? start + 1 :\n                inputParam.inputIndexEnd);\n        if (inputParam.type === 'tensor') {\n            return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n        }\n        if (inputParam.type === 'tensors') {\n            const inputs = node.inputNames.slice(start, end);\n            return inputs.map(name => getTensor(name, tensorMap, context, resourceManager));\n        }\n        const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n        const data = tensor.dataSync();\n        return inputParam.type === 'number' ?\n            data[0] :\n            util.toNestedArray(tensor.shape, data);\n    }\n    const attrParam = node.attrParams[paramName];\n    return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n    const [nodeName, index] = parseNodeName(name);\n    if (resourceManager != null) {\n        const tensor = resourceManager.getHashTableHandleByName(nodeName);\n        if (tensor != null) {\n            return tensor;\n        }\n    }\n    const contextId = context.currentContextIds.find(contextId => {\n        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n    });\n    return contextId !== undefined ?\n        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :\n        undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n    return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n */\nexport function getNodeNameAndIndex(inputName, context) {\n    const [nodeName, index] = parseNodeName(inputName);\n    return [\n        getNodeNameWithContextId(nodeName, context && context.currentContextId),\n        index\n    ];\n}\nfunction getNodeNameWithContextId(name, contextId) {\n    return !!contextId ? `${name}-${contextId}` : name;\n}\nexport function parseNodeName(name) {\n    const parts = name.split(':');\n    if (parts.length === 1) {\n        return [name, 0];\n    }\n    const nodeName = parts[0];\n    return [nodeName, Number(parts[parts.length - 1])];\n}\nexport function split(arr, size) {\n    const res = [];\n    for (let i = 0; i < arr.length; i += size) {\n        res.push(arr.slice(i, i + size));\n    }\n    return res;\n}\nexport function getPadding(node, tensorMap, context) {\n    let pad = getParamValue('pad', node, tensorMap, context);\n    if (pad === 'explicit') {\n        // This is 1d array, we need to convert it to 2d array\n        pad = getParamValue('explicitPaddings', node, tensorMap, context);\n        const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n        for (let i = 0; i < 4; i++) {\n            explicitPadding[i][0] = pad[i * 2];\n            explicitPadding[i][1] = pad[i * 2 + 1];\n        }\n        return explicitPadding;\n    }\n    return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\nexport function cloneTensor(tensor) {\n    return tensor.kept ? tensor : clone(tensor);\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}