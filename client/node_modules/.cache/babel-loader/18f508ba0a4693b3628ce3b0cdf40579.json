{"ast":null,"code":"/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error('tf.sparseToDense() expects the indices to be int32 type,' + ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n\n  if (sparseIndices.rank > 2) {\n    throw new Error('sparseIndices should be a scalar, vector, or matrix,' + ` but got shape ${sparseIndices.shape}.`);\n  }\n\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error('outputShape has incorrect number of elements:,' + ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n\n  const numValues = sparseValues.size;\n\n  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error('sparseValues has incorrect shape ' + `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}","map":{"version":3,"sources":["../../src/ops/sparse_to_dense_util.ts"],"names":[],"mappings":"AAkBA;;;;;;;;;;;;AAYG;AACH,OAAM,SAAU,aAAV,CACF,aADE,EACqB,YADrB,EAC2C,WAD3C,EAEF,aAFE,EAEmB;AACvB,MAAI,aAAa,CAAC,KAAd,KAAwB,OAA5B,EAAqC;AACnC,UAAM,IAAI,KAAJ,CACF,6DACA,sBAAsB,aAAa,CAAC,KAAK,GAFvC,CAAN;AAGD;;AACD,MAAI,aAAa,CAAC,IAAd,GAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAI,KAAJ,CACF,yDACA,kBAAkB,aAAa,CAAC,KAAK,GAFnC,CAAN;AAGD;;AAED,QAAM,QAAQ,GAAG,aAAa,CAAC,IAAd,GAAqB,CAArB,GAAyB,aAAa,CAAC,KAAd,CAAoB,CAApB,CAAzB,GAAkD,CAAnE;AACA,QAAM,OAAO,GAAG,aAAa,CAAC,IAAd,GAAqB,CAArB,GAAyB,aAAa,CAAC,KAAd,CAAoB,CAApB,CAAzB,GAAkD,CAAlE;;AAEA,MAAI,WAAW,CAAC,MAAZ,KAAuB,OAA3B,EAAoC;AAClC,UAAM,IAAI,KAAJ,CACF,mDACA,IAAI,WAAW,CAAC,MAAM,gBAAgB,OAAO,GAF3C,CAAN;AAGD;;AAED,QAAM,SAAS,GAAG,YAAY,CAAC,IAA/B;;AACA,MAAI,EAAE,YAAY,CAAC,IAAb,KAAsB,CAAtB,IACA,YAAY,CAAC,IAAb,KAAsB,CAAtB,IAA2B,SAAS,KAAK,QAD3C,CAAJ,EAC0D;AACxD,UAAM,IAAI,KAAJ,CACF,sCACA,GAAG,YAAY,CAAC,KAAK,sBAAsB,QAAQ,GAFjD,CAAN;AAGD;;AAED,MAAI,YAAY,CAAC,KAAb,KAAuB,aAAa,CAAC,KAAzC,EAAgD;AAC9C,UAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;AACD;AACF","sourceRoot":"","sourcesContent":["/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n    if (sparseIndices.dtype !== 'int32') {\n        throw new Error('tf.sparseToDense() expects the indices to be int32 type,' +\n            ` but the dtype was ${sparseIndices.dtype}.`);\n    }\n    if (sparseIndices.rank > 2) {\n        throw new Error('sparseIndices should be a scalar, vector, or matrix,' +\n            ` but got shape ${sparseIndices.shape}.`);\n    }\n    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n    if (outputShape.length !== numDims) {\n        throw new Error('outputShape has incorrect number of elements:,' +\n            ` ${outputShape.length}, should be: ${numDims}.`);\n    }\n    const numValues = sparseValues.size;\n    if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n        throw new Error('sparseValues has incorrect shape ' +\n            `${sparseValues.shape}, should be [] or [${numElems}]`);\n    }\n    if (sparseValues.dtype !== defaultValues.dtype) {\n        throw new Error('sparseValues.dtype must match defaultValues.dtype');\n    }\n}\n//# sourceMappingURL=sparse_to_dense_util.js.map"]},"metadata":{},"sourceType":"module"}