{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    y,\n    dy\n  } = inputs;\n  const {\n    depthRadius,\n    bias,\n    alpha,\n    beta\n  } = attrs;\n  assertNotComplex(dy, 'LRNGrad');\n  const dySize = util.sizeFromShape(dy.shape);\n  const channels = dy.shape[3];\n  const dyValues = backend.data.get(dy.dataId).values;\n  const xValues = backend.data.get(x.dataId).values;\n  const yValues = backend.data.get(y.dataId).values;\n  const result = new Float32Array(dySize);\n  const size = dySize;\n\n  for (let offset = 0; offset < size; offset++) {\n    const currentChannel = offset % channels;\n    const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    let norm = 0;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n\n    norm = alpha * norm + bias;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n\n      if (offset === k) {\n        dyi += Math.pow(norm, -beta);\n      }\n\n      dyi *= dyValues[offset];\n      result[k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport const lRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":{"version":3,"sources":["../../src/kernels/LRNGrad.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkC,OAAlC,EAAgG,IAAhG,QAA2G,uBAA3G;AAGA,SAAQ,gBAAR,QAA+B,aAA/B;AAEA,OAAM,SAAU,OAAV,CACF,IADE,EAEuE;AAE3E,QAAM;AAAC,IAAA,MAAD;AAAS,IAAA,OAAT;AAAkB,IAAA;AAAlB,MAA2B,IAAjC;AACA,QAAM;AAAC,IAAA,CAAD;AAAI,IAAA,CAAJ;AAAO,IAAA;AAAP,MAAa,MAAnB;AACA,QAAM;AAAC,IAAA,WAAD;AAAc,IAAA,IAAd;AAAoB,IAAA,KAApB;AAA2B,IAAA;AAA3B,MAAmC,KAAzC;AAEA,EAAA,gBAAgB,CAAC,EAAD,EAAK,SAAL,CAAhB;AAEA,QAAM,MAAM,GAAG,IAAI,CAAC,aAAL,CAAmB,EAAE,CAAC,KAAtB,CAAf;AAEA,QAAM,QAAQ,GAAG,EAAE,CAAC,KAAH,CAAS,CAAT,CAAjB;AACA,QAAM,QAAQ,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,EAAE,CAAC,MAApB,EAA4B,MAA7C;AACA,QAAM,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,CAAC,CAAC,MAAnB,EAA2B,MAA3C;AACA,QAAM,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,CAAC,CAAC,MAAnB,EAA2B,MAA3C;AACA,QAAM,MAAM,GAAG,IAAI,YAAJ,CAAiB,MAAjB,CAAf;AACA,QAAM,IAAI,GAAG,MAAb;;AAEA,OAAK,IAAI,MAAM,GAAG,CAAlB,EAAqB,MAAM,GAAG,IAA9B,EAAoC,MAAM,EAA1C,EAA8C;AAC5C,UAAM,cAAc,GAAG,MAAM,GAAG,QAAhC;AACA,UAAM,UAAU,GACX,MAAM,GAAG,cAAV,GAA4B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,cAAc,GAAG,WAA7B,CADhC;AAEA,UAAM,QAAQ,GAAI,MAAM,GAAG,cAAV,GACb,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,cAAc,GAAG,WAAjB,GAA+B,CAAlD,CADJ;AAGA,QAAI,IAAI,GAAG,CAAX;;AACA,SAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,QAA7B,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,MAAA,IAAI,IAAI,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,CAAD,CAAhB,EAAqB,CAArB,CAAR;AACD;;AACD,IAAA,IAAI,GAAG,KAAK,GAAG,IAAR,GAAe,IAAtB;;AAEA,SAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,QAA7B,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,UAAI,GAAG,GAAG,CAAC,CAAD,GAAK,KAAL,GAAa,IAAb,GAAoB,OAAO,CAAC,CAAD,CAA3B,GAAiC,OAAO,CAAC,MAAD,CAAxC,GAAmD,IAA7D;;AACA,UAAI,MAAM,KAAK,CAAf,EAAkB;AAChB,QAAA,GAAG,IAAI,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,CAAC,IAAhB,CAAP;AACD;;AACD,MAAA,GAAG,IAAI,QAAQ,CAAC,MAAD,CAAf;AACA,MAAA,MAAM,CAAC,CAAD,CAAN,IAAa,GAAb;AACD;AACF;;AAED,SAAO,OAAO,CAAC,cAAR,CAAuB,EAAE,CAAC,KAA1B,EAAiC,CAAC,CAAC,KAAnC,EAA0C,MAA1C,CAAP;AACD;AAED,OAAO,MAAM,aAAa,GAAiB;AACzC,EAAA,UAAU,EAAE,OAD6B;AAEzC,EAAA,WAAW,EAAE,KAF4B;AAGzC,EAAA,UAAU,EAAE;AAH6B,CAApC","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, y, dy } = inputs;\n    const { depthRadius, bias, alpha, beta } = attrs;\n    assertNotComplex(dy, 'LRNGrad');\n    const dySize = util.sizeFromShape(dy.shape);\n    const channels = dy.shape[3];\n    const dyValues = backend.data.get(dy.dataId).values;\n    const xValues = backend.data.get(x.dataId).values;\n    const yValues = backend.data.get(y.dataId).values;\n    const result = new Float32Array(dySize);\n    const size = dySize;\n    for (let offset = 0; offset < size; offset++) {\n        const currentChannel = offset % channels;\n        const depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n        const depthEnd = (offset - currentChannel) +\n            Math.min(channels, currentChannel + depthRadius + 1);\n        let norm = 0;\n        for (let k = depthBegin; k < depthEnd; k++) {\n            norm += Math.pow(xValues[k], 2);\n        }\n        norm = alpha * norm + bias;\n        for (let k = depthBegin; k < depthEnd; k++) {\n            let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n            if (offset === k) {\n                dyi += Math.pow(norm, -beta);\n            }\n            dyi *= dyValues[offset];\n            result[k] += dyi;\n        }\n    }\n    return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport const lRNGradConfig = {\n    kernelName: LRNGrad,\n    backendName: 'cpu',\n    kernelFunc: lRNGrad\n};\n//# sourceMappingURL=LRNGrad.js.map"]},"metadata":{},"sourceType":"module"}