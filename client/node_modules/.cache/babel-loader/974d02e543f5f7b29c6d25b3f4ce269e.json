{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n  const returnValue = func();\n\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n\n  return returnValue;\n}\n\nfunction checkWebGLError(gl) {\n  const error = gl.getError();\n\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n} // https://en.wikipedia.org/wiki/Half-precision_floating-point_format\n\n\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {\n    return true;\n  }\n\n  return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n\n  return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n\n  return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\n\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl) {\n  return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\nexport function validateProgram(gl, program) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\nexport function createStaticVertexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function getNumChannels() {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n\n  return 4;\n}\nexport function createTexture(gl) {\n  return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (width <= 0 || height <= 0) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n\n  if (width > maxTextureSize || height > maxTextureSize) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error('Requested texture size ' + requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\nexport function createFramebuffer(gl) {\n  return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n  const loc = gl.getAttribLocation(program, attribute);\n\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n  return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n  const tOrNull = callAndCheck(gl, () => returnTOrNull());\n\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl, textureUnit) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape, dimsToSkip = 2) {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function getShapeAs3D(shape) {\n  let shapeAs3D = [1, 1, 1];\n  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;\n\n  if (!isScalar) {\n    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];\n  }\n\n  return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2; // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n\n    logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util.nearestLargerEven(logShape[i]) : logShape[i]); // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  } // If logical shape is 2, we don't squeeze, since we want to match physical.\n\n\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {\n    return logShape;\n  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n      const batchDim = getBatchDim(logShape);\n      let rows = 2,\n          cols = 2;\n\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2);\n    }\n\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n) {\n  return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\n\n\nexport function isReshapeFree(shape1, shape2) {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {\n    // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {\n    // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n} // We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\n\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n\n  return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  } // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n\n\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n\n  return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n\n  return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\n\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n  const texConfig = getTextureConfig(gl);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer( // tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion); // tslint:disable-next-line:no-any\n\n  const isEnabled = gl.fenceSync != null;\n  return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` + 'in the WebGL backend.');\n    }\n  });\n}","map":{"version":3,"sources":["../src/webgl_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n    const returnValue = func();\n    if (env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    const error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return `Unknown error code ${status}`;\n    }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n    callAndCheck(gl, () => gl.compileShader(vertexShader));\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n    callAndCheck(gl, () => gl.compileShader(fragmentShader));\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n        console.log(shaderSource);\n        return;\n    }\n    const lineNumber = +lineNumberRegexResult[1];\n    const shaderLines = shaderSource.split('\\n');\n    const pad = shaderLines.length.toString().length + 2;\n    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n    let maxLineLength = 0;\n    for (let i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n    callAndCheck(gl, () => gl.linkProgram(program));\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexport function validateProgram(gl, program) {\n    callAndCheck(gl, () => gl.validateProgram(program));\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexport function createStaticVertexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function getNumChannels() {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexport function createTexture(gl) {\n    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n    const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        const requested = `[${width}x${height}]`;\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        const requested = `[${width}x${height}]`;\n        const max = `[${maxTextureSize}x${maxTextureSize}]`;\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexport function createFramebuffer(gl) {\n    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    const loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n    return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return `unknown error ${status}`;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    const tOrNull = callAndCheck(gl, () => returnTOrNull());\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    const glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n        throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n    }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n    return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nexport function getShapeAs3D(shape) {\n    let shapeAs3D = [1, 1, 1];\n    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape), ...getRowsCols(shape)];\n    }\n    return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n    let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        const squeezeResult = util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    let size = util.sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        return [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            const batchDim = getBatchDim(logShape);\n            let rows = 2, cols = 2;\n            if (logShape.length) {\n                [rows, cols] = getRowsCols(logShape);\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            return util.sizeToSquarishShape(size).map(d => d * 2);\n        }\n        return util.sizeToSquarishShape(size);\n    }\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        const shape1Cols = shape1.slice(-1)[0];\n        const shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    let queryTimerVersion;\n    const gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n    const ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n    try {\n        const gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        console.log('Error when getting WebGL context: ', e);\n        return false;\n    }\n    return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    const texConfig = getTextureConfig(gl);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    const isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(t => {\n        if (t != null) {\n            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +\n                'in the WebGL backend.');\n        }\n    });\n}\n//# sourceMappingURL=webgl_util.js.map"]},"metadata":{},"sourceType":"module"}