{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    segmentIds\n  } = inputs;\n  const {\n    numSegments\n  } = attrs;\n  assertNotComplex(x, 'unsortedSegmentSum');\n  const xRank = x.shape.length;\n  const segmentIdsRank = segmentIds.shape.length;\n  const res = [];\n  const intermediates = []; // Reshape the segment id's so that they can be broadcast with\n  // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n\n  const numIters = xRank - segmentIdsRank;\n  let $segmentIds = segmentIds;\n\n  for (let i = 0; i < numIters; ++i) {\n    const expanded = expandDims({\n      inputs: {\n        input: $segmentIds\n      },\n      backend,\n      attrs: {\n        dim: i + 1\n      }\n    });\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n\n  for (let i = 0; i < numSegments; ++i) {\n    const scalarValue = util.createScalarValue(i, 'int32');\n    const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    const mask = equal({\n      inputs: {\n        a: segmentId,\n        b: $segmentIds\n      },\n      backend\n    });\n    const maskCasted = cast({\n      inputs: {\n        x: mask\n      },\n      backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    const mul = multiply({\n      inputs: {\n        a: maskCasted,\n        b: x\n      },\n      backend\n    });\n    const sumTensorInfo = sum({\n      inputs: {\n        x: mul\n      },\n      backend,\n      attrs: {\n        axis: 0,\n        keepDims: false\n      }\n    });\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n\n  const result = pack({\n    inputs: res,\n    backend,\n    attrs: {\n      axis: 0\n    }\n  });\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\nexport const unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"sources":["../../src/kernels/UnsortedSegmentSum.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAA8C,kBAA9C,EAAqH,IAArH,QAAgI,uBAAhI;AAGA,SAAQ,gBAAR,QAA+B,aAA/B;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,KAAR,QAAoB,SAApB;AACA,SAAQ,UAAR,QAAyB,cAAzB;AACA,SAAQ,QAAR,QAAuB,YAAvB;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,GAAR,QAAkB,OAAlB;AAEA,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAIL;AACC,QAAM;AAAC,IAAA,MAAD;AAAS,IAAA,OAAT;AAAkB,IAAA;AAAlB,MAA2B,IAAjC;AACA,QAAM;AAAC,IAAA,CAAD;AAAI,IAAA;AAAJ,MAAkB,MAAxB;AACA,QAAM;AAAC,IAAA;AAAD,MAAgB,KAAtB;AAEA,EAAA,gBAAgB,CAAC,CAAD,EAAI,oBAAJ,CAAhB;AAEA,QAAM,KAAK,GAAG,CAAC,CAAC,KAAF,CAAQ,MAAtB;AACA,QAAM,cAAc,GAAG,UAAU,CAAC,KAAX,CAAiB,MAAxC;AACA,QAAM,GAAG,GAAG,EAAZ;AACA,QAAM,aAAa,GAAiB,EAApC,CAVD,CAYC;AACA;;AACA,QAAM,QAAQ,GAAG,KAAK,GAAG,cAAzB;AACA,MAAI,WAAW,GAAG,UAAlB;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,EAAE,CAAhC,EAAmC;AACjC,UAAM,QAAQ,GAAG,UAAU,CACvB;AAAC,MAAA,MAAM,EAAE;AAAC,QAAA,KAAK,EAAE;AAAR,OAAT;AAA+B,MAAA,OAA/B;AAAwC,MAAA,KAAK,EAAE;AAAC,QAAA,GAAG,EAAE,CAAC,GAAG;AAAV;AAA/C,KADuB,CAA3B;AAEA,IAAA,WAAW,GAAG,QAAd;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,QAAnB;AACD;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,EAAE,CAAnC,EAAsC;AACpC,UAAM,WAAW,GAAG,IAAI,CAAC,iBAAL,CAAuB,CAAvB,EAA2C,OAA3C,CAApB;AACA,UAAM,SAAS,GAAG,OAAO,CAAC,cAAR,CAAuB,EAAvB,EAA2B,OAA3B,EAAoC,WAApC,CAAlB;AACA,UAAM,IAAI,GACN,KAAK,CAAC;AAAC,MAAA,MAAM,EAAE;AAAC,QAAA,CAAC,EAAE,SAAJ;AAAe,QAAA,CAAC,EAAE;AAAlB,OAAT;AAAyC,MAAA;AAAzC,KAAD,CADT;AAEA,UAAM,UAAU,GACZ,IAAI,CAAC;AAAC,MAAA,MAAM,EAAE;AAAC,QAAA,CAAC,EAAE;AAAJ,OAAT;AAAoB,MAAA,OAApB;AAA6B,MAAA,KAAK,EAAE;AAAC,QAAA,KAAK,EAAE;AAAR;AAApC,KAAD,CADR;AAEA,UAAM,GAAG,GACL,QAAQ,CAAC;AAAC,MAAA,MAAM,EAAE;AAAC,QAAA,CAAC,EAAE,UAAJ;AAAgB,QAAA,CAAC,EAAE;AAAnB,OAAT;AAAgC,MAAA;AAAhC,KAAD,CADZ;AAEA,UAAM,aAAa,GACf,GAAG,CAAC;AAAC,MAAA,MAAM,EAAE;AAAC,QAAA,CAAC,EAAE;AAAJ,OAAT;AAAmB,MAAA,OAAnB;AAA4B,MAAA,KAAK,EAAE;AAAC,QAAA,IAAI,EAAE,CAAP;AAAU,QAAA,QAAQ,EAAE;AAApB;AAAnC,KAAD,CADP;AAEA,IAAA,GAAG,CAAC,IAAJ,CAAS,aAAT;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,SAAnB;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,IAAnB;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,GAAnB;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,aAAnB;AACD;;AAED,QAAM,MAAM,GAAG,IAAI,CAAC;AAAC,IAAA,MAAM,EAAE,GAAT;AAAc,IAAA,OAAd;AAAuB,IAAA,KAAK,EAAE;AAAC,MAAA,IAAI,EAAE;AAAP;AAA9B,GAAD,CAAnB;AAEA,EAAA,aAAa,CAAC,OAAd,CAAsB,CAAC,IAAI,OAAO,CAAC,6BAAR,CAAsC,CAAtC,CAA3B;AAEA,SAAO,MAAP;AACD;AAED,OAAO,MAAM,wBAAwB,GAAiB;AACpD,EAAA,UAAU,EAAE,kBADwC;AAEpD,EAAA,WAAW,EAAE,KAFuC;AAGpD,EAAA,UAAU,EAAE;AAHwC,CAA/C","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, segmentIds } = inputs;\n    const { numSegments } = attrs;\n    assertNotComplex(x, 'unsortedSegmentSum');\n    const xRank = x.shape.length;\n    const segmentIdsRank = segmentIds.shape.length;\n    const res = [];\n    const intermediates = [];\n    // Reshape the segment id's so that they can be broadcast with\n    // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n    const numIters = xRank - segmentIdsRank;\n    let $segmentIds = segmentIds;\n    for (let i = 0; i < numIters; ++i) {\n        const expanded = expandDims({ inputs: { input: $segmentIds }, backend, attrs: { dim: i + 1 } });\n        $segmentIds = expanded;\n        intermediates.push(expanded);\n    }\n    for (let i = 0; i < numSegments; ++i) {\n        const scalarValue = util.createScalarValue(i, 'int32');\n        const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n        const mask = equal({ inputs: { a: segmentId, b: $segmentIds }, backend });\n        const maskCasted = cast({ inputs: { x: mask }, backend, attrs: { dtype: 'float32' } });\n        const mul = multiply({ inputs: { a: maskCasted, b: x }, backend });\n        const sumTensorInfo = sum({ inputs: { x: mul }, backend, attrs: { axis: 0, keepDims: false } });\n        res.push(sumTensorInfo);\n        intermediates.push(segmentId);\n        intermediates.push(mask);\n        intermediates.push(maskCasted);\n        intermediates.push(mul);\n        intermediates.push(sumTensorInfo);\n    }\n    const result = pack({ inputs: res, backend, attrs: { axis: 0 } });\n    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const unsortedSegmentSumConfig = {\n    kernelName: UnsortedSegmentSum,\n    backendName: 'cpu',\n    kernelFunc: unsortedSegmentSum\n};\n//# sourceMappingURL=UnsortedSegmentSum.js.map"]},"metadata":{},"sourceType":"module"}