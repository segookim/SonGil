{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighbor, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighbor(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images;\n  var alignCorners = attrs.alignCorners,\n      halfPixelCenters = attrs.halfPixelCenters,\n      size = attrs.size;\n  assertNotComplex(images, 'resizeNearestNeighbor');\n  var imagesStrides = util.computeStrides(images.shape);\n\n  var _size = _slicedToArray(size, 2),\n      newHeight = _size[0],\n      newWidth = _size[1];\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      oldHeight = _images$shape[1],\n      oldWidth = _images$shape[2],\n      numChannels = _images$shape[3];\n\n  var xValues = backend.data.get(images.dataId).values;\n  var output = new Float32Array(batch * newHeight * newWidth * numChannels);\n  var effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n  var effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n  var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n  var outputOffset = 0;\n\n  for (var b = 0; b < batch; b++) {\n    var batchOffset = b * imagesStrides[0];\n\n    for (var r = 0; r < newHeight; r++) {\n      var sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r + 0.5) : effectiveRowSizeRatio * r;\n      var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n      if (halfPixelCenters) {\n        sourceNearestRow = Math.max(0, sourceNearestRow);\n      }\n\n      var rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n\n      for (var c = 0; c < newWidth; c++) {\n        var sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c + 0.5) : effectiveColSizeRatio * c;\n        var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n        if (halfPixelCenters) {\n          sourceNearestCol = Math.max(0, sourceNearestCol);\n        }\n\n        var colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n\n        for (var d = 0; d < numChannels; d++) {\n          // Begin shader.\n          // Compute the fractional index of the source.\n          var newVal = xValues[colOffset + d];\n          output[outputOffset++] = newVal;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\nexport var resizeNearestNeighborConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'cpu',\n  kernelFunc: resizeNearestNeighbor\n};","map":{"version":3,"sources":["../../src/kernels/ResizeNearestNeighbor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighbor, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighbor(args) {\n    const { inputs, backend, attrs } = args;\n    const { images } = inputs;\n    const { alignCorners, halfPixelCenters, size } = attrs;\n    assertNotComplex(images, 'resizeNearestNeighbor');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [newHeight, newWidth] = size;\n    const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n    const xValues = backend.data.get(images.dataId).values;\n    const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n    const effectiveInputSize = [\n        (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n        (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n    const effectiveOutputSize = [\n        (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n        (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    let outputOffset = 0;\n    for (let b = 0; b < batch; b++) {\n        const batchOffset = b * imagesStrides[0];\n        for (let r = 0; r < newHeight; r++) {\n            const sourceFracRow = halfPixelCenters ?\n                effectiveRowSizeRatio * (r + 0.5) :\n                effectiveRowSizeRatio * r;\n            let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n            if (halfPixelCenters) {\n                sourceNearestRow = Math.max(0, sourceNearestRow);\n            }\n            const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n            for (let c = 0; c < newWidth; c++) {\n                const sourceFracCol = halfPixelCenters ?\n                    effectiveColSizeRatio * (c + 0.5) :\n                    effectiveColSizeRatio * c;\n                let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                    Math.floor(sourceFracCol));\n                if (halfPixelCenters) {\n                    sourceNearestCol = Math.max(0, sourceNearestCol);\n                }\n                const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n                for (let d = 0; d < numChannels; d++) {\n                    // Begin shader.\n                    // Compute the fractional index of the source.\n                    const newVal = xValues[colOffset + d];\n                    output[outputOffset++] = newVal;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\nexport const resizeNearestNeighborConfig = {\n    kernelName: ResizeNearestNeighbor,\n    backendName: 'cpu',\n    kernelFunc: resizeNearestNeighbor\n};\n//# sourceMappingURL=ResizeNearestNeighbor.js.map"]},"metadata":{},"sourceType":"module"}