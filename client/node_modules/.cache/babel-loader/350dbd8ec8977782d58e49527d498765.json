{"ast":null,"code":"import _classCallCheck from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport var InputLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(InputLayer, _Layer);\n\n  var _super = _createSuper(InputLayer);\n\n  function InputLayer(args) {\n    var _this;\n\n    _classCallCheck(this, InputLayer);\n\n    _this = _super.call(this, {\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    }); // Normalize config.batchSize and config.sparse\n\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n\n    _this.trainable = false;\n    _this.built = true;\n    _this.sparse = args.sparse;\n\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError('Only provide the inputShape OR ' + 'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n\n    var batchInputShape = args.batchInputShape;\n\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError('An InputLayer should be passed either a ' + '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError('Cannot specify batchSize if batchInputShape is ' + 'specified when creating an InputLayer.');\n      }\n    }\n\n    var dtype = args.dtype || 'float32';\n    _this.batchInputShape = batchInputShape;\n    _this.dtype = dtype; // TODO(michaelterry): Backport this to PyKeras?\n\n    _this.inputSpec = [{\n      shape: batchInputShape\n    }];\n    var inputTensor = new SymbolicTensor(_this.dtype, _this.batchInputShape, _assertThisInitialized(_this), [], {}, _this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0; // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n\n    new Node({\n      outboundLayer: _assertThisInitialized(_this),\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n    return _this;\n  }\n\n  _createClass(InputLayer, [{\n    key: \"apply\",\n    value: function apply(inputs, kwargs) {\n      throw new ValueError('Cannot pass any input to an ' + \"InputLayer's apply() method. InputLayer name: \".concat(this.name));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      // dispose() for InputLayer is overridden as no-op.\n      return {\n        refCountAfterDispose: this._refCount,\n        numDisposedVariables: 0\n      };\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return {\n        batchInputShape: this.batchInputShape,\n        dtype: this.dtype,\n        sparse: this.sparse,\n        name: this.name\n      };\n    }\n  }]);\n\n  return InputLayer;\n}(Layer);\n/** @nocollapse */\n\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error('Please provide to Input either a `shape`' + ' or a `batchShape` argument. Note that ' + '`shape` does not include the batch ' + 'dimension.');\n  }\n\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError('Please provide either a `shape` or `batchShape` ' + 'argument to Input, but not both.');\n  }\n\n  var batchShape = config.batchShape;\n\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n\n  var dtype = config.dtype;\n\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n\n  var inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype: dtype,\n    sparse: config.sparse\n  });\n  var outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}","map":{"version":3,"sources":["../../src/engine/input_layer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n    constructor(args) {\n        super({\n            dtype: args.dtype,\n            name: args.name != null ? args.name : getUid('input').toString()\n        });\n        // Normalize config.batchSize and config.sparse\n        if (args.batchSize == null) {\n            args.batchSize = null;\n        }\n        if (args.sparse == null) {\n            args.sparse = false;\n        }\n        this.trainable = false;\n        this.built = true;\n        this.sparse = args.sparse;\n        if (args.inputShape != null && args.batchInputShape != null) {\n            throw new ValueError('Only provide the inputShape OR ' +\n                'batchInputShape argument to inputLayer, not both at the same time.');\n        }\n        let batchInputShape = args.batchInputShape;\n        if (batchInputShape == null) {\n            if (args.inputShape == null) {\n                throw new ValueError('An InputLayer should be passed either a ' +\n                    '`batchInputShape` or an `inputShape`.');\n            }\n            else {\n                batchInputShape = [args.batchSize].concat(args.inputShape);\n            }\n        }\n        else {\n            // TODO(michaelterry): Backport to PyKeras\n            if (args.batchSize != null) {\n                throw new ValueError('Cannot specify batchSize if batchInputShape is ' +\n                    'specified when creating an InputLayer.');\n            }\n        }\n        const dtype = args.dtype || 'float32';\n        this.batchInputShape = batchInputShape;\n        this.dtype = dtype;\n        // TODO(michaelterry): Backport this to PyKeras?\n        this.inputSpec = [{ shape: batchInputShape }];\n        const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n        inputTensor.nodeIndex = 0;\n        inputTensor.tensorIndex = 0;\n        // Create an input node to add to this.outboundNode.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: [inputTensor],\n            outputTensors: [inputTensor],\n            inputMasks: [null],\n            outputMasks: [null],\n            inputShapes: [batchInputShape],\n            outputShapes: [batchInputShape]\n        });\n    }\n    apply(inputs, kwargs) {\n        throw new ValueError('Cannot pass any input to an ' +\n            `InputLayer's apply() method. InputLayer name: ${this.name}`);\n    }\n    dispose() {\n        // dispose() for InputLayer is overridden as no-op.\n        return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };\n    }\n    getConfig() {\n        return {\n            batchInputShape: this.batchInputShape,\n            dtype: this.dtype,\n            sparse: this.sparse,\n            name: this.name\n        };\n    }\n}\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n    if (config.batchShape == null && config.shape == null) {\n        throw new Error('Please provide to Input either a `shape`' +\n            ' or a `batchShape` argument. Note that ' +\n            '`shape` does not include the batch ' +\n            'dimension.');\n    }\n    if (config.batchShape != null && config.shape != null) {\n        // TODO(michaelterry): Backport to PyKeras.\n        throw new ValueError('Please provide either a `shape` or `batchShape` ' +\n            'argument to Input, but not both.');\n    }\n    let batchShape = config.batchShape;\n    if (config.shape != null && batchShape == null) {\n        batchShape = [null].concat(config.shape);\n    }\n    let dtype = config.dtype;\n    if (dtype == null) {\n        dtype = 'float32';\n    }\n    const inputLayer = new InputLayer({\n        batchInputShape: batchShape,\n        name: config.name,\n        dtype,\n        sparse: config.sparse\n    });\n    const outputs = inputLayer.inboundNodes[0].outputTensors;\n    return outputs[0];\n}\n//# sourceMappingURL=input_layer.js.map"]},"metadata":{},"sourceType":"module"}