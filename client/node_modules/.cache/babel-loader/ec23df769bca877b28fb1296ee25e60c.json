{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils'; // A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\n\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\n\nexport function nameScope(name, fn) {\n  _nameScopeStack.push(name);\n\n  try {\n    const val = fn();\n\n    _nameScopeStack.pop();\n\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n\n    throw e;\n  }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\n\nfunction currentNameScopePrefix() {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\n\n\nexport function getScopedTensorName(tensorName) {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n\n  return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\n\nexport function getUniqueTensorName(scopedName) {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    const result = `${scopedName}_${index}`; // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\n\nexport function isValidTensorName(name) {\n  return !!name.match(tensorNameRegex);\n}","map":{"version":3,"sources":["../src/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils';\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n    checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope(name, fn) {\n    _nameScopeStack.push(name);\n    try {\n        const val = fn();\n        _nameScopeStack.pop();\n        return val;\n    }\n    catch (e) {\n        _nameScopeStack.pop();\n        throw e;\n    }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix() {\n    if (_nameScopeStack.length === 0) {\n        return '';\n    }\n    else {\n        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n    }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName) {\n    if (!isValidTensorName(tensorName)) {\n        throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n    }\n    return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName) {\n    if (!isValidTensorName(scopedName)) {\n        throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n    }\n    if (!nameMap.has(scopedName)) {\n        nameMap.set(scopedName, 0);\n    }\n    const index = nameMap.get(scopedName);\n    nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n    if (index > 0) {\n        const result = `${scopedName}_${index}`;\n        // Mark the composed name as used in case someone wants\n        // to call getUniqueTensorName(\"name_1\").\n        nameMap.set(result, 1);\n        return result;\n    }\n    else {\n        return scopedName;\n    }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name) {\n    return !!name.match(tensorNameRegex);\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}