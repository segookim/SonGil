{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nimport { SliceProgram } from '../slice_gpu';\nimport { SlicePackedProgram } from '../slice_packed_gpu';\n\nfunction shallowSlice(x, begin, size, backend) {\n  const xTexData = backend.texData.get(x.dataId);\n  const t = backend.makeTensorInfo(size, x.dtype);\n  const newTexData = backend.texData.get(t.dataId); // Copy texture data from the original tensor.\n\n  Object.assign(newTexData, xTexData);\n  newTexData.refCount = 1;\n  newTexData.shape = size;\n  newTexData.dtype = x.dtype;\n  let flatOffset = slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n\n  if (xTexData.slice) {\n    // We are slicing an already sliced tensor, so we have to accumulate\n    // the offset.\n    flatOffset += xTexData.slice.flatOffset;\n  }\n\n  newTexData.slice = {\n    flatOffset,\n    // Point to the original dataId, which is used to do ref counting.\n    origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n  }; // Increase the ref count for that data bucket.\n\n  const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n  backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n  return t;\n}\n\nexport function slice(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    begin,\n    size\n  } = attrs;\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  if (util.sizeFromShape($size) === 0) {\n    return backend.makeTensorInfo($size, x.dtype, []);\n  } // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgl doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n\n\n  if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n    const xTexData = backend.texData.get(x.dataId);\n    const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outValues);\n  }\n\n  const {\n    isPacked\n  } = backend.texData.get(x.dataId);\n  const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n\n  if (isPacked || !isContinous) {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new SlicePackedProgram($size) : new SliceProgram($size);\n    const customSetup = program.getCustomSetupFunc($begin);\n    return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n  }\n\n  backend.uploadToGPU(x.dataId);\n  return shallowSlice(x, $begin, $size, backend);\n}\nexport const sliceConfig = {\n  kernelName: Slice,\n  backendName: 'webgl',\n  kernelFunc: slice\n};","map":{"version":3,"sources":["../../src/kernels/Slice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nimport { SliceProgram } from '../slice_gpu';\nimport { SlicePackedProgram } from '../slice_packed_gpu';\nfunction shallowSlice(x, begin, size, backend) {\n    const xTexData = backend.texData.get(x.dataId);\n    const t = backend.makeTensorInfo(size, x.dtype);\n    const newTexData = backend.texData.get(t.dataId);\n    // Copy texture data from the original tensor.\n    Object.assign(newTexData, xTexData);\n    newTexData.refCount = 1;\n    newTexData.shape = size;\n    newTexData.dtype = x.dtype;\n    let flatOffset = slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n    if (xTexData.slice) {\n        // We are slicing an already sliced tensor, so we have to accumulate\n        // the offset.\n        flatOffset += xTexData.slice.flatOffset;\n    }\n    newTexData.slice = {\n        flatOffset,\n        // Point to the original dataId, which is used to do ref counting.\n        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n    };\n    // Increase the ref count for that data bucket.\n    const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n    return t;\n}\nexport function slice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, size } = attrs;\n    const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n    slice_util.assertParamsValid(x, $begin, $size);\n    if (util.sizeFromShape($size) === 0) {\n        return backend.makeTensorInfo($size, x.dtype, []);\n    }\n    // Run on cpu if dtype is string. For string, the backend represents it\n    // as Uint8Array[], where each Uint8Array is a character. Given that the\n    // computation is only on the outer array, uploading the whole data onto\n    // gpu is wasteful. Also, currently webgl doesn't have a design to\n    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n    // just run the kernel on cpu if dtype is string.\n    if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n        const xTexData = backend.texData.get(x.dataId);\n        const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);\n        return backend.makeTensorInfo($size, x.dtype, outValues);\n    }\n    const { isPacked } = backend.texData.get(x.dataId);\n    const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n    if (isPacked || !isContinous) {\n        const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n            new SlicePackedProgram($size) :\n            new SliceProgram($size);\n        const customSetup = program.getCustomSetupFunc($begin);\n        return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n    }\n    backend.uploadToGPU(x.dataId);\n    return shallowSlice(x, $begin, $size, backend);\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'webgl',\n    kernelFunc: slice\n};\n//# sourceMappingURL=Slice.js.map"]},"metadata":{},"sourceType":"module"}