{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\n\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n\n\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool( // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\n\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // x is NDHWC after preprocessing.\n\n\n    x = preprocessConv3DInput(x, dataFormat);\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\n\nexport class Pooling1D extends Layer {\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n\n    super(args);\n\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);\n      }\n    }\n\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs); // Add dummy last dimension.\n\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast'); // Remove dummy last dimension.\n\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\n\nexport class Pooling2D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\n\nexport class Pooling3D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\n\nexport class GlobalPooling1D extends Layer {\n  constructor(args) {\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\n\nexport class GlobalPooling2D extends Layer {\n  constructor(args) {\n    super(args);\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n  getConfig() {\n    const config = {\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"sources":["../../src/layers/pooling.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n        // dataFormat as an input argument.\n        x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            // TODO(cais): Rank check?\n            y = tfc.maxPool(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            // TODO(cais): Check the dtype and rank of x and give clear error message\n            //   if those are incorrect.\n            y = tfc.avgPool(\n            // TODO(cais): Rank check?\n            x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n        }\n        return y;\n    });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // x is NDHWC after preprocessing.\n        x = preprocessConv3DInput(x, dataFormat);\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n        }\n        return y;\n    });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport class Pooling1D extends Layer {\n    /**\n     *\n     * @param args Parameters for the Pooling layer.\n     *\n     * config.poolSize defaults to 2.\n     */\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = 2;\n        }\n        super(args);\n        if (typeof args.poolSize === 'number') {\n            this.poolSize = [args.poolSize];\n        }\n        else if (Array.isArray(args.poolSize) &&\n            args.poolSize.length === 1 &&\n            typeof args.poolSize[0] === 'number') {\n            this.poolSize = args.poolSize;\n        }\n        else {\n            throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` +\n                `Array of a single number, but received ` +\n                `${JSON.stringify(args.poolSize)}`);\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else {\n            if (typeof args.strides === 'number') {\n                this.strides = [args.strides];\n            }\n            else if (Array.isArray(args.strides) &&\n                args.strides.length === 1 &&\n                typeof args.strides[0] === 'number') {\n                this.strides = args.strides;\n            }\n            else {\n                throw new ValueError(`strides for 1D convolutional layer must be a number or an ` +\n                    `Array of a single number, but received ` +\n                    `${JSON.stringify(args.strides)}`);\n            }\n        }\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n        return [inputShape[0], length, inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            // Add dummy last dimension.\n            inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n            const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast');\n            // Remove dummy last dimension.\n            return tfc.squeeze(output, [2]);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport class Pooling2D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 2) {\n                throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` +\n                    `it is expected to have a length of 2, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        rows =\n            convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n        cols =\n            convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], rows, cols];\n        }\n        else {\n            return [inputShape[0], rows, cols, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport class Pooling3D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 3) {\n                throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` +\n                    `it is expected to have a length of 3, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n        depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n        rows =\n            convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n        cols =\n            convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], depths, rows, cols];\n        }\n        else {\n            return [inputShape[0], depths, rows, cols, inputShape[4]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport class GlobalPooling1D extends Layer {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        return [inputShape[0], inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.mean(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.max(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport class GlobalPooling2D extends Layer {\n    constructor(args) {\n        super(args);\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = inputShape;\n        if (this.dataFormat === 'channelsLast') {\n            return [inputShape[0], inputShape[3]];\n        }\n        else {\n            return [inputShape[0], inputShape[1]];\n        }\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n    getConfig() {\n        const config = { dataFormat: this.dataFormat };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.mean(input, [1, 2]);\n            }\n            else {\n                return tfc.mean(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.max(input, [1, 2]);\n            }\n            else {\n                return tfc.max(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);\n//# sourceMappingURL=pooling.js.map"]},"metadata":{},"sourceType":"module"}