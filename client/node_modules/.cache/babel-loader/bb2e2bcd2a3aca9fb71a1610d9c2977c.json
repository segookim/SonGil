{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../../tensor_util_env';\nimport { assert } from '../../util';\nimport { greaterEqual } from '../greater_equal';\nimport { lessEqual } from '../less_equal';\nimport { logicalAnd } from '../logical_and';\nimport { op } from '../operation';\nimport { range } from '../range';\nimport { reshape } from '../reshape';\nimport { scalar } from '../scalar';\nimport { stack } from '../stack';\nimport { sub } from '../sub';\nimport { unstack } from '../unstack';\nimport { where } from '../where';\nimport { zeros } from '../zeros';\n/**\n * Copy a tensor setting everything outside a central band in each innermost\n * matrix to zero.\n *\n * The band part is computed as follows: Assume input has `k` dimensions\n * `[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where\n * `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n * The indicator function\n * `in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower))`\n * `&& (num_upper < 0 || (n-m) <= num_upper)`\n *\n * ```js\n * const x = tf.tensor2d([[ 0,  1,  2, 3],\n *                        [-1,  0,  1, 2],\n *                        [-2, -1,  0, 1],\n *                        [-3, -2, -1, 0]]);\n * let y = tf.linalg.bandPart(x, 1, -1);\n * y.print(); // [[ 0,  1,  2, 3],\n *            //  [-1,  0,  1, 2],\n *            //  [ 0, -1,  0, 1],\n *            //  [ 0, 0 , -1, 0]]\n * let z = tf.linalg.bandPart(x, 2, 1);\n * z.print(); // [[ 0,  1,  0, 0],\n *            //  [-1,  0,  1, 0],\n *            //  [-2, -1,  0, 1],\n *            //  [ 0, -2, -1, 0]]\n * ```\n *\n * @param x Rank `k` tensor\n * @param numLower Number of subdiagonals to keep.\n *   If negative, keep entire lower triangle.\n * @param numUpper Number of subdiagonals to keep.\n *   If negative, keep entire upper triangle.\n * @returns Rank `k` tensor of the same shape as input.\n *   The extracted banded tensor.\n *\n * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}\n */\n\nfunction bandPart_(a, numLower, numUpper) {\n  assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);\n  assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);\n  const $a = convertToTensor(a, 'a', 'bandPart');\n  assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);\n  const shape = $a.shape;\n  const [M, N] = $a.shape.slice(-2);\n\n  if (!(numLower <= M)) {\n    throw new Error(`bandPart(): numLower (${numLower})` + ` must not be greater than the number of rows (${M}).`);\n  }\n\n  if (!(numUpper <= N)) {\n    throw new Error(`bandPart(): numUpper (${numUpper})` + ` must not be greater than the number of columns (${N}).`);\n  }\n\n  if (numLower < 0) {\n    numLower = M;\n  }\n\n  if (numUpper < 0) {\n    numUpper = N;\n  }\n\n  const i = reshape(range(0, M, 1, 'int32'), [-1, 1]);\n  const j = range(0, N, 1, 'int32');\n  const ij = sub(i, j);\n  const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, 'int32')), greaterEqual(ij, scalar(-numUpper, 'int32')));\n  const zero = zeros([M, N], $a.dtype);\n  return reshape(stack(unstack(reshape($a, [-1, M, N])).map(mat => where(inBand, mat, zero))), shape);\n}\n\nexport const bandPart = op({\n  bandPart_\n});","map":{"version":3,"sources":["../../../src/ops/linalg/band_part.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../../tensor_util_env';\nimport { assert } from '../../util';\nimport { greaterEqual } from '../greater_equal';\nimport { lessEqual } from '../less_equal';\nimport { logicalAnd } from '../logical_and';\nimport { op } from '../operation';\nimport { range } from '../range';\nimport { reshape } from '../reshape';\nimport { scalar } from '../scalar';\nimport { stack } from '../stack';\nimport { sub } from '../sub';\nimport { unstack } from '../unstack';\nimport { where } from '../where';\nimport { zeros } from '../zeros';\n/**\n * Copy a tensor setting everything outside a central band in each innermost\n * matrix to zero.\n *\n * The band part is computed as follows: Assume input has `k` dimensions\n * `[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where\n * `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n * The indicator function\n * `in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower))`\n * `&& (num_upper < 0 || (n-m) <= num_upper)`\n *\n * ```js\n * const x = tf.tensor2d([[ 0,  1,  2, 3],\n *                        [-1,  0,  1, 2],\n *                        [-2, -1,  0, 1],\n *                        [-3, -2, -1, 0]]);\n * let y = tf.linalg.bandPart(x, 1, -1);\n * y.print(); // [[ 0,  1,  2, 3],\n *            //  [-1,  0,  1, 2],\n *            //  [ 0, -1,  0, 1],\n *            //  [ 0, 0 , -1, 0]]\n * let z = tf.linalg.bandPart(x, 2, 1);\n * z.print(); // [[ 0,  1,  0, 0],\n *            //  [-1,  0,  1, 0],\n *            //  [-2, -1,  0, 1],\n *            //  [ 0, -2, -1, 0]]\n * ```\n *\n * @param x Rank `k` tensor\n * @param numLower Number of subdiagonals to keep.\n *   If negative, keep entire lower triangle.\n * @param numUpper Number of subdiagonals to keep.\n *   If negative, keep entire upper triangle.\n * @returns Rank `k` tensor of the same shape as input.\n *   The extracted banded tensor.\n *\n * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}\n */\nfunction bandPart_(a, numLower, numUpper) {\n    assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);\n    assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);\n    const $a = convertToTensor(a, 'a', 'bandPart');\n    assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);\n    const shape = $a.shape;\n    const [M, N] = $a.shape.slice(-2);\n    if (!(numLower <= M)) {\n        throw new Error(`bandPart(): numLower (${numLower})` +\n            ` must not be greater than the number of rows (${M}).`);\n    }\n    if (!(numUpper <= N)) {\n        throw new Error(`bandPart(): numUpper (${numUpper})` +\n            ` must not be greater than the number of columns (${N}).`);\n    }\n    if (numLower < 0) {\n        numLower = M;\n    }\n    if (numUpper < 0) {\n        numUpper = N;\n    }\n    const i = reshape(range(0, M, 1, 'int32'), [-1, 1]);\n    const j = range(0, N, 1, 'int32');\n    const ij = sub(i, j);\n    const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, 'int32')), greaterEqual(ij, scalar(-numUpper, 'int32')));\n    const zero = zeros([M, N], $a.dtype);\n    return reshape(stack(unstack(reshape($a, [-1, M, N]))\n        .map(mat => where(inBand, mat, zero))), shape);\n}\nexport const bandPart = op({ bandPart_ });\n//# sourceMappingURL=band_part.js.map"]},"metadata":{},"sourceType":"module"}