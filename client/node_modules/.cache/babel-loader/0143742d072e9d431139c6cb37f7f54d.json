{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util'; // Maximum number of values before we decide to show ellipsis.\n\nconst FORMAT_LIMIT_NUM_VALS = 20; // Number of first and last values to show when displaying a, b,...,y, z.\n\nconst FORMAT_NUM_FIRST_LAST_VALS = 3; // Number of significant digits to show.\n\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad, dtype) {\n  let valStr;\n\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` + `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n  const size = shape[0];\n  const rank = shape.length;\n\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      let firstVals = Array.from(vals.slice(0, firstValsSize));\n      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n\n      return ['[' + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ', ..., ' + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(', ') + ']'];\n    }\n\n    const displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ']'];\n  } // The array is rank 2 or more.\n\n\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false\n      /* isLast */\n      ));\n    }\n\n    lines.push('...');\n\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  }\n\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n\n  let newLineSep = ',\\n';\n\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals) {\n  const complexTuples = [];\n\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n\n  return complexTuples;\n}","map":{"version":3,"sources":["../src/tensor_format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n//# sourceMappingURL=tensor_format.js.map"]},"metadata":{},"sourceType":"module"}