{"ast":null,"code":"import _toConsumableArray from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _assertThisInitialized from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\n\nexport var ModelLoggingVerbosity;\n\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\n\n\nexport var DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\n\nexport var BaseCallback = /*#__PURE__*/function () {\n  function BaseCallback() {\n    _classCallCheck(this, BaseCallback);\n\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n\n  _createClass(BaseCallback, [{\n    key: \"setParams\",\n    value: function setParams(params) {\n      this.params = params;\n    }\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(epoch, logs) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function onEpochBegin(_x, _x2) {\n        return _onEpochBegin.apply(this, arguments);\n      }\n\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(epoch, logs) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function onEpochEnd(_x3, _x4) {\n        return _onEpochEnd.apply(this, arguments);\n      }\n\n      return onEpochEnd;\n    }()\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(batch, logs) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function onBatchBegin(_x5, _x6) {\n        return _onBatchBegin.apply(this, arguments);\n      }\n\n      return onBatchBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(batch, logs) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function onBatchEnd(_x7, _x8) {\n        return _onBatchEnd.apply(this, arguments);\n      }\n\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(logs) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function onTrainBegin(_x9) {\n        return _onTrainBegin.apply(this, arguments);\n      }\n\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(logs) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function onTrainEnd(_x10) {\n        return _onTrainEnd.apply(this, arguments);\n      }\n\n      return onTrainEnd;\n    }() // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {// Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n  }]);\n\n  return BaseCallback;\n}();\n/**\n * Container abstracting a list of callbacks.\n */\n\nexport var CallbackList = /*#__PURE__*/function () {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  function CallbackList(callbacks) {\n    var queueLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, CallbackList);\n\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  _createClass(CallbackList, [{\n    key: \"append\",\n    value: function append(callback) {\n      this.callbacks.push(callback);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(params) {\n      var _iterator = _createForOfIteratorHelper(this.callbacks),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var callback = _step.value;\n          callback.setParams(params);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {\n      var _iterator2 = _createForOfIteratorHelper(this.callbacks),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var callback = _step2.value;\n          callback.setModel(model);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(epoch, logs) {\n        var _iterator3, _step3, callback;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                _iterator3 = _createForOfIteratorHelper(this.callbacks);\n                _context7.prev = 2;\n\n                _iterator3.s();\n\n              case 4:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                callback = _step3.value;\n                _context7.next = 8;\n                return callback.onEpochBegin(epoch, logs);\n\n              case 8:\n                _context7.next = 4;\n                break;\n\n              case 10:\n                _context7.next = 15;\n                break;\n\n              case 12:\n                _context7.prev = 12;\n                _context7.t0 = _context7[\"catch\"](2);\n\n                _iterator3.e(_context7.t0);\n\n              case 15:\n                _context7.prev = 15;\n\n                _iterator3.f();\n\n                return _context7.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[2, 12, 15, 18]]);\n      }));\n\n      function onEpochBegin(_x11, _x12) {\n        return _onEpochBegin2.apply(this, arguments);\n      }\n\n      return onEpochBegin;\n    }()\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(epoch, logs) {\n        var _iterator4, _step4, callback;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                _iterator4 = _createForOfIteratorHelper(this.callbacks);\n                _context8.prev = 2;\n\n                _iterator4.s();\n\n              case 4:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                callback = _step4.value;\n                _context8.next = 8;\n                return callback.onEpochEnd(epoch, logs);\n\n              case 8:\n                _context8.next = 4;\n                break;\n\n              case 10:\n                _context8.next = 15;\n                break;\n\n              case 12:\n                _context8.prev = 12;\n                _context8.t0 = _context8[\"catch\"](2);\n\n                _iterator4.e(_context8.t0);\n\n              case 15:\n                _context8.prev = 15;\n\n                _iterator4.f();\n\n                return _context8.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[2, 12, 15, 18]]);\n      }));\n\n      function onEpochEnd(_x13, _x14) {\n        return _onEpochEnd2.apply(this, arguments);\n      }\n\n      return onEpochEnd;\n    }()\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(batch, logs) {\n        var _iterator5, _step5, callback;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                _iterator5 = _createForOfIteratorHelper(this.callbacks);\n                _context9.prev = 2;\n\n                _iterator5.s();\n\n              case 4:\n                if ((_step5 = _iterator5.n()).done) {\n                  _context9.next = 10;\n                  break;\n                }\n\n                callback = _step5.value;\n                _context9.next = 8;\n                return callback.onBatchBegin(batch, logs);\n\n              case 8:\n                _context9.next = 4;\n                break;\n\n              case 10:\n                _context9.next = 15;\n                break;\n\n              case 12:\n                _context9.prev = 12;\n                _context9.t0 = _context9[\"catch\"](2);\n\n                _iterator5.e(_context9.t0);\n\n              case 15:\n                _context9.prev = 15;\n\n                _iterator5.f();\n\n                return _context9.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[2, 12, 15, 18]]);\n      }));\n\n      function onBatchBegin(_x15, _x16) {\n        return _onBatchBegin2.apply(this, arguments);\n      }\n\n      return onBatchBegin;\n    }()\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(batch, logs) {\n        var _iterator6, _step6, callback;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                _iterator6 = _createForOfIteratorHelper(this.callbacks);\n                _context10.prev = 2;\n\n                _iterator6.s();\n\n              case 4:\n                if ((_step6 = _iterator6.n()).done) {\n                  _context10.next = 10;\n                  break;\n                }\n\n                callback = _step6.value;\n                _context10.next = 8;\n                return callback.onBatchEnd(batch, logs);\n\n              case 8:\n                _context10.next = 4;\n                break;\n\n              case 10:\n                _context10.next = 15;\n                break;\n\n              case 12:\n                _context10.prev = 12;\n                _context10.t0 = _context10[\"catch\"](2);\n\n                _iterator6.e(_context10.t0);\n\n              case 15:\n                _context10.prev = 15;\n\n                _iterator6.f();\n\n                return _context10.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 12, 15, 18]]);\n      }));\n\n      function onBatchEnd(_x17, _x18) {\n        return _onBatchEnd2.apply(this, arguments);\n      }\n\n      return onBatchEnd;\n    }()\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(logs) {\n        var _iterator7, _step7, callback;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                _iterator7 = _createForOfIteratorHelper(this.callbacks);\n                _context11.prev = 2;\n\n                _iterator7.s();\n\n              case 4:\n                if ((_step7 = _iterator7.n()).done) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                callback = _step7.value;\n                _context11.next = 8;\n                return callback.onTrainBegin(logs);\n\n              case 8:\n                _context11.next = 4;\n                break;\n\n              case 10:\n                _context11.next = 15;\n                break;\n\n              case 12:\n                _context11.prev = 12;\n                _context11.t0 = _context11[\"catch\"](2);\n\n                _iterator7.e(_context11.t0);\n\n              case 15:\n                _context11.prev = 15;\n\n                _iterator7.f();\n\n                return _context11.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[2, 12, 15, 18]]);\n      }));\n\n      function onTrainBegin(_x19) {\n        return _onTrainBegin2.apply(this, arguments);\n      }\n\n      return onTrainBegin;\n    }()\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(logs) {\n        var _iterator8, _step8, callback;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                _iterator8 = _createForOfIteratorHelper(this.callbacks);\n                _context12.prev = 2;\n\n                _iterator8.s();\n\n              case 4:\n                if ((_step8 = _iterator8.n()).done) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                callback = _step8.value;\n                _context12.next = 8;\n                return callback.onTrainEnd(logs);\n\n              case 8:\n                _context12.next = 4;\n                break;\n\n              case 10:\n                _context12.next = 15;\n                break;\n\n              case 12:\n                _context12.prev = 12;\n                _context12.t0 = _context12[\"catch\"](2);\n\n                _iterator8.e(_context12.t0);\n\n              case 15:\n                _context12.prev = 15;\n\n                _iterator8.f();\n\n                return _context12.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[2, 12, 15, 18]]);\n      }));\n\n      function onTrainEnd(_x20) {\n        return _onTrainEnd2.apply(this, arguments);\n      }\n\n      return onTrainEnd;\n    }()\n  }]);\n\n  return CallbackList;\n}();\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\n\nexport var BaseLogger = /*#__PURE__*/function (_BaseCallback) {\n  _inherits(BaseLogger, _BaseCallback);\n\n  var _super = _createSuper(BaseLogger);\n\n  function BaseLogger() {\n    _classCallCheck(this, BaseLogger);\n\n    return _super.call(this);\n  }\n\n  _createClass(BaseLogger, [{\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(epoch) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                this.seen = 0;\n                this.totals = {};\n\n              case 2:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function onEpochBegin(_x21) {\n        return _onEpochBegin3.apply(this, arguments);\n      }\n\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(batch, logs) {\n        var _this = this;\n\n        var batchSize, _loop, key;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                batchSize = logs['size'] == null ? 0 : logs['size'];\n                this.seen += batchSize;\n\n                _loop = function _loop(key) {\n                  var value = logs[key];\n\n                  if (typeof value === 'number') {\n                    if (!_this.totals.hasOwnProperty(key)) {\n                      _this.totals[key] = 0;\n                    }\n\n                    _this.totals[key] = _this.totals[key] + value * batchSize;\n                  } else {\n                    var oldTotalsToDispose;\n\n                    if (key in _this.totals) {\n                      oldTotalsToDispose = _this.totals[key];\n                    } else {\n                      _this.totals[key] = 0;\n                    }\n\n                    var total = tidy(function () {\n                      return add(_this.totals[key], mul(value, batchSize));\n                    });\n                    _this.totals[key] = total;\n\n                    if (oldTotalsToDispose != null) {\n                      oldTotalsToDispose.dispose();\n                    }\n                  }\n                };\n\n                for (key in logs) {\n                  _loop(key);\n                }\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function onBatchEnd(_x22, _x23) {\n        return _onBatchEnd3.apply(this, arguments);\n      }\n\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(epoch, logs) {\n        var _this2 = this;\n\n        var _iterator9, _step9, _loop2, _ret;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!(logs != null)) {\n                  _context15.next = 19;\n                  break;\n                }\n\n                _iterator9 = _createForOfIteratorHelper(this.params['metrics']);\n                _context15.prev = 2;\n\n                _loop2 = function _loop2() {\n                  var key = _step9.value;\n\n                  if (_this2.totals[key] == null) {\n                    return \"continue\";\n                  }\n\n                  if (typeof _this2.totals[key] === 'number') {\n                    logs[key] = _this2.totals[key] / _this2.seen;\n                  } else {\n                    tidy(function () {\n                      var log = mul(div(1, _this2.seen), _this2.totals[key]);\n                      logs[key] = log;\n\n                      _this2.totals[key].dispose();\n\n                      keep(logs[key]);\n                    });\n                  }\n                };\n\n                _iterator9.s();\n\n              case 5:\n                if ((_step9 = _iterator9.n()).done) {\n                  _context15.next = 11;\n                  break;\n                }\n\n                _ret = _loop2();\n\n                if (!(_ret === \"continue\")) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                return _context15.abrupt(\"continue\", 9);\n\n              case 9:\n                _context15.next = 5;\n                break;\n\n              case 11:\n                _context15.next = 16;\n                break;\n\n              case 13:\n                _context15.prev = 13;\n                _context15.t0 = _context15[\"catch\"](2);\n\n                _iterator9.e(_context15.t0);\n\n              case 16:\n                _context15.prev = 16;\n\n                _iterator9.f();\n\n                return _context15.finish(16);\n\n              case 19:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[2, 13, 16, 19]]);\n      }));\n\n      function onEpochEnd(_x24, _x25) {\n        return _onEpochEnd3.apply(this, arguments);\n      }\n\n      return onEpochEnd;\n    }()\n  }]);\n\n  return BaseLogger;\n}(BaseCallback);\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\n\nexport var History = /*#__PURE__*/function (_BaseCallback2) {\n  _inherits(History, _BaseCallback2);\n\n  var _super2 = _createSuper(History);\n\n  function History() {\n    _classCallCheck(this, History);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(History, [{\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(logs) {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                this.epoch = [];\n                this.history = {};\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function onTrainBegin(_x26) {\n        return _onTrainBegin3.apply(this, arguments);\n      }\n\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(epoch, logs) {\n        var key;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (logs == null) {\n                  logs = {};\n                }\n\n                this.epoch.push(epoch);\n\n                for (key in logs) {\n                  if (this.history[key] == null) {\n                    this.history[key] = [];\n                  }\n\n                  this.history[key].push(logs[key]);\n                }\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function onEpochEnd(_x27, _x28) {\n        return _onEpochEnd4.apply(this, arguments);\n      }\n\n      return onEpochEnd;\n    }()\n    /**\n     * Await the values of all losses and metrics.\n     */\n\n  }, {\n    key: \"syncData\",\n    value: function () {\n      var _syncData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var promises, keys, indices, key, valueArray, i, valueScalar, values, n, tensorToDispose;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                promises = [];\n                keys = [];\n                indices = [];\n\n                for (key in this.history) {\n                  valueArray = this.history[key];\n\n                  for (i = 0; i < valueArray.length; ++i) {\n                    if (typeof valueArray[i] !== 'number') {\n                      valueScalar = valueArray[i];\n                      promises.push(valueScalar.data());\n                      keys.push(key);\n                      indices.push(i);\n                    }\n                  }\n                }\n\n                _context18.next = 6;\n                return Promise.all(promises);\n\n              case 6:\n                values = _context18.sent;\n\n                for (n = 0; n < values.length; ++n) {\n                  tensorToDispose = this.history[keys[n]][indices[n]];\n                  tensorToDispose.dispose();\n                  this.history[keys[n]][indices[n]] = values[n][0];\n                }\n\n              case 8:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function syncData() {\n        return _syncData.apply(this, arguments);\n      }\n\n      return syncData;\n    }()\n  }]);\n\n  return History;\n}(BaseCallback);\n/**\n * Custom callback for training.\n */\n\nexport var CustomCallback = /*#__PURE__*/function (_BaseCallback3) {\n  _inherits(CustomCallback, _BaseCallback3);\n\n  var _super3 = _createSuper(CustomCallback);\n\n  function CustomCallback(args, yieldEvery) {\n    var _this3;\n\n    _classCallCheck(this, CustomCallback);\n\n    _this3 = _super3.call(this);\n    _this3.currentEpoch = 0;\n    _this3.yieldEvery = yieldEvery || 'auto';\n\n    if (_this3.yieldEvery === 'auto') {\n      _this3.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n\n    if (_this3.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n\n    if (util.isNumber(_this3.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      _this3.maybeWait = generic_utils.debounce(_this3.maybeWait.bind(_assertThisInitialized(_this3)), _this3.yieldEvery);\n    }\n\n    _this3.trainBegin = args.onTrainBegin;\n    _this3.trainEnd = args.onTrainEnd;\n    _this3.epochBegin = args.onEpochBegin;\n    _this3.epochEnd = args.onEpochEnd;\n    _this3.batchBegin = args.onBatchBegin;\n    _this3.batchEnd = args.onBatchEnd;\n    _this3.yield = args.onYield;\n    return _this3;\n  }\n\n  _createClass(CustomCallback, [{\n    key: \"maybeWait\",\n    value: function () {\n      var _maybeWait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(epoch, batch, logs) {\n        var ps;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                ps = [];\n\n                if (!(this.yield != null)) {\n                  _context19.next = 5;\n                  break;\n                }\n\n                _context19.next = 4;\n                return resolveScalarsInLogs(logs);\n\n              case 4:\n                ps.push(this.yield(epoch, batch, logs));\n\n              case 5:\n                ps.push(nextFrame());\n                _context19.next = 8;\n                return Promise.all(ps);\n\n              case 8:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function maybeWait(_x29, _x30, _x31) {\n        return _maybeWait.apply(this, arguments);\n      }\n\n      return maybeWait;\n    }()\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(epoch, logs) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                this.currentEpoch = epoch;\n\n                if (!(this.epochBegin != null)) {\n                  _context20.next = 6;\n                  break;\n                }\n\n                _context20.next = 4;\n                return resolveScalarsInLogs(logs);\n\n              case 4:\n                _context20.next = 6;\n                return this.epochBegin(epoch, logs);\n\n              case 6:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function onEpochBegin(_x32, _x33) {\n        return _onEpochBegin4.apply(this, arguments);\n      }\n\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(epoch, logs) {\n        var ps;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                ps = [];\n\n                if (!(this.epochEnd != null)) {\n                  _context21.next = 5;\n                  break;\n                }\n\n                _context21.next = 4;\n                return resolveScalarsInLogs(logs);\n\n              case 4:\n                ps.push(this.epochEnd(epoch, logs));\n\n              case 5:\n                if (this.yieldEvery === 'epoch') {\n                  ps.push(nextFrame());\n                }\n\n                _context21.next = 8;\n                return Promise.all(ps);\n\n              case 8:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function onEpochEnd(_x34, _x35) {\n        return _onEpochEnd5.apply(this, arguments);\n      }\n\n      return onEpochEnd;\n    }()\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(batch, logs) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (!(this.batchBegin != null)) {\n                  _context22.next = 5;\n                  break;\n                }\n\n                _context22.next = 3;\n                return resolveScalarsInLogs(logs);\n\n              case 3:\n                _context22.next = 5;\n                return this.batchBegin(batch, logs);\n\n              case 5:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function onBatchBegin(_x36, _x37) {\n        return _onBatchBegin3.apply(this, arguments);\n      }\n\n      return onBatchBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(batch, logs) {\n        var ps;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                ps = [];\n\n                if (!(this.batchEnd != null)) {\n                  _context23.next = 5;\n                  break;\n                }\n\n                _context23.next = 4;\n                return resolveScalarsInLogs(logs);\n\n              case 4:\n                ps.push(this.batchEnd(batch, logs));\n\n              case 5:\n                if (this.yieldEvery === 'batch') {\n                  ps.push(nextFrame());\n                } else if (util.isNumber(this.yieldEvery)) {\n                  ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n                }\n\n                _context23.next = 8;\n                return Promise.all(ps);\n\n              case 8:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function onBatchEnd(_x38, _x39) {\n        return _onBatchEnd4.apply(this, arguments);\n      }\n\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(logs) {\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (!(this.trainBegin != null)) {\n                  _context24.next = 5;\n                  break;\n                }\n\n                _context24.next = 3;\n                return resolveScalarsInLogs(logs);\n\n              case 3:\n                _context24.next = 5;\n                return this.trainBegin(logs);\n\n              case 5:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function onTrainBegin(_x40) {\n        return _onTrainBegin4.apply(this, arguments);\n      }\n\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(logs) {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (!(this.trainEnd != null)) {\n                  _context25.next = 5;\n                  break;\n                }\n\n                _context25.next = 3;\n                return resolveScalarsInLogs(logs);\n\n              case 3:\n                _context25.next = 5;\n                return this.trainEnd(logs);\n\n              case 5:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function onTrainEnd(_x41) {\n        return _onTrainEnd3.apply(this, arguments);\n      }\n\n      return onTrainEnd;\n    }()\n  }]);\n\n  return CustomCallback;\n}(BaseCallback);\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\n\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  } // Convert custom callback configs to custom callback objects.\n\n\n  var callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(function (callbackConfig) {\n    return new CustomCallback(callbackConfig, yieldEvery);\n  });\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\n\nexport var CallbackConstructorRegistry = /*#__PURE__*/function () {\n  /**\n   * Blocks public access to constructor.\n   */\n  function CallbackConstructorRegistry() {\n    _classCallCheck(this, CallbackConstructorRegistry);\n  }\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n\n\n  _createClass(CallbackConstructorRegistry, null, [{\n    key: \"registerCallbackConstructor\",\n    value: function registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n      util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), function () {\n        return \"Verbosity level is expected to be an integer >= 0, \" + \"but got \".concat(verbosityLevel);\n      });\n      CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n\n      if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n        CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n      }\n\n      CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n  }, {\n    key: \"checkForDuplicate\",\n    value: function checkForDuplicate(callbackConstructor) {\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var constructors = CallbackConstructorRegistry.constructors[+levelName];\n        constructors.forEach(function (ctor) {\n          if (ctor === callbackConstructor) {\n            throw new ValueError('Duplicate callback constructor.');\n          }\n        });\n      }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n\n  }, {\n    key: \"createCallbacks\",\n    value: function createCallbacks(verbosityLevel) {\n      var constructors = [];\n\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var level = +levelName;\n\n        if (verbosityLevel >= level) {\n          constructors.push.apply(constructors, _toConsumableArray(CallbackConstructorRegistry.constructors[level]));\n        }\n      }\n\n      return constructors.map(function (ctor) {\n        return new ctor();\n      });\n    }\n  }]);\n\n  return CallbackConstructorRegistry;\n}();\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  var history = new History();\n  var actualCallbacks = [new BaseLogger()].concat(_toConsumableArray(CallbackConstructorRegistry.createCallbacks(verbose)));\n\n  if (callbacks != null) {\n    actualCallbacks.push.apply(actualCallbacks, _toConsumableArray(callbacks));\n  }\n\n  actualCallbacks.push(history);\n  var callbackList = new CallbackList(actualCallbacks); // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs: epochs,\n    initialEpoch: initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize: batchSize,\n    verbose: verbose,\n    doValidation: doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList: callbackList,\n    history: history\n  };\n}","map":{"version":3,"sources":["../src/base_callbacks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(nextFrame());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(nextFrame());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(nextFrame());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n//# sourceMappingURL=base_callbacks.js.map"]},"metadata":{},"sourceType":"module"}