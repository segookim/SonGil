{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      y = inputs.y,\n      dy = inputs.dy;\n  var depthRadius = attrs.depthRadius,\n      bias = attrs.bias,\n      alpha = attrs.alpha,\n      beta = attrs.beta;\n  assertNotComplex(dy, 'LRNGrad');\n  var dySize = util.sizeFromShape(dy.shape);\n  var channels = dy.shape[3];\n  var dyValues = backend.data.get(dy.dataId).values;\n  var xValues = backend.data.get(x.dataId).values;\n  var yValues = backend.data.get(y.dataId).values;\n  var result = new Float32Array(dySize);\n  var size = dySize;\n\n  for (var offset = 0; offset < size; offset++) {\n    var currentChannel = offset % channels;\n    var depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    var depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    var norm = 0;\n\n    for (var k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n\n    norm = alpha * norm + bias;\n\n    for (var _k = depthBegin; _k < depthEnd; _k++) {\n      var dyi = -2 * alpha * beta * xValues[_k] * yValues[offset] / norm;\n\n      if (offset === _k) {\n        dyi += Math.pow(norm, -beta);\n      }\n\n      dyi *= dyValues[offset];\n      result[_k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport var lRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":{"version":3,"sources":["../../src/kernels/LRNGrad.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, y, dy } = inputs;\n    const { depthRadius, bias, alpha, beta } = attrs;\n    assertNotComplex(dy, 'LRNGrad');\n    const dySize = util.sizeFromShape(dy.shape);\n    const channels = dy.shape[3];\n    const dyValues = backend.data.get(dy.dataId).values;\n    const xValues = backend.data.get(x.dataId).values;\n    const yValues = backend.data.get(y.dataId).values;\n    const result = new Float32Array(dySize);\n    const size = dySize;\n    for (let offset = 0; offset < size; offset++) {\n        const currentChannel = offset % channels;\n        const depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n        const depthEnd = (offset - currentChannel) +\n            Math.min(channels, currentChannel + depthRadius + 1);\n        let norm = 0;\n        for (let k = depthBegin; k < depthEnd; k++) {\n            norm += Math.pow(xValues[k], 2);\n        }\n        norm = alpha * norm + bias;\n        for (let k = depthBegin; k < depthEnd; k++) {\n            let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n            if (offset === k) {\n                dyi += Math.pow(norm, -beta);\n            }\n            dyi *= dyValues[offset];\n            result[k] += dyi;\n        }\n    }\n    return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport const lRNGradConfig = {\n    kernelName: LRNGrad,\n    backendName: 'cpu',\n    kernelFunc: lRNGrad\n};\n//# sourceMappingURL=LRNGrad.js.map"]},"metadata":{},"sourceType":"module"}