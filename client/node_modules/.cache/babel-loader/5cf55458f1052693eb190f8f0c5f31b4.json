{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad) {\n  var dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NHWC';\n  var dilations = arguments.length > 5 ? arguments[5] : undefined;\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  var inputChannels = inputShape[3];\n  var $filterShape = [].concat(_toConsumableArray(filterShape), [inputChannels]);\n  var $dataFormat = convertConv2DDataFormat(dataFormat);\n  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null\n  /* roundingMode */\n  , null\n  /* depthWise */\n  , $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n\n  var _parseTupleParam = parseTupleParam(filterSize),\n      _parseTupleParam2 = _slicedToArray(_parseTupleParam, 2),\n      filterHeight = _parseTupleParam2[0],\n      filterWidth = _parseTupleParam2[1];\n\n  var filterShape;\n\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\n\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'NDHWC';\n\n  var _parse3TupleParam = parse3TupleParam(filterSize),\n      _parse3TupleParam2 = _slicedToArray(_parse3TupleParam, 3),\n      filterDepth = _parse3TupleParam2[0],\n      filterHeight = _parse3TupleParam2[1],\n      filterWidth = _parse3TupleParam2[2];\n\n  var filterShape;\n  var $dataFormat;\n\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\n\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode) {\n  var depthwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var dataFormat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'channelsLast';\n  var batchSize = -1,\n      inHeight = -1,\n      inWidth = -1,\n      inChannels = -1;\n\n  if (dataFormat === 'channelsLast') {\n    var _inShape = _slicedToArray(inShape, 4);\n\n    batchSize = _inShape[0];\n    inHeight = _inShape[1];\n    inWidth = _inShape[2];\n    inChannels = _inShape[3];\n  } else if (dataFormat === 'channelsFirst') {\n    var _inShape2 = _slicedToArray(inShape, 4);\n\n    batchSize = _inShape2[0];\n    inChannels = _inShape2[1];\n    inHeight = _inShape2[2];\n    inWidth = _inShape2[3];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  var _filterShape = _slicedToArray(filterShape, 4),\n      filterHeight = _filterShape[0],\n      filterWidth = _filterShape[1],\n      filterChannels = _filterShape[3];\n\n  var _parseTupleParam3 = parseTupleParam(strides),\n      _parseTupleParam4 = _slicedToArray(_parseTupleParam3, 2),\n      strideHeight = _parseTupleParam4[0],\n      strideWidth = _parseTupleParam4[1];\n\n  var _parseTupleParam5 = parseTupleParam(dilations),\n      _parseTupleParam6 = _slicedToArray(_parseTupleParam5, 2),\n      dilationHeight = _parseTupleParam6[0],\n      dilationWidth = _parseTupleParam6[1];\n\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n\n  var _getPadAndOutInfo = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat),\n      padInfo = _getPadAndOutInfo.padInfo,\n      outHeight = _getPadAndOutInfo.outHeight,\n      outWidth = _getPadAndOutInfo.outWidth;\n\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    effectiveFilterHeight: effectiveFilterHeight,\n    effectiveFilterWidth: effectiveFilterWidth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\n\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad) {\n  var depthwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n  var roundingMode = arguments.length > 7 ? arguments[7] : undefined;\n  var batchSize = -1,\n      inDepth = -1,\n      inHeight = -1,\n      inWidth = -1,\n      inChannels = -1;\n\n  if (dataFormat === 'channelsLast') {\n    var _inShape3 = _slicedToArray(inShape, 5);\n\n    batchSize = _inShape3[0];\n    inDepth = _inShape3[1];\n    inHeight = _inShape3[2];\n    inWidth = _inShape3[3];\n    inChannels = _inShape3[4];\n  } else if (dataFormat === 'channelsFirst') {\n    var _inShape4 = _slicedToArray(inShape, 5);\n\n    batchSize = _inShape4[0];\n    inChannels = _inShape4[1];\n    inDepth = _inShape4[2];\n    inHeight = _inShape4[3];\n    inWidth = _inShape4[4];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n\n  var _filterShape2 = _slicedToArray(filterShape, 5),\n      filterDepth = _filterShape2[0],\n      filterHeight = _filterShape2[1],\n      filterWidth = _filterShape2[2],\n      filterChannels = _filterShape2[4];\n\n  var _parse3TupleParam3 = parse3TupleParam(strides),\n      _parse3TupleParam4 = _slicedToArray(_parse3TupleParam3, 3),\n      strideDepth = _parse3TupleParam4[0],\n      strideHeight = _parse3TupleParam4[1],\n      strideWidth = _parse3TupleParam4[2];\n\n  var _parse3TupleParam5 = parse3TupleParam(dilations),\n      _parse3TupleParam6 = _slicedToArray(_parse3TupleParam5, 3),\n      dilationDepth = _parse3TupleParam6[0],\n      dilationHeight = _parse3TupleParam6[1],\n      dilationWidth = _parse3TupleParam6[2];\n\n  var effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n\n  var _get3DPadAndOutInfo = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode),\n      padInfo = _get3DPadAndOutInfo.padInfo,\n      outDepth = _get3DPadAndOutInfo.outDepth,\n      outHeight = _get3DPadAndOutInfo.outHeight,\n      outWidth = _get3DPadAndOutInfo.outWidth;\n\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inDepth: inDepth,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outDepth: outDepth,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideDepth: strideDepth,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterDepth: filterDepth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    effectiveFilterDepth: effectiveFilterDepth,\n    effectiveFilterHeight: effectiveFilterHeight,\n    effectiveFilterWidth: effectiveFilterWidth,\n    dilationDepth: dilationDepth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\n\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  var inputRows = inShape[0];\n  var inputCols = inShape[1];\n  var outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  var outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  var inputDepth = inShape[0];\n  var inputRows = inShape[1];\n  var inputCols = inShape[2];\n  var outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  var outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  var outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputDepths, outputRows, outputCols, outChannels];\n}\n\nexport function computeDefaultPad(inputShape, fieldSize, stride) {\n  var dilation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param) {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n\n  return param;\n}\n\nfunction parse3TupleParam(param) {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\n\n\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n  var padInfo;\n  var outHeight;\n  var outWidth;\n\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    var padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    var top = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    var _top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n\n    var _bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n\n    var _left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n\n    var _right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n\n    var _padType = _top === 0 && _bottom === 0 && _left === 0 && _right === 0 ? 'VALID' : 'EXPLICIT';\n\n    padInfo = {\n      top: _top,\n      bottom: _bottom,\n      left: _left,\n      right: _right,\n      type: _padType\n    };\n    outHeight = round((inHeight - filterHeight + _top + _bottom) / strideHeight + 1, roundingMode);\n    outWidth = round((inWidth - filterWidth + _left + _right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(\"Unknown padding parameter: \".concat(pad));\n  }\n\n  return {\n    padInfo: padInfo,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\n\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n  var padInfo;\n  var outDepth;\n  var outHeight;\n  var outWidth;\n\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    var front = Math.floor(padAlongDepth / 2);\n    var back = padAlongDepth - front;\n    var top = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      front: front,\n      back: back,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      front: 0,\n      back: 0,\n      type: 'VALID'\n    };\n    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(\"Unknown padding parameter: \".concat(pad));\n  }\n\n  return {\n    padInfo: padInfo,\n    outDepth: outDepth,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\n\n\nfunction round(value, roundingMode) {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n\n    case 'floor':\n      return Math.floor(value);\n\n    default:\n      throw new Error(\"Unknown roundingMode \".concat(roundingMode));\n  }\n}\n\nexport function tupleValuesAreOne(param) {\n  var _parseTupleParam7 = parseTupleParam(param),\n      _parseTupleParam8 = _slicedToArray(_parseTupleParam7, 3),\n      dimA = _parseTupleParam8[0],\n      dimB = _parseTupleParam8[1],\n      dimC = _parseTupleParam8[2];\n\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\n\nexport function convertConv2DDataFormat(dataFormat) {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n}","map":{"version":3,"sources":["../../src/ops/conv_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = 'NHWC', dilations) {\n    // `computerConv2DInfo` require filterShape to be in the dimension of:\n    // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n    // outDepth, it should have the same depth as the input.\n    // Input shape: [batch, height, width, inChannels]\n    const inputChannels = inputShape[3];\n    const $filterShape = [...filterShape, inputChannels];\n    const $dataFormat = convertConv2DDataFormat(dataFormat);\n    return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {\n    const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n    let filterShape;\n    if (dataFormat === 'channelsLast') {\n        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n    }\n    else if (dataFormat === 'channelsFirst') {\n        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'NDHWC') {\n    const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n    let filterShape;\n    let $dataFormat;\n    if (dataFormat === 'NDHWC') {\n        $dataFormat = 'channelsLast';\n        filterShape =\n            [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n    }\n    else if (dataFormat === 'NCDHW') {\n        $dataFormat = 'channelsFirst';\n        filterShape =\n            [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {\n    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n    if (dataFormat === 'channelsLast') {\n        [batchSize, inHeight, inWidth, inChannels] = inShape;\n    }\n    else if (dataFormat === 'channelsFirst') {\n        [batchSize, inChannels, inHeight, inWidth] = inShape;\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    const [filterHeight, filterWidth, , filterChannels] = filterShape;\n    const [strideHeight, strideWidth] = parseTupleParam(strides);\n    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);\n    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n    let outShape;\n    if (dataFormat === 'channelsFirst') {\n        outShape = [batchSize, outChannels, outHeight, outWidth];\n    }\n    else if (dataFormat === 'channelsLast') {\n        outShape = [batchSize, outHeight, outWidth, outChannels];\n    }\n    return {\n        batchSize,\n        dataFormat,\n        inHeight,\n        inWidth,\n        inChannels,\n        outHeight,\n        outWidth,\n        outChannels,\n        padInfo,\n        strideHeight,\n        strideWidth,\n        filterHeight,\n        filterWidth,\n        effectiveFilterHeight,\n        effectiveFilterWidth,\n        dilationHeight,\n        dilationWidth,\n        inShape,\n        outShape,\n        filterShape\n    };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = 'channelsLast', roundingMode) {\n    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];\n    if (dataFormat === 'channelsLast') {\n        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n    }\n    else if (dataFormat === 'channelsFirst') {\n        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;\n    const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n    const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);\n    const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n    const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);\n    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n    let outShape;\n    if (dataFormat === 'channelsFirst') {\n        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n    }\n    else if (dataFormat === 'channelsLast') {\n        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n    }\n    return {\n        batchSize,\n        dataFormat,\n        inDepth,\n        inHeight,\n        inWidth,\n        inChannels,\n        outDepth,\n        outHeight,\n        outWidth,\n        outChannels,\n        padInfo,\n        strideDepth,\n        strideHeight,\n        strideWidth,\n        filterDepth,\n        filterHeight,\n        filterWidth,\n        effectiveFilterDepth,\n        effectiveFilterHeight,\n        effectiveFilterWidth,\n        dilationDepth,\n        dilationHeight,\n        dilationWidth,\n        inShape,\n        outShape,\n        filterShape\n    };\n}\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    const inputRows = inShape[0];\n    const inputCols = inShape[1];\n    const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    return [outputRows, outputCols];\n}\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    const inputDepth = inShape[0];\n    const inputRows = inShape[1];\n    const inputCols = inShape[2];\n    const outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    return [outputDepths, outputRows, outputCols, outChannels];\n}\nexport function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {\n    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\nfunction parseTupleParam(param) {\n    if (typeof param === 'number') {\n        return [param, param, param];\n    }\n    if (param.length === 2) {\n        return [param[0], param[1], 1];\n    }\n    return param;\n}\nfunction parse3TupleParam(param) {\n    return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize, dilation) {\n    if (dilation <= 1) {\n        return filterSize;\n    }\n    return filterSize + (filterSize - 1) * (dilation - 1);\n}\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n    let padInfo;\n    let outHeight;\n    let outWidth;\n    if (typeof pad === 'number') {\n        const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };\n        const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n        outHeight = outShape[0];\n        outWidth = outShape[1];\n    }\n    else if (pad === 'same') {\n        outHeight = Math.ceil(inHeight / strideHeight);\n        outWidth = Math.ceil(inWidth / strideWidth);\n        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n        const top = Math.floor(padAlongHeight / 2);\n        const bottom = padAlongHeight - top;\n        const left = Math.floor(padAlongWidth / 2);\n        const right = padAlongWidth - left;\n        padInfo = { top, bottom, left, right, type: 'SAME' };\n    }\n    else if (pad === 'valid') {\n        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };\n        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n    }\n    else if (typeof pad === 'object') {\n        const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n        const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n        const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n        const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n        const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n            'VALID' :\n            'EXPLICIT';\n        padInfo = { top, bottom, left, right, type: padType };\n        outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);\n        outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n    }\n    else {\n        throw Error(`Unknown padding parameter: ${pad}`);\n    }\n    return { padInfo, outHeight, outWidth };\n}\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n    let padInfo;\n    let outDepth;\n    let outHeight;\n    let outWidth;\n    if (typeof pad === 'number') {\n        const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n        padInfo = {\n            top: pad,\n            bottom: pad,\n            left: pad,\n            right: pad,\n            front: pad,\n            back: pad,\n            type: padType\n        };\n        const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n        outDepth = outShape[0];\n        outHeight = outShape[1];\n        outWidth = outShape[2];\n    }\n    else if (pad === 'same') {\n        outDepth = Math.ceil(inDepth / strideDepth);\n        outHeight = Math.ceil(inHeight / strideHeight);\n        outWidth = Math.ceil(inWidth / strideWidth);\n        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n        const front = Math.floor(padAlongDepth / 2);\n        const back = padAlongDepth - front;\n        const top = Math.floor(padAlongHeight / 2);\n        const bottom = padAlongHeight - top;\n        const left = Math.floor(padAlongWidth / 2);\n        const right = padAlongWidth - left;\n        padInfo = { top, bottom, left, right, front, back, type: 'SAME' };\n    }\n    else if (pad === 'valid') {\n        padInfo = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            front: 0,\n            back: 0,\n            type: 'VALID'\n        };\n        outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n    }\n    else {\n        throw Error(`Unknown padding parameter: ${pad}`);\n    }\n    return { padInfo, outDepth, outHeight, outWidth };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value, roundingMode) {\n    if (!roundingMode) {\n        return Math.trunc(value);\n    }\n    switch (roundingMode) {\n        case 'round':\n            // used for Caffe Conv\n            return Math.round(value);\n        case 'ceil':\n            // used for Caffe Pool\n            return Math.ceil(value);\n        case 'floor':\n            return Math.floor(value);\n        default:\n            throw new Error(`Unknown roundingMode ${roundingMode}`);\n    }\n}\nexport function tupleValuesAreOne(param) {\n    const [dimA, dimB, dimC] = parseTupleParam(param);\n    return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat) {\n    if (dataFormat === 'NHWC') {\n        return 'channelsLast';\n    }\n    else if (dataFormat === 'NCHW') {\n        return 'channelsFirst';\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n}\n//# sourceMappingURL=conv_util.js.map"]},"metadata":{},"sourceType":"module"}