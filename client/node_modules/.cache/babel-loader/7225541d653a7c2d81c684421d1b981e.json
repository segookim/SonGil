{"ast":null,"code":"import _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { getCoordsDataType } from './shader_compiler';\nexport var CumSumProgram = /*#__PURE__*/function () {\n  function CumSumProgram(shape, exclusive, reverse) {\n    _classCallCheck(this, CumSumProgram);\n\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n    var rank = shape.length;\n    var val = exclusive ? '0.0' : \"getX(\".concat(getCoords(rank, 'coords'), \")\");\n    var length = shape[shape.length - 1];\n    var condition = '';\n    var idxString = ''; // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n\n    if (exclusive) {\n      condition = reverse ? \"end != \".concat(length - 1) : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? \"end + pow2 < \".concat(length) : 'end >= pow2';\n      idxString = reverse ? 'end + pow2' : 'end - pow2';\n    }\n\n    this.userCode = \"\\n      uniform float index;\\n      void main() {\\n        \".concat(getCoordsDataType(rank), \" coords = getOutputCoords();\\n        int end = \").concat(getFinalCoord(rank, 'coords'), \";\\n        float val = \").concat(val, \";\\n        int pow2 = int(pow(2.0, index));\\n        if (\").concat(condition, \") {\\n          int idx = \").concat(idxString, \";\\n          \").concat(getFinalCoord(rank, 'coords'), \" = idx;\\n          val += getX(\").concat(getCoords(rank, 'coords'), \");\\n        }\\n        setOutput(val);\\n      }\\n    \");\n  }\n\n  _createClass(CumSumProgram, [{\n    key: \"getCustomSetupFunc\",\n    value: function getCustomSetupFunc(index) {\n      var _this = this;\n\n      return function (gpgpu, webGLProgram) {\n        if (_this.index == null) {\n          _this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n        }\n\n        gpgpu.gl.uniform1f(_this.index, index);\n      };\n    }\n  }]);\n\n  return CumSumProgram;\n}();\n\nfunction getCoords(rank, name) {\n  if (rank === 1) {\n    return \"\".concat(name);\n  } else if (rank === 2) {\n    return \"\".concat(name, \".x, \").concat(name, \".y\");\n  } else if (rank === 3) {\n    return \"\".concat(name, \".x, \").concat(name, \".y, \").concat(name, \".z\");\n  } else if (rank === 4) {\n    return \"\".concat(name, \".x, \").concat(name, \".y, \").concat(name, \".z, \").concat(name, \".w\");\n  } else {\n    throw Error(\"Cumulative sum for rank \".concat(rank, \" is not yet supported\"));\n  }\n}\n\nfunction getFinalCoord(rank, name) {\n  if (rank === 1) {\n    return \"\".concat(name);\n  } else if (rank === 2) {\n    return \"\".concat(name, \".y\");\n  } else if (rank === 3) {\n    return \"\".concat(name, \".z\");\n  } else if (rank === 4) {\n    return \"\".concat(name, \".w\");\n  } else {\n    throw Error(\"Cumulative sum for rank \".concat(rank, \" is not yet supported\"));\n  }\n}","map":{"version":3,"sources":["../src/cumsum_gpu.ts"],"names":[],"mappings":";;AAkBA,SAAQ,iBAAR,QAAgC,mBAAhC;AAEA,WAAa,aAAb;AAQE,yBAAY,KAAZ,EAA6B,SAA7B,EAAiD,OAAjD,EAAiE;AAAA;;AAPjE,SAAA,aAAA,GAAgB,CAAC,GAAD,CAAhB;AAQE,SAAK,WAAL,GAAmB,KAAnB;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,MAAnB;AACA,QAAM,GAAG,GAAG,SAAS,GAAG,KAAH,kBAAmB,SAAS,CAAC,IAAD,EAAO,QAAP,CAA5B,MAArB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAApB;AACA,QAAI,SAAS,GAAG,EAAhB;AACA,QAAI,SAAS,GAAG,EAAhB,CAN+D,CAO/D;AACA;AACA;;AACA,QAAI,SAAJ,EAAe;AACb,MAAA,SAAS,GAAG,OAAO,oBAAa,MAAM,GAAG,CAAtB,IAA4B,UAA/C;AACA,MAAA,SAAS,GAAG,OAAO,GAAG,SAAH,GAAe,SAAlC;AACD,KAHD,MAGO;AACL,MAAA,SAAS,GAAG,OAAO,0BAAmB,MAAnB,IAA8B,aAAjD;AACA,MAAA,SAAS,GAAI,OAAO,GAAG,YAAH,GAAkB,YAAtC;AACD;;AAED,SAAK,QAAL,wEAGM,iBAAiB,CAAC,IAAD,CAHvB,6DAIgB,aAAa,CAAC,IAAD,EAAO,QAAP,CAJ7B,oCAKkB,GALlB,sEAOU,SAPV,sCAQkB,SARlB,0BASQ,aAAa,CAAC,IAAD,EAAO,QAAP,CATrB,4CAUoB,SAAS,CAAC,IAAD,EAAO,QAAP,CAV7B;AAeD;;AAzCH;AAAA;AAAA,WA2CE,4BAAmB,KAAnB,EAAgC;AAAA;;AAC9B,aAAO,UAAC,KAAD,EAAsB,YAAtB,EAAoD;AACzD,YAAI,KAAI,CAAC,KAAL,IAAc,IAAlB,EAAwB;AACtB,UAAA,KAAI,CAAC,KAAL,GAAa,KAAK,CAAC,kBAAN,CAAyB,YAAzB,EAAuC,OAAvC,CAAb;AACD;;AACD,QAAA,KAAK,CAAC,EAAN,CAAS,SAAT,CAAmB,KAAI,CAAC,KAAxB,EAA+B,KAA/B;AACD,OALD;AAMD;AAlDH;;AAAA;AAAA;;AAqDA,SAAS,SAAT,CAAmB,IAAnB,EAAiC,IAAjC,EAA6C;AAC3C,MAAI,IAAI,KAAK,CAAb,EAAgB;AACd,qBAAU,IAAV;AACD,GAFD,MAEO,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,qBAAU,IAAV,iBAAqB,IAArB;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,qBAAU,IAAV,iBAAqB,IAArB,iBAAgC,IAAhC;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,qBAAU,IAAV,iBAAqB,IAArB,iBAAgC,IAAhC,iBAA2C,IAA3C;AACD,GAFM,MAEA;AACL,UAAM,KAAK,mCAA4B,IAA5B,2BAAX;AACD;AACF;;AAED,SAAS,aAAT,CAAuB,IAAvB,EAAqC,IAArC,EAAiD;AAC/C,MAAI,IAAI,KAAK,CAAb,EAAgB;AACd,qBAAU,IAAV;AACD,GAFD,MAEO,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,qBAAU,IAAV;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,qBAAU,IAAV;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,qBAAU,IAAV;AACD,GAFM,MAEA;AACL,UAAM,KAAK,mCAA4B,IAA5B,2BAAX;AACD;AACF","sourceRoot":"","sourcesContent":["import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n    constructor(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        const rank = shape.length;\n        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n        const length = shape[shape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n    getCustomSetupFunc(index) {\n        return (gpgpu, webGLProgram) => {\n            if (this.index == null) {\n                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(this.index, index);\n        };\n    }\n}\nfunction getCoords(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=cumsum_gpu.js.map"]},"metadata":{},"sourceType":"module"}