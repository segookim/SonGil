{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n  constructor(gl) {\n    this.outputTexture = null;\n    this.program = null;\n    this.disposed = false;\n    this.vertexAttrsAreBound = false;\n    this.itemsToPoll = [];\n    const glVersion = env().getNumber('WEBGL_VERSION');\n\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    } // WebGL 2.0 enables texture floats without an extension.\n\n\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n      this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support half float textures, yet the ' + 'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support color renderable half floats, yet ' + 'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    this.textureConfig = tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  get debug() {\n    return env().getBool('DEBUG');\n  }\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n\n    if (this.program != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' + ' This is probably a resource leak, delete the program with ' + 'GPGPUContext.deleteProgram before disposing.');\n    }\n\n    if (this.outputTexture != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound output matrix ' + 'texture.  This is probably a resource leak, delete the output ' + 'matrix texture with GPGPUContext.deleteMatrixTexture before ' + 'disposing.');\n    }\n\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  createFloat32MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createFloat16MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createUnsignedBytesMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  uploadPixelDataToTexture(texture, pixels) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  uploadDenseMatrixToTexture(texture, width, height, data) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  createFloat16PackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createPackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  deleteMatrixTexture(texture) {\n    this.throwIfDisposed();\n\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n  }\n\n  downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n  }\n\n  downloadFloat32MatrixFromBuffer(buffer, size) {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  createBufferFromTexture(texture, rows, columns) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  createAndWaitForFence() {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  createFence(gl) {\n    let query;\n    let isFencePassed;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl;\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n\n      isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {\n      query,\n      isFencePassed\n    };\n  }\n\n  downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n  }\n\n  createProgram(fragmentShaderSource) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n    const vertexShader = gpgpu_util.createVertexShader(gl);\n    const program = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n    }\n\n    return program;\n  }\n\n  deleteProgram(program) {\n    this.throwIfDisposed();\n\n    if (program === this.program) {\n      this.program = null;\n    }\n\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  setProgram(program) {\n    this.throwIfDisposed();\n    this.program = program;\n\n    if (this.program != null && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  getUniformLocation(program, uniformName, shouldThrow = true) {\n    this.throwIfDisposed();\n\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n    }\n  }\n\n  getAttributeLocation(program, attribute) {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  getUniformLocationNoThrow(program, uniformName) {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n    this.throwIfDisposed();\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n  }\n\n  setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n\n    if (this.debug) {\n      this.debugValidate();\n    }\n\n    webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  getQueryTimerExtension() {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');\n    }\n\n    return this.disjointQueryTimerExtension;\n  }\n\n  getQueryTimerExtensionWebGL2() {\n    return this.getQueryTimerExtension();\n  }\n\n  getQueryTimerExtensionWebGL1() {\n    return this.getQueryTimerExtension();\n  }\n\n  beginQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT();\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  async waitForQueryAndGetTime(query) {\n    await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n    // in rapid succession, so without this check we\n    // may poll for the query timer indefinitely\n    this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  getQueryTime(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT); // Return milliseconds.\n\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT); // Return milliseconds.\n\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  isQueryAvailable(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext) {\n    return new Promise(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  pollItems() {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n\n    for (let i = 0; i <= index; ++i) {\n      const {\n        resolveFn\n      } = this.itemsToPoll[i];\n      resolveFn();\n    }\n\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  addItemToPoll(isDoneFn, resolveFn) {\n    this.itemsToPoll.push({\n      isDoneFn,\n      resolveFn\n    });\n\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    } // Start a new loop that polls.\n\n\n    util.repeatedTry(() => {\n      this.pollItems(); // End the loop if no more items to poll.\n\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  bindTextureToFrameBuffer(texture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  downloadMatrixDriver(texture, downloadAndDecode) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  setOutputMatrixWriteRegionDriver(x, y, width, height) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\n\nexport function linearSearchLastTrue(arr) {\n  let i = 0;\n\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n\n    if (!isDone) {\n      break;\n    }\n  }\n\n  return i - 1;\n}","map":{"version":3,"sources":["../src/gpgpu_context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n    constructor(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.vertexAttrsAreBound = false;\n        this.itemsToPoll = [];\n        const glVersion = env().getNumber('WEBGL_VERSION');\n        if (gl != null) {\n            this.gl = gl;\n            setWebGLContext(glVersion, gl);\n        }\n        else {\n            this.gl = getWebGLContext(glVersion);\n        }\n        // WebGL 2.0 enables texture floats without an extension.\n        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (env().getNumber('WEBGL_VERSION') === 1) {\n            const TEXTURE_FLOAT = 'OES_texture_float';\n            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n            this.textureFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n            if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n                this.textureHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support half float textures, yet the ' +\n                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support color renderable half floats, yet ' +\n                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n        }\n        else {\n            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n                this.colorBufferFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            }\n            else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            }\n            else {\n                throw new Error('GL context does not support color renderable floats');\n            }\n        }\n        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n        this.framebuffer = webgl_util.createFramebuffer(this.gl);\n        this.textureConfig =\n            tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n    }\n    get debug() {\n        return env().getBool('DEBUG');\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        const gl = this.gl;\n        webgl_util.callAndCheck(gl, () => gl.finish());\n        webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n        this.disposed = true;\n    }\n    createFloat32MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createFloat16MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createUnsignedBytesMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    uploadPixelDataToTexture(texture, pixels) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n    uploadDenseMatrixToTexture(texture, width, height, data) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n    createFloat16PackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createPackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    deleteMatrixTexture(texture) {\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n    }\n    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n    }\n    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n        return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n    downloadFloat32MatrixFromBuffer(buffer, size) {\n        return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n    createBufferFromTexture(texture, rows, columns) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    createAndWaitForFence() {\n        const fenceContext = this.createFence(this.gl);\n        return this.pollFence(fenceContext);\n    }\n    createFence(gl) {\n        let query;\n        let isFencePassed;\n        if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n            const gl2 = gl;\n            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n            isFencePassed = () => {\n                const status = gl2.clientWaitSync(sync, 0, 0);\n                return status === gl2.ALREADY_SIGNALED ||\n                    status === gl2.CONDITION_SATISFIED;\n            };\n            query = sync;\n        }\n        else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n            query = this.beginQuery();\n            this.endQuery();\n            isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        }\n        else {\n            // If we have no way to fence, return true immediately. This will fire in\n            // WebGL 1.0 when there is no disjoint query timer. In this case, because\n            // the fence passes immediately, we'll immediately ask for a download of\n            // the texture, which will cause the UI thread to hang.\n            isFencePassed = () => true;\n        }\n        return { query, isFencePassed };\n    }\n    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n    }\n    createProgram(fragmentShaderSource) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n        const vertexShader = gpgpu_util.createVertexShader(gl);\n        const program = webgl_util.createProgram(gl);\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n        webgl_util.linkProgram(gl, program);\n        if (this.debug) {\n            webgl_util.validateProgram(gl, program);\n        }\n        if (!this.vertexAttrsAreBound) {\n            this.setProgram(program);\n            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n        }\n        return program;\n    }\n    deleteProgram(program) {\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n        }\n    }\n    setProgram(program) {\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.debug) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n    }\n    getUniformLocation(program, uniformName, shouldThrow = true) {\n        this.throwIfDisposed();\n        if (shouldThrow) {\n            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n        }\n        else {\n            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n        }\n    }\n    getAttributeLocation(program, attribute) {\n        this.throwIfDisposed();\n        return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n    }\n    getUniformLocationNoThrow(program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    }\n    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n    debugValidate() {\n        if (this.program != null) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.validateFramebuffer(this.gl);\n    }\n    executeProgram() {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        const gl = this.gl;\n        if (this.debug) {\n            this.debugValidate();\n        }\n        webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n    }\n    blockUntilAllProgramsCompleted() {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n    }\n    getQueryTimerExtension() {\n        if (this.disjointQueryTimerExtension == null) {\n            this.disjointQueryTimerExtension =\n                webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                    'EXT_disjoint_timer_query_webgl2' :\n                    'EXT_disjoint_timer_query');\n        }\n        return this.disjointQueryTimerExtension;\n    }\n    getQueryTimerExtensionWebGL2() {\n        return this.getQueryTimerExtension();\n    }\n    getQueryTimerExtensionWebGL1() {\n        return this.getQueryTimerExtension();\n    }\n    beginQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const query = gl2.createQuery();\n            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n            return query;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        const query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        return query;\n    }\n    endQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            gl2.endQuery(ext.TIME_ELAPSED_EXT);\n            return;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n    async waitForQueryAndGetTime(query) {\n        await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n            // in rapid succession, so without this check we\n            // may poll for the query timer indefinitely\n            this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n        return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    }\n    getQueryTime(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return null;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n    }\n    isQueryAvailable(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return true;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n    }\n    pollFence(fenceContext) {\n        return new Promise(resolve => {\n            this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n        });\n    }\n    pollItems() {\n        // Find the last query that has finished.\n        const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n        for (let i = 0; i <= index; ++i) {\n            const { resolveFn } = this.itemsToPoll[i];\n            resolveFn();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n    addItemToPoll(isDoneFn, resolveFn) {\n        this.itemsToPoll.push({ isDoneFn, resolveFn });\n        if (this.itemsToPoll.length > 1) {\n            // We already have a running loop that polls.\n            return;\n        }\n        // Start a new loop that polls.\n        util.repeatedTry(() => {\n            this.pollItems();\n            // End the loop if no more items to poll.\n            return this.itemsToPoll.length === 0;\n        });\n    }\n    bindTextureToFrameBuffer(texture) {\n        this.throwIfDisposed();\n        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(this.gl);\n        }\n    }\n    unbindTextureToFrameBuffer() {\n        if (this.outputTexture != null) {\n            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.debug) {\n                webgl_util.validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n    }\n    downloadMatrixDriver(texture, downloadAndDecode) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = downloadAndDecode();\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n        webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n    }\n    setOutputMatrixWriteRegionDriver(x, y, width, height) {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n    }\n    throwIfDisposed() {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    }\n    throwIfNoProgram() {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    }\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr) {\n    let i = 0;\n    for (; i < arr.length; ++i) {\n        const isDone = arr[i]();\n        if (!isDone) {\n            break;\n        }\n    }\n    return i - 1;\n}\n//# sourceMappingURL=gpgpu_context.js.map"]},"metadata":{},"sourceType":"module"}