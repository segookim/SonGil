{"ast":null,"code":"import { convertToTensor } from '../../tensor_util_env';\nimport { cast } from '../cast';\nimport { div } from '../div';\nimport { Reduction } from '../loss_ops_utils';\nimport { mean } from '../mean';\nimport { mul } from '../mul';\nimport { notEqual } from '../not_equal';\nimport { ones } from '../ones';\nimport { op } from '../operation';\nimport { scalar } from '../scalar';\nimport { sum } from '../sum';\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\n\nfunction computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights = null;\n\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss;\n  }\n\n  if (reduction === Reduction.SUM) {\n    return sum(weightedLoss);\n  }\n\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return mean(weightedLoss);\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = div(sum(weightedLoss), sum($weights));\n      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;\n    }\n  }\n\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return div(sum(weightedLoss), scalar($losses.size));\n    } else {\n      const broadcastedWeights = mul($weights, ones($losses.shape));\n      const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n      return div(sum(weightedLoss), numNonZeros);\n    }\n  }\n\n  throw Error(`Unknown reduction: ${reduction}`);\n}\n\nexport const computeWeightedLoss = op({\n  computeWeightedLoss_\n});","map":{"version":3,"sources":["../../../src/ops/losses/compute_weighted_loss.ts"],"names":[],"mappings":"AAiBA,SAAQ,eAAR,QAA8B,uBAA9B;AAGA,SAAQ,IAAR,QAAmB,SAAnB;AACA,SAAQ,GAAR,QAAkB,QAAlB;AACA,SAAQ,SAAR,QAAwB,mBAAxB;AACA,SAAQ,IAAR,QAAmB,SAAnB;AACA,SAAQ,GAAR,QAAkB,QAAlB;AACA,SAAQ,QAAR,QAAuB,cAAvB;AACA,SAAQ,IAAR,QAAmB,SAAnB;AACA,SAAQ,EAAR,QAAiB,cAAjB;AACA,SAAQ,MAAR,QAAqB,WAArB;AACA,SAAQ,GAAR,QAAkB,QAAlB;AAEA;;;;;;;;;;AAUG;;AACH,SAAS,oBAAT,CACI,MADJ,EAC0B,OAD1B,EAEI,SAAS,GAAG,SAAS,CAAC,sBAF1B,EAEgD;AAC9C,QAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,qBAAnB,CAA/B;AACA,MAAI,QAAQ,GAAW,IAAvB;;AACA,MAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,IAAA,QAAQ,GAAG,eAAe,CAAC,OAAD,EAAU,SAAV,EAAqB,qBAArB,CAA1B;AACD;;AAED,QAAM,YAAY,GAAI,QAAQ,IAAI,IAAb,GAAqB,OAArB,GAA+B,GAAG,CAAC,OAAD,EAAU,QAAV,CAAvD;;AAEA,MAAI,SAAS,KAAK,SAAS,CAAC,IAA5B,EAAkC;AAChC,WAAO,YAAP;AACD;;AACD,MAAI,SAAS,KAAK,SAAS,CAAC,GAA5B,EAAiC;AAC/B,WAAO,GAAG,CAAC,YAAD,CAAV;AACD;;AACD,MAAI,SAAS,KAAK,SAAS,CAAC,IAA5B,EAAkC;AAChC,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,IAAI,CAAC,YAAD,CAAX;AACD,KAFD,MAEO;AACL,YAAM,eAAe,GAAG,OAAO,CAAC,IAAR,GAAe,QAAQ,CAAC,IAAhD;AACA,YAAM,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,YAAD,CAAJ,EAAoB,GAAG,CAAC,QAAD,CAAvB,CAAlB;AACA,aAAO,eAAe,GAAG,CAAlB,GAAsB,GAAG,CAAC,MAAD,EAAS,MAAM,CAAC,eAAD,CAAf,CAAzB,GACsB,MAD7B;AAED;AACF;;AACD,MAAI,SAAS,KAAK,SAAS,CAAC,sBAA5B,EAAoD;AAClD,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,GAAG,CAAC,GAAG,CAAC,YAAD,CAAJ,EAAoB,MAAM,CAAC,OAAO,CAAC,IAAT,CAA1B,CAAV;AACD,KAFD,MAEO;AACL,YAAM,kBAAkB,GAAG,GAAG,CAAC,QAAD,EAAW,IAAI,CAAC,OAAO,CAAC,KAAT,CAAf,CAA9B;AAEA,YAAM,WAAW,GACb,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,kBAAD,EAAqB,MAAM,CAAC,CAAD,CAA3B,CAAT,CAAJ,EAA+C,SAA/C,CADR;AAEA,aAAO,GAAG,CAAC,GAAG,CAAC,YAAD,CAAJ,EAAoB,WAApB,CAAV;AACD;AACF;;AAED,QAAM,KAAK,CAAC,sBAAsB,SAAS,EAAhC,CAAX;AACD;;AACD,OAAO,MAAM,mBAAmB,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAA9B","sourceRoot":"","sourcesContent":["import { convertToTensor } from '../../tensor_util_env';\nimport { cast } from '../cast';\nimport { div } from '../div';\nimport { Reduction } from '../loss_ops_utils';\nimport { mean } from '../mean';\nimport { mul } from '../mul';\nimport { notEqual } from '../not_equal';\nimport { ones } from '../ones';\nimport { op } from '../operation';\nimport { scalar } from '../scalar';\nimport { sum } from '../sum';\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n    let $weights = null;\n    if (weights != null) {\n        $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n    }\n    const weightedLoss = ($weights == null) ? $losses : mul($losses, $weights);\n    if (reduction === Reduction.NONE) {\n        return weightedLoss;\n    }\n    if (reduction === Reduction.SUM) {\n        return sum(weightedLoss);\n    }\n    if (reduction === Reduction.MEAN) {\n        if ($weights == null) {\n            return mean(weightedLoss);\n        }\n        else {\n            const broadcastFactor = $losses.size / $weights.size;\n            const result = div(sum(weightedLoss), sum($weights));\n            return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) :\n                result;\n        }\n    }\n    if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n        if ($weights == null) {\n            return div(sum(weightedLoss), scalar($losses.size));\n        }\n        else {\n            const broadcastedWeights = mul($weights, ones($losses.shape));\n            const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n            return div(sum(weightedLoss), numNonZeros);\n        }\n    }\n    throw Error(`Unknown reduction: ${reduction}`);\n}\nexport const computeWeightedLoss = op({ computeWeightedLoss_ });\n//# sourceMappingURL=compute_weighted_loss.js.map"]},"metadata":{},"sourceType":"module"}