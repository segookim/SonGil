{"ast":null,"code":"import _regeneratorRuntime from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\n\nexport var WebcamIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(WebcamIterator, _LazyIterator);\n\n  var _super = _createSuper(WebcamIterator);\n\n  function WebcamIterator(webcamVideoElement, webcamConfig) {\n    var _this;\n\n    _classCallCheck(this, WebcamIterator);\n\n    _this = _super.call(this);\n    _this.webcamVideoElement = webcamVideoElement;\n    _this.webcamConfig = webcamConfig;\n    _this.isClosed = true;\n    _this.resize = false;\n\n    if (_this.needToResize()) {\n      _this.resize = true;\n      _this.cropSize = [_this.webcamConfig.resizeHeight, _this.webcamConfig.resizeWidth];\n      _this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (_this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        var widthCroppingRatio = _this.webcamConfig.resizeWidth * 1.0 / _this.webcamVideoElement.width;\n        var heightCroppingRatio = _this.webcamConfig.resizeHeight * 1.0 / _this.webcamVideoElement.height;\n        var widthCropStart = (1 - widthCroppingRatio) / 2;\n        var heightCropStart = (1 - heightCroppingRatio) / 2;\n        var widthCropEnd = widthCropStart + widthCroppingRatio;\n        var heightCropEnd = heightCroppingRatio + heightCropStart;\n        _this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        _this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(WebcamIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"webcam\";\n    } // Construct a WebcamIterator and start it's video stream.\n\n  }, {\n    key: \"start\",\n    value: // Async function to start video stream.\n    function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.webcamConfig.facingMode) {\n                  util.assert(this.webcamConfig.facingMode === 'user' || this.webcamConfig.facingMode === 'environment', function () {\n                    return \"Invalid webcam facing mode: \".concat(_this2.webcamConfig.facingMode, \". \") + \"Please provide 'user' or 'environment'\";\n                  });\n                }\n\n                _context.prev = 1;\n                _context.next = 4;\n                return navigator.mediaDevices.getUserMedia({\n                  video: {\n                    deviceId: this.webcamConfig.deviceId,\n                    facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : 'user',\n                    width: this.webcamVideoElement.width,\n                    height: this.webcamVideoElement.height\n                  }\n                });\n\n              case 4:\n                this.stream = _context.sent;\n                _context.next = 11;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](1);\n                // Modify the error message but leave the stack trace intact\n                _context.t0.message = \"Error thrown while initializing video stream: \".concat(_context.t0.message);\n                throw _context.t0;\n\n              case 11:\n                if (this.stream) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new Error('Could not obtain video from webcam.');\n\n              case 13:\n                // Older browsers may not have srcObject\n                try {\n                  this.webcamVideoElement.srcObject = this.stream;\n                } catch (error) {\n                  console.log(error);\n                  this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n                } // Start the webcam video stream\n\n\n                this.webcamVideoElement.play();\n                this.isClosed = false;\n                return _context.abrupt(\"return\", new Promise(function (resolve) {\n                  // Add event listener to make sure the webcam has been fully initialized.\n                  _this2.webcamVideoElement.onloadedmetadata = function () {\n                    resolve();\n                  };\n                }));\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 7]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var img;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.isClosed) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 2:\n                _context2.prev = 2;\n                img = browser.fromPixels(this.webcamVideoElement);\n                _context2.next = 9;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](2);\n                throw new Error(\"Error thrown converting video to pixels: \".concat(JSON.stringify(_context2.t0)));\n\n              case 9:\n                if (!this.resize) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                _context2.prev = 10;\n                return _context2.abrupt(\"return\", {\n                  value: this.cropAndResizeFrame(img),\n                  done: false\n                });\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t1 = _context2[\"catch\"](10);\n                throw new Error(\"Error thrown cropping the video: \".concat(_context2.t1.message));\n\n              case 17:\n                _context2.prev = 17;\n                img.dispose();\n                return _context2.finish(17);\n\n              case 20:\n                _context2.next = 23;\n                break;\n\n              case 22:\n                return _context2.abrupt(\"return\", {\n                  value: img,\n                  done: false\n                });\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 6], [10, 14, 17, 20]]);\n      }));\n\n      function next() {\n        return _next.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"needToResize\",\n    value: function needToResize() {\n      // If resizeWidth and resizeHeight are provided, and different from the\n      // width and height of original HTMLVideoElement, then resizing and cropping\n      // is required.\n      if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n        return true;\n      }\n\n      return false;\n    } // Cropping and resizing each frame based on config\n\n  }, {\n    key: \"cropAndResizeFrame\",\n    value: function cropAndResizeFrame(img) {\n      var _this3 = this;\n\n      return tidy(function () {\n        var expandedImage = expandDims(cast(img, 'float32'), 0);\n        var resizedImage;\n        resizedImage = image.cropAndResize(expandedImage, _this3.cropBox, _this3.cropBoxInd, _this3.cropSize, 'bilinear'); // Extract image from batch cropping.\n\n        var shape = resizedImage.shape;\n        return reshape(resizedImage, shape.slice(1));\n      });\n    } // Capture one frame from the video stream, and extract the value from\n    // iterator.next() result.\n\n  }, {\n    key: \"capture\",\n    value: function () {\n      var _capture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.next();\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent.value);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function capture() {\n        return _capture.apply(this, arguments);\n      }\n\n      return capture;\n    }() // Stop the video stream and pause webcam iterator.\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var tracks = this.stream.getTracks();\n      tracks.forEach(function (track) {\n        return track.stop();\n      });\n\n      try {\n        this.webcamVideoElement.srcObject = null;\n      } catch (error) {\n        console.log(error);\n        this.webcamVideoElement.src = null;\n      }\n\n      this.isClosed = true;\n    } // Override toArray() function to prevent collecting.\n\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      throw new Error('Can not convert infinite video stream to array.');\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(webcamVideoElement) {\n        var webcamConfig,\n            webcamIterator,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                webcamConfig = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n\n                if (!env().get('IS_NODE')) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error('tf.data.webcam is only supported in browser environment.');\n\n              case 3:\n                if (webcamVideoElement) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                // If webcam video element is not provided, create a hidden video element\n                // with provided width and height.\n                webcamVideoElement = document.createElement('video');\n\n                if (!(!webcamConfig.resizeWidth || !webcamConfig.resizeHeight)) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n\n              case 7:\n                webcamVideoElement.width = webcamConfig.resizeWidth;\n                webcamVideoElement.height = webcamConfig.resizeHeight;\n\n              case 9:\n                webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig); // Call async function to initialize the video stream.\n\n                _context4.next = 12;\n                return webcamIterator.start();\n\n              case 12:\n                return _context4.abrupt(\"return\", webcamIterator);\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function create(_x) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return WebcamIterator;\n}(LazyIterator);","map":{"version":3,"sources":["../../src/iterators/webcam_iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator {\n    constructor(webcamVideoElement, webcamConfig) {\n        super();\n        this.webcamVideoElement = webcamVideoElement;\n        this.webcamConfig = webcamConfig;\n        this.isClosed = true;\n        this.resize = false;\n        if (this.needToResize()) {\n            this.resize = true;\n            this.cropSize =\n                [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n            this.cropBoxInd = tensor1d([0], 'int32');\n            if (this.webcamConfig.centerCrop) {\n                // Calculate the box based on resizing shape.\n                const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n                const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n                    this.webcamVideoElement.height;\n                const widthCropStart = (1 - widthCroppingRatio) / 2;\n                const heightCropStart = (1 - heightCroppingRatio) / 2;\n                const widthCropEnd = widthCropStart + widthCroppingRatio;\n                const heightCropEnd = heightCroppingRatio + heightCropStart;\n                this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n            }\n            else {\n                this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n            }\n        }\n    }\n    summary() {\n        return `webcam`;\n    }\n    // Construct a WebcamIterator and start it's video stream.\n    static async create(webcamVideoElement, webcamConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('tf.data.webcam is only supported in browser environment.');\n        }\n        if (!webcamVideoElement) {\n            // If webcam video element is not provided, create a hidden video element\n            // with provided width and height.\n            webcamVideoElement = document.createElement('video');\n            if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n                throw new Error('Please provide webcam video element, or resizeWidth and ' +\n                    'resizeHeight to create a hidden video element.');\n            }\n            webcamVideoElement.width = webcamConfig.resizeWidth;\n            webcamVideoElement.height = webcamConfig.resizeHeight;\n        }\n        const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n        // Call async function to initialize the video stream.\n        await webcamIterator.start();\n        return webcamIterator;\n    }\n    // Async function to start video stream.\n    async start() {\n        if (this.webcamConfig.facingMode) {\n            util.assert((this.webcamConfig.facingMode === 'user') ||\n                (this.webcamConfig.facingMode === 'environment'), () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n                `Please provide 'user' or 'environment'`);\n        }\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    deviceId: this.webcamConfig.deviceId,\n                    facingMode: this.webcamConfig.facingMode ?\n                        this.webcamConfig.facingMode :\n                        'user',\n                    width: this.webcamVideoElement.width,\n                    height: this.webcamVideoElement.height\n                }\n            });\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message = `Error thrown while initializing video stream: ${e.message}`;\n            throw e;\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain video from webcam.');\n        }\n        // Older browsers may not have srcObject\n        try {\n            this.webcamVideoElement.srcObject = this.stream;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n        }\n        // Start the webcam video stream\n        this.webcamVideoElement.play();\n        this.isClosed = false;\n        return new Promise(resolve => {\n            // Add event listener to make sure the webcam has been fully initialized.\n            this.webcamVideoElement.onloadedmetadata = () => {\n                resolve();\n            };\n        });\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let img;\n        try {\n            img = browser.fromPixels(this.webcamVideoElement);\n        }\n        catch (e) {\n            throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n        }\n        if (this.resize) {\n            try {\n                return { value: this.cropAndResizeFrame(img), done: false };\n            }\n            catch (e) {\n                throw new Error(`Error thrown cropping the video: ${e.message}`);\n            }\n            finally {\n                img.dispose();\n            }\n        }\n        else {\n            return { value: img, done: false };\n        }\n    }\n    needToResize() {\n        // If resizeWidth and resizeHeight are provided, and different from the\n        // width and height of original HTMLVideoElement, then resizing and cropping\n        // is required.\n        if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n            (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n                this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n            return true;\n        }\n        return false;\n    }\n    // Cropping and resizing each frame based on config\n    cropAndResizeFrame(img) {\n        return tidy(() => {\n            const expandedImage = expandDims(cast(img, 'float32'), (0));\n            let resizedImage;\n            resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear');\n            // Extract image from batch cropping.\n            const shape = resizedImage.shape;\n            return reshape(resizedImage, shape.slice(1));\n        });\n    }\n    // Capture one frame from the video stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    // Stop the video stream and pause webcam iterator.\n    stop() {\n        const tracks = this.stream.getTracks();\n        tracks.forEach(track => track.stop());\n        try {\n            this.webcamVideoElement.srcObject = null;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = null;\n        }\n        this.isClosed = true;\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite video stream to array.');\n    }\n}\n//# sourceMappingURL=webcam_iterator.js.map"]},"metadata":{},"sourceType":"module"}