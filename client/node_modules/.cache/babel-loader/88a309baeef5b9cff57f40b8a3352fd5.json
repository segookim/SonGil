{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { BatchMatMul, buffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nexport function batchMatMul(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var a = inputs.a,\n      b = inputs.b;\n  var transposeA = attrs.transposeA,\n      transposeB = attrs.transposeB;\n  assertNotComplex([a, b], 'matMul');\n  var aRank = a.shape.length;\n  var bRank = b.shape.length;\n  var innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  var innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n  var outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  var outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n  var outerDimsA = a.shape.slice(0, -2);\n  var outerDimsB = b.shape.slice(0, -2);\n  var batchDimA = util.sizeFromShape(outerDimsA);\n  var batchDimB = util.sizeFromShape(outerDimsB);\n  var batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n  util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, function () {\n    return \"Error in matMul: the input batch dimensions must either be the \" + \"same or at least one input batch dimension must be 1. Got input \" + \"batch dimensions of (\".concat(outerDimsA, \") and (\").concat(outerDimsB, \").\");\n  });\n  var outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n  var outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n  util.assert(innerShapeA === innerShapeB, function () {\n    return \"Error in matMul: inner shapes (\".concat(innerShapeA, \") and (\") + \"\".concat(innerShapeB, \") of Tensors with shapes \").concat(a.shape, \" and \") + \"\".concat(b.shape, \" and transposeA=\").concat(transposeA) + \" and transposeB=\".concat(transposeB, \" must match.\");\n  });\n  var a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];\n  var b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB]; // The rest of the implementation is designed to operate on rank-3 tensors\n\n  var a3d = reshape({\n    inputs: {\n      x: a\n    },\n    backend: backend,\n    attrs: {\n      shape: a3dShape\n    }\n  });\n  var b3d = reshape({\n    inputs: {\n      x: b\n    },\n    backend: backend,\n    attrs: {\n      shape: b3dShape\n    }\n  });\n  var sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  var leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  var rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  var batchDim = Math.max(batchDimA, batchDimB);\n  var a3dValues = backend.data.get(a3d.dataId).values;\n  var b3dValues = backend.data.get(b3d.dataId).values;\n  var a3dStrides = util.computeStrides(a3d.shape);\n  var b3dStrides = util.computeStrides(b3d.shape);\n\n  var _ref = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1],\n      _ref2 = _slicedToArray(_ref, 3),\n      aBatch = _ref2[0],\n      aOuterStep = _ref2[1],\n      aInnerStep = _ref2[2];\n\n  var _ref3 = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]],\n      _ref4 = _slicedToArray(_ref3, 3),\n      bInnerStep = _ref4[0],\n      bOuterStep = _ref4[1],\n      bBatch = _ref4[2];\n\n  var size = leftDim * rightDim;\n  var result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n  var resVals = result.values;\n  var blockSize = backend.blockSize;\n\n  for (var bi = 0; bi < batchDim; bi++) {\n    for (var i0 = 0; i0 < leftDim; i0 += blockSize) {\n      for (var j0 = 0; j0 < rightDim; j0 += blockSize) {\n        for (var k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          // for when blockSize doesn't evenly divide the input\n          var iBlock = Math.min(i0 + blockSize, leftDim);\n          var jBlock = Math.min(j0 + blockSize, rightDim);\n          var kBlock = Math.min(k0 + blockSize, sharedDim);\n\n          for (var i = i0; i < iBlock; i++) {\n            for (var j = j0; j < jBlock; j++) {\n              var sum = 0.0;\n\n              for (var k = k0; k < kBlock; k++) {\n                var batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;\n                var batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;\n                var aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];\n                var bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];\n                sum += aVal * bVal;\n              }\n\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d); // set correct shape on output.\n\n  return backend.makeTensorInfo(outShape, result.dtype, result.values);\n}\nexport var batchMatMulConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul\n};","map":{"version":3,"sources":["../../src/kernels/BatchMatMul.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { BatchMatMul, buffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nexport function batchMatMul(args) {\n    const { inputs, backend, attrs } = args;\n    const { a, b } = inputs;\n    const { transposeA, transposeB } = attrs;\n    assertNotComplex([a, b], 'matMul');\n    const aRank = a.shape.length;\n    const bRank = b.shape.length;\n    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n    const outerDimsA = a.shape.slice(0, -2);\n    const outerDimsB = b.shape.slice(0, -2);\n    const batchDimA = util.sizeFromShape(outerDimsA);\n    const batchDimB = util.sizeFromShape(outerDimsB);\n    const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n    util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the ` +\n        `same or at least one input batch dimension must be 1. Got input ` +\n        `batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);\n    const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n    util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n        `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n        `${b.shape} and transposeA=${transposeA}` +\n        ` and transposeB=${transposeB} must match.`);\n    const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] :\n        [batchDimA, outerShapeA, innerShapeA];\n    const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] :\n        [batchDimB, innerShapeB, outerShapeB];\n    // The rest of the implementation is designed to operate on rank-3 tensors\n    const a3d = reshape({ inputs: { x: a }, backend, attrs: { shape: a3dShape } });\n    const b3d = reshape({ inputs: { x: b }, backend, attrs: { shape: b3dShape } });\n    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n    const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n    const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n    const batchDim = Math.max(batchDimA, batchDimB);\n    const a3dValues = backend.data.get(a3d.dataId).values;\n    const b3dValues = backend.data.get(b3d.dataId).values;\n    const a3dStrides = util.computeStrides(a3d.shape);\n    const b3dStrides = util.computeStrides(b3d.shape);\n    const [aBatch, aOuterStep, aInnerStep] = transposeA ?\n        [a3dStrides[0], 1, a3dStrides[1]] :\n        [a3dStrides[0], a3dStrides[1], 1];\n    const [bInnerStep, bOuterStep, bBatch] = transposeB ?\n        [1, b3dStrides[1], b3dStrides[0]] :\n        [b3dStrides[1], 1, b3dStrides[0]];\n    const size = leftDim * rightDim;\n    const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n    const resVals = result.values;\n    const blockSize = backend.blockSize;\n    for (let bi = 0; bi < batchDim; bi++) {\n        for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n            for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n                for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n                    // for when blockSize doesn't evenly divide the input\n                    const iBlock = Math.min(i0 + blockSize, leftDim);\n                    const jBlock = Math.min(j0 + blockSize, rightDim);\n                    const kBlock = Math.min(k0 + blockSize, sharedDim);\n                    for (let i = i0; i < iBlock; i++) {\n                        for (let j = j0; j < jBlock; j++) {\n                            let sum = 0.0;\n                            for (let k = k0; k < kBlock; k++) {\n                                const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;\n                                const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;\n                                const aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];\n                                const bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];\n                                sum += aVal * bVal;\n                            }\n                            resVals[bi * size + (i * rightDim + j)] += sum;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    backend.disposeIntermediateTensorInfo(a3d);\n    backend.disposeIntermediateTensorInfo(b3d);\n    // set correct shape on output.\n    return backend.makeTensorInfo(outShape, result.dtype, result.values);\n}\nexport const batchMatMulConfig = {\n    kernelName: BatchMatMul,\n    backendName: 'cpu',\n    kernelFunc: batchMatMul,\n};\n//# sourceMappingURL=BatchMatMul.js.map"]},"metadata":{},"sourceType":"module"}