{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsConsistent(shapes, axis) {\n  const rank = shapes[0].length;\n  shapes.forEach((shape, i) => {\n    util.assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same ` + `as the rank of the rest (${rank})`);\n  });\n  util.assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);\n  const firstShape = shapes[0];\n  shapes.forEach((shape, i) => {\n    for (let r = 0; r < rank; r++) {\n      util.assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) ` + `does not match the shape of the rest (${firstShape}) ` + `along the non-concatenated axis ${i}.`);\n    }\n  });\n}\nexport function computeOutShape(shapes, axis) {\n  const outputShape = shapes[0].slice();\n\n  for (let i = 1; i < shapes.length; i++) {\n    outputShape[axis] += shapes[i][axis];\n  }\n\n  return outputShape;\n}","map":{"version":3,"sources":["../../src/ops/concat_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,OAAO,KAAK,IAAZ,MAAsB,SAAtB;AAEA,OAAM,SAAU,sBAAV,CAAiC,MAAjC,EAAqD,IAArD,EAAiE;AACrE,QAAM,IAAI,GAAG,MAAM,CAAC,CAAD,CAAN,CAAU,MAAvB;AACA,EAAA,MAAM,CAAC,OAAP,CAAe,CAAC,KAAD,EAAQ,CAAR,KAAa;AAC1B,IAAA,IAAI,CAAC,MAAL,CACI,KAAK,CAAC,MAAN,KAAiB,IADrB,EAEI,MACI,kBAAkB,IAAI,sBAAsB,CAAC,qBAA7C,GACA,4BAA4B,IAAI,GAJxC;AAKD,GAND;AAQA,EAAA,IAAI,CAAC,MAAL,CACI,IAAI,IAAI,CAAR,IAAa,IAAI,GAAG,IADxB,EAEI,MAAM,kBAAkB,IAAI,iCAAiC,IAAI,GAAG,CAAC,GAFzE;AAIA,QAAM,UAAU,GAAG,MAAM,CAAC,CAAD,CAAzB;AACA,EAAA,MAAM,CAAC,OAAP,CAAe,CAAC,KAAD,EAAQ,CAAR,KAAa;AAC1B,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAApB,EAA0B,CAAC,EAA3B,EAA+B;AAC7B,MAAA,IAAI,CAAC,MAAL,CACK,CAAC,KAAK,IAAP,IAAiB,KAAK,CAAC,CAAD,CAAL,KAAa,UAAU,CAAC,CAAD,CAD5C,EAEI,MAAM,kBAAkB,IAAI,uBAAuB,CAAC,MAAM,KAAK,IAAzD,GACF,yCAAyC,UAAU,IADjD,GAEF,mCAAmC,CAAC,GAJ5C;AAKD;AACF,GARD;AASD;AAED,OAAM,SAAU,eAAV,CAA0B,MAA1B,EAA8C,IAA9C,EAA0D;AAC9D,QAAM,WAAW,GAAG,MAAM,CAAC,CAAD,CAAN,CAAU,KAAV,EAApB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,IAAA,WAAW,CAAC,IAAD,CAAX,IAAqB,MAAM,CAAC,CAAD,CAAN,CAAU,IAAV,CAArB;AACD;;AACD,SAAO,WAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsConsistent(shapes, axis) {\n    const rank = shapes[0].length;\n    shapes.forEach((shape, i) => {\n        util.assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same ` +\n            `as the rank of the rest (${rank})`);\n    });\n    util.assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);\n    const firstShape = shapes[0];\n    shapes.forEach((shape, i) => {\n        for (let r = 0; r < rank; r++) {\n            util.assert((r === axis) || (shape[r] === firstShape[r]), () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) ` +\n                `does not match the shape of the rest (${firstShape}) ` +\n                `along the non-concatenated axis ${i}.`);\n        }\n    });\n}\nexport function computeOutShape(shapes, axis) {\n    const outputShape = shapes[0].slice();\n    for (let i = 1; i < shapes.length; i++) {\n        outputShape[axis] += shapes[i][axis];\n    }\n    return outputShape;\n}\n//# sourceMappingURL=concat_util.js.map"]},"metadata":{},"sourceType":"module"}