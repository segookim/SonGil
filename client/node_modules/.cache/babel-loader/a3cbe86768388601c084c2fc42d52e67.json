{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction rfft_(input, fftLength) {\n  assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let adjustedInput;\n\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  } // Complement the input with zero imaginary numbers.\n\n\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n  const ret = fft(complexInput); // Exclude complex conjugations. These conjugations are put symmetrically.\n\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n  const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport const rfft = op({\n  rfft_\n});","map":{"version":3,"sources":["../../../src/ops/spectral/rfft.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input, fftLength) {\n    assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n    let innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    let adjustedInput;\n    if (fftLength != null && fftLength < innerDimensionSize) {\n        // Need to crop\n        const begin = input.shape.map(v => 0);\n        const size = input.shape.map(v => v);\n        size[input.shape.length - 1] = fftLength;\n        adjustedInput = slice(input, begin, size);\n        innerDimensionSize = fftLength;\n    }\n    else if (fftLength != null && fftLength > innerDimensionSize) {\n        // Need to pad with zeros\n        const zerosShape = input.shape.map(v => v);\n        zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n        adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n        innerDimensionSize = fftLength;\n    }\n    else {\n        adjustedInput = input;\n    }\n    // Complement the input with zero imaginary numbers.\n    const zerosInput = zerosLike(adjustedInput);\n    const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n    const ret = fft(complexInput);\n    // Exclude complex conjugations. These conjugations are put symmetrically.\n    const half = Math.floor(innerDimensionSize / 2) + 1;\n    const realValues = real(ret);\n    const imagValues = imag(ret);\n    const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n    const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n    const outputShape = adjustedInput.shape.slice();\n    outputShape[adjustedInput.shape.length - 1] = half;\n    return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\nexport const rfft = op({ rfft_ });\n//# sourceMappingURL=rfft.js.map"]},"metadata":{},"sourceType":"module"}