{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n  constructor(shapes, axis) {\n    this.packedInputs = true;\n    this.packedOutput = true;\n    this.outputShape = [];\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n    const offsets = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n    let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1]; // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n\n      getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n    }\n\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n    this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n  }\n\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\n\nfunction shiftedChannels(channels, channel, shift) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}","map":{"version":3,"sources":["../src/concat_packed_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=concat_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}