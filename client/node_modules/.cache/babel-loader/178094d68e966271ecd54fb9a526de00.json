{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { CropAndResize } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by cropSize.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\n\nfunction cropAndResize_(image, boxes, boxInd, cropSize) {\n  var method = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'bilinear';\n  var extrapolationValue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var $image = convertToTensor(image, 'image', 'cropAndResize');\n  var $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  var $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  var numBoxes = $boxes.shape[0];\n  util.assert($image.rank === 4, function () {\n    return 'Error in cropAndResize: image must be rank 4,' + \"but got rank \".concat($image.rank, \".\");\n  });\n  util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, function () {\n    return \"Error in cropAndResize: boxes must be have size [\".concat(numBoxes, \",4] \") + \"but had shape \".concat($boxes.shape, \".\");\n  });\n  util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, function () {\n    return \"Error in cropAndResize: boxInd must be have size [\".concat(numBoxes, \"] \") + \"but had shape \".concat($boxes.shape, \".\");\n  });\n  util.assert(cropSize.length === 2, function () {\n    return \"Error in cropAndResize: cropSize must be of length 2, but got \" + \"length \".concat(cropSize.length, \".\");\n  });\n  util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, function () {\n    return \"cropSize must be atleast [1,1], but was \".concat(cropSize);\n  });\n  util.assert(method === 'bilinear' || method === 'nearest', function () {\n    return \"method must be bilinear or nearest, but was \".concat(method);\n  });\n  var inputs = {\n    image: $image,\n    boxes: $boxes,\n    boxInd: $boxInd\n  };\n  var attrs = {\n    method: method,\n    extrapolationValue: extrapolationValue,\n    cropSize: cropSize\n  };\n  var res = ENGINE.runKernel(CropAndResize, inputs, attrs);\n  return res;\n}\n\nexport var cropAndResize = op({\n  cropAndResize_: cropAndResize_\n});","map":{"version":3,"sources":["../../../src/ops/image/crop_and_resize.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAqB,cAArB;AACA,SAAQ,aAAR,QAAqE,oBAArE;AAIA,SAAQ,eAAR,QAA8B,uBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,YAAtB;AAEA,SAAQ,EAAR,QAAiB,cAAjB;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBG;;AACH,SAAS,cAAT,CACI,KADJ,EAEI,KAFJ,EAGI,MAHJ,EAII,QAJJ,EAM0B;AAAA,MADtB,MACsB,uEADS,UACT;AAAA,MAAtB,kBAAsB,uEAAD,CAAC;AAExB,MAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,CAA9B;AACA,MAAM,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,EAAkC,SAAlC,CAA9B;AACA,MAAM,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,eAAnB,EAAoC,OAApC,CAA/B;AAEA,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAjB;AAEA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CADpB,EAEI;AAAA,WAAM,yEACc,MAAM,CAAC,IADrB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,CAAC,IAAP,KAAgB,CAAhB,IAAqB,MAAM,CAAC,KAAP,CAAa,CAAb,MAAoB,CAD7C,EAEI;AAAA,WAAM,2DAAoD,QAApD,oCACe,MAAM,CAAC,KADtB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,CAAC,IAAR,KAAiB,CAAjB,IAAsB,OAAO,CAAC,KAAR,CAAc,CAAd,MAAqB,QAD/C,EAEI;AAAA,WAAM,4DAAqD,QAArD,kCACe,MAAM,CAAC,KADtB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,MAAT,KAAoB,CADxB,EAEI;AAAA,WAAM,oFACQ,QAAQ,CAAC,MADjB,MAAN;AAAA,GAFJ;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,QAAQ,CAAC,CAAD,CAAR,IAAe,CAAf,IAAoB,QAAQ,CAAC,CAAD,CAAR,IAAe,CADvC,EAEI;AAAA,6DAAiD,QAAjD;AAAA,GAFJ;AAGA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,KAAK,UAAX,IAAyB,MAAM,KAAK,SADxC,EAEI;AAAA,iEAAqD,MAArD;AAAA,GAFJ;AAIA,MAAM,MAAM,GACc;AAAC,IAAA,KAAK,EAAE,MAAR;AAAgB,IAAA,KAAK,EAAE,MAAvB;AAA+B,IAAA,MAAM,EAAE;AAAvC,GAD1B;AAEA,MAAM,KAAK,GAAuB;AAAC,IAAA,MAAM,EAAN,MAAD;AAAS,IAAA,kBAAkB,EAAlB,kBAAT;AAA6B,IAAA,QAAQ,EAAR;AAA7B,GAAlC;AACA,MAAM,GAAG,GAAG,MAAM,CAAC,SAAP,CACR,aADQ,EACO,MADP,EAER,KAFQ,CAAZ;AAGA,SAAO,GAAP;AACD;;AAED,OAAO,IAAM,aAAa,GAAG,EAAE,CAAC;AAAC,EAAA,cAAc,EAAd;AAAD,CAAD,CAAxB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { CropAndResize } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by cropSize.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method = 'bilinear', extrapolationValue = 0) {\n    const $image = convertToTensor(image, 'image', 'cropAndResize');\n    const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n    const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n    const numBoxes = $boxes.shape[0];\n    util.assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' +\n        `but got rank ${$image.rank}.`);\n    util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\n        `but had shape ${$boxes.shape}.`);\n    util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\n        `but had shape ${$boxes.shape}.`);\n    util.assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\n        `length ${cropSize.length}.`);\n    util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n    util.assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);\n    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };\n    const attrs = { method, extrapolationValue, cropSize };\n    const res = ENGINE.runKernel(CropAndResize, inputs, attrs);\n    return res;\n}\nexport const cropAndResize = op({ cropAndResize_ });\n//# sourceMappingURL=crop_and_resize.js.map"]},"metadata":{},"sourceType":"module"}