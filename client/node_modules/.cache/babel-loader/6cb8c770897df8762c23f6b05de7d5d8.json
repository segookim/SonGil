{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\n\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"sources":["../../src/ops/tensor_ops_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAqB,WAArB;AAIA,SAAQ,MAAR,EAAgB,kCAAhB,EAAoD,OAApD,EAA6D,UAA7D,EAAyE,YAAzE,EAAuF,aAAvF,EAAsG,YAAtG,QAAyH,SAAzH;AAEA;;AACA,OAAM,SAAU,UAAV,CACF,MADE,EACkB,KADlB,EACmC,aADnC,EAEF,KAFE,EAEc;AAClB,MAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,IAAA,KAAK,GAAG,UAAU,CAAC,MAAD,CAAlB;AACD;;AACD,MAAI,KAAK,KAAK,WAAd,EAA2B;AACzB,UAAM,IAAI,KAAJ,CACF,gDAAA,GACA,oCAFE,CAAN;AAGD;;AACD,MAAI,CAAC,YAAY,CAAC,MAAD,CAAb,IAAyB,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAA1B,IACA,OAAO,MAAP,KAAkB,QADlB,IAC8B,OAAO,MAAP,KAAkB,SADhD,IAEA,OAAO,MAAP,KAAkB,QAFtB,EAEgC;AAC9B,UAAM,IAAI,KAAJ,CACF,wEACA,uDAFE,CAAN;AAGD;;AACD,MAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,IAAA,kCAAkC,CAAC,KAAD,CAAlC;AAEA,UAAM,YAAY,GAAG,aAAa,CAAC,KAAD,CAAlC;AACA,UAAM,YAAY,GAAG,aAAa,CAAC,aAAD,CAAlC;AACA,IAAA,MAAM,CACF,YAAY,KAAK,YADf,EAEF,MACI,iCAAiC,KAAK,4BAAtC,GACA,GAAG,YAAY,mBAAmB,YAAY,EAJhD,CAAN;;AAMA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAAa,CAAC,MAAlC,EAA0C,EAAE,CAA5C,EAA+C;AAC7C,YAAM,QAAQ,GAAG,aAAa,CAAC,CAAD,CAA9B;AACA,YAAM,iBAAiB,GAAG,CAAC,KAAK,aAAa,CAAC,MAAd,GAAuB,CAA7B,GACtB,QAAQ,KAAK,aAAa,CAAC,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAD,CADJ,GAEtB,IAFJ;AAGA,MAAA,MAAM,CACF,aAAa,CAAC,CAAD,CAAb,KAAqB,KAAK,CAAC,CAAD,CAA1B,IAAiC,CAAC,iBADhC,EAEF,MAAM,8CAAA,GACF,IAAI,aAAa,gCADf,GAEF,UAAU,KAAK,KAJjB,CAAN;AAKD;AACF;;AAED,MAAI,CAAC,YAAY,CAAC,MAAD,CAAb,IAAyB,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAA9B,EAAqD;AACnD,IAAA,MAAM,GAAG,CAAC,MAAD,CAAT;AACD;;AAED,EAAA,KAAK,GAAG,KAAK,IAAI,aAAjB;AACA,EAAA,MAAM,GAAG,KAAK,KAAK,QAAV,GACL,YAAY,CAAC,MAAD,EAAS,KAAT,CADP,GAEL,OAAO,CAAC,MAAD,EAAqB,EAArB,EAAyB,IAAzB,CAFX;AAGA,SAAO,MAAM,CAAC,UAAP,CAAkB,MAAlB,EAAwC,KAAxC,EAA+C,KAA/C,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n    if (dtype == null) {\n        dtype = inferDtype(values);\n    }\n    if (dtype === 'complex64') {\n        throw new Error(`Cannot construct a complex64 tensor directly. ` +\n            `Please use tf.complex(real, imag).`);\n    }\n    if (!isTypedArray(values) && !Array.isArray(values) &&\n        typeof values !== 'number' && typeof values !== 'boolean' &&\n        typeof values !== 'string') {\n        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +\n            'an array of numbers/booleans/strings, or a TypedArray');\n    }\n    if (shape != null) {\n        assertNonNegativeIntegerDimensions(shape);\n        const providedSize = sizeFromShape(shape);\n        const inferredSize = sizeFromShape(inferredShape);\n        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n        for (let i = 0; i < inferredShape.length; ++i) {\n            const inferred = inferredShape[i];\n            const flatDimsDontMatch = i === inferredShape.length - 1 ?\n                inferred !== sizeFromShape(shape.slice(i)) :\n                true;\n            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +\n                `(${inferredShape}) does not match the provided ` +\n                `shape (${shape}). `);\n        }\n    }\n    if (!isTypedArray(values) && !Array.isArray(values)) {\n        values = [values];\n    }\n    shape = shape || inferredShape;\n    values = dtype !== 'string' ?\n        toTypedArray(values, dtype) :\n        flatten(values, [], true);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n//# sourceMappingURL=tensor_ops_util.js.map"]},"metadata":{},"sourceType":"module"}