{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport var TextureManager = /*#__PURE__*/function () {\n  function TextureManager(gpgpu) {\n    _classCallCheck(this, TextureManager);\n\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0; // How many bytes that have been allocated\n    // are available for reuse.\n\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n\n  _createClass(TextureManager, [{\n    key: \"acquireTexture\",\n    value: function acquireTexture(shapeRC, usage, isPacked) {\n      var physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n      var shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n\n      if (!(shapeKey in this.freeTextures)) {\n        this.freeTextures[shapeKey] = [];\n      }\n\n      if (!(shapeKey in this.usedTextures)) {\n        this.usedTextures[shapeKey] = [];\n      }\n\n      var texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n\n      if (this.freeTextures[shapeKey].length > 0) {\n        this.numFreeTextures--;\n        this.numUsedTextures++;\n        this._numBytesFree -= texBytes;\n        this.log();\n\n        var _newTexture = this.freeTextures[shapeKey].shift();\n\n        this.usedTextures[shapeKey].push(_newTexture);\n        return _newTexture;\n      }\n\n      var newTexture;\n\n      if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n        newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n        newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n        newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n        newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n        newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n      }\n\n      this.usedTextures[shapeKey].push(newTexture);\n      this.numUsedTextures++;\n      this._numBytesAllocated += texBytes;\n      this.log();\n      return newTexture;\n    }\n  }, {\n    key: \"releaseTexture\",\n    value: function releaseTexture(texture, shape, logicalTexType, isPacked) {\n      if (this.freeTextures == null) {\n        // Already disposed.\n        return;\n      }\n\n      var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n      var shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n\n      if (!(shapeKey in this.freeTextures)) {\n        this.freeTextures[shapeKey] = [];\n      }\n\n      var texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n      var deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n\n      if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n        this.gpgpu.deleteMatrixTexture(texture);\n        this._numBytesAllocated -= texBytes;\n      } else {\n        this.freeTextures[shapeKey].push(texture);\n        this.numFreeTextures++;\n        this._numBytesFree += texBytes;\n      }\n\n      this.numUsedTextures--;\n      var texList = this.usedTextures[shapeKey];\n      var texIndex = texList.indexOf(texture);\n\n      if (texIndex < 0) {\n        throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n      }\n\n      texList.splice(texIndex, 1);\n      this.log();\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (!this.logEnabled) {\n        return;\n      }\n\n      var total = this.numFreeTextures + this.numUsedTextures;\n      console.log('Free/Used', \"\".concat(this.numFreeTextures, \" / \").concat(this.numUsedTextures), \"(\".concat(total, \")\"));\n      var freeRatio = this._numBytesFree / this._numBytesAllocated;\n      console.log(\"Bytes allocated: \".concat(this._numBytesAllocated));\n      console.log(\"Bytes unused: \".concat(this._numBytesFree, \" (\").concat(Math.round(100 * freeRatio), \"%)\"));\n    }\n  }, {\n    key: \"numBytesAllocated\",\n    get: function get() {\n      return this._numBytesAllocated;\n    }\n  }, {\n    key: \"numBytesFree\",\n    get: function get() {\n      return this._numBytesFree;\n    }\n  }, {\n    key: \"getNumUsedTextures\",\n    value: function getNumUsedTextures() {\n      return this.numUsedTextures;\n    }\n  }, {\n    key: \"getNumFreeTextures\",\n    value: function getNumFreeTextures() {\n      return this.numFreeTextures;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this = this;\n\n      if (this.freeTextures == null) {\n        // Already disposed.\n        return;\n      }\n\n      for (var texShape in this.freeTextures) {\n        this.freeTextures[texShape].forEach(function (tex) {\n          _this.gpgpu.deleteMatrixTexture(tex);\n        });\n      }\n\n      for (var _texShape in this.usedTextures) {\n        this.usedTextures[_texShape].forEach(function (tex) {\n          _this.gpgpu.deleteMatrixTexture(tex);\n        });\n      }\n\n      this.freeTextures = null;\n      this.usedTextures = null;\n      this.numUsedTextures = 0;\n      this.numFreeTextures = 0;\n      this._numBytesAllocated = 0;\n      this._numBytesFree = 0;\n    }\n  }]);\n\n  return TextureManager;\n}();\n\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  var glany = gl;\n\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  }\n\n  throw new Error(\"Unknown internal format \".concat(internalFormat));\n}\n\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  var internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  var numElements;\n\n  if (isPacked) {\n    var _getPackedMatrixTextu = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]),\n        _getPackedMatrixTextu2 = _slicedToArray(_getPackedMatrixTextu, 2),\n        packedWidth = _getPackedMatrixTextu2[0],\n        packedHeight = _getPackedMatrixTextu2[1];\n\n    numElements = packedWidth * packedHeight;\n  } else {\n    var _getUnpackedMatrixTex = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]),\n        _getUnpackedMatrixTex2 = _slicedToArray(_getUnpackedMatrixTex, 2),\n        width = _getUnpackedMatrixTex2[0],\n        height = _getUnpackedMatrixTex2[1];\n\n    numElements = width * height;\n  }\n\n  var bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n\n    default:\n      throw new Error(\"Unknown physical texture type \".concat(physicalTexType));\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n\n  throw new Error(\"Unknown logical texture type \".concat(logicalTexType));\n}\n\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return \"\".concat(shapeRowsCol[0], \"_\").concat(shapeRowsCol[1], \"_\").concat(physicalTexType, \"_\").concat(isPacked);\n}","map":{"version":3,"sources":["../src/texture_manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n        const freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n    }\n    get numBytesAllocated() {\n        return this._numBytesAllocated;\n    }\n    get numBytesFree() {\n        return this._numBytesFree;\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    let numElements;\n    if (isPacked) {\n        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = width * height;\n    }\n    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(`Unknown physical texture type ${physicalTexType}`);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n//# sourceMappingURL=texture_manager.js.map"]},"metadata":{},"sourceType":"module"}