{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n  constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n    this.variableNames = ['x', 'W'];\n    this.outputShape = convInfo.outShape;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n    let activationSnippet = '',\n        applyActivationSnippet = '';\n\n    if (activation) {\n      if (hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluAlpha) {\n        activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n\n}\nexport class Conv3DProgram {\n  constructor(convInfo) {\n    this.variableNames = ['x', 'W'];\n    this.outputShape = convInfo.outShape;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n    this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n\n}","map":{"version":3,"sources":["../src/conv_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\nexport class Conv3DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu.js.map"]},"metadata":{},"sourceType":"module"}