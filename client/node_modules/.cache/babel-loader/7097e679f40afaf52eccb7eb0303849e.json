{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { FusedBatchNorm } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { xAs4D } from './batchnorm_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Batch normalization.\n *\n * As described in\n * [http://arxiv.org/abs/1502.03167](http://arxiv.org/abs/1502.03167).\n *\n * Mean, variance, scale, and offset can be of two shapes:\n *   - The same shape as the input.\n *   - In the common case, the depth dimension is the last dimension of x, so\n *     the values would be an `tf.Tensor1D` of shape [depth].\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that parameters passed are of given rank\n *   - `tf.batchNorm2d`\n *   - `tf.batchNorm3d`\n *   - `tf.batchNorm4d`\n *\n * @param x The input Tensor.\n * @param mean A mean Tensor.\n * @param variance A variance Tensor.\n * @param offset An offset Tensor.\n * @param scale A scale Tensor.\n * @param varianceEpsilon A small float number to avoid dividing by 0.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\n\nfunction batchNorm_(x, mean, variance, offset, scale, varianceEpsilon) {\n  if (varianceEpsilon == null) {\n    varianceEpsilon = 0.001;\n  }\n\n  const $x = convertToTensor(x, 'x', 'batchNorm');\n  const $mean = convertToTensor(mean, 'mean', 'batchNorm');\n  const $variance = convertToTensor(variance, 'variance', 'batchNorm');\n  let $scale;\n\n  if (scale != null) {\n    $scale = convertToTensor(scale, 'scale', 'batchNorm');\n  }\n\n  let $offset;\n\n  if (offset != null) {\n    $offset = convertToTensor(offset, 'offset', 'batchNorm');\n  }\n\n  util.assert($mean.rank === $variance.rank, () => 'Batch normalization gradient requires mean and variance to have ' + 'equal ranks.');\n  util.assert($offset == null || $mean.rank === $offset.rank, () => 'Batch normalization gradient requires mean and offset to have ' + 'equal ranks.');\n  util.assert($scale == null || $mean.rank === $scale.rank, () => 'Batch normalization gradient requires mean and scale to have ' + 'equal ranks.');\n  const x4D = xAs4D($x);\n  const inputs = {\n    x: x4D,\n    scale: $scale,\n    offset: $offset,\n    mean: $mean,\n    variance: $variance\n  };\n  const attrs = {\n    varianceEpsilon\n  }; // tslint:disable-next-line: no-unnecessary-type-assertion\n\n  const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);\n  return reshape(res, $x.shape);\n}\n\nexport const batchNorm = op({\n  batchNorm_\n});","map":{"version":3,"sources":["../../src/ops/batchnorm.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,QAAqB,WAArB;AACA,SAAQ,cAAR,QAAwE,iBAAxE;AAIA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,OAAO,KAAK,IAAZ,MAAsB,SAAtB;AAEA,SAAQ,KAAR,QAAoB,kBAApB;AACA,SAAQ,EAAR,QAAiB,aAAjB;AACA,SAAQ,OAAR,QAAsB,WAAtB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;;AACH,SAAS,UAAT,CACI,CADJ,EAC6B,IAD7B,EAEI,QAFJ,EAGI,MAHJ,EAII,KAJJ,EAKI,eALJ,EAK4B;AAC1B,MAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,IAAA,eAAe,GAAG,KAAlB;AACD;;AACD,QAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,WAAT,CAA1B;AACA,QAAM,KAAK,GAAG,eAAe,CAAC,IAAD,EAAO,MAAP,EAAe,WAAf,CAA7B;AACA,QAAM,SAAS,GAAG,eAAe,CAAC,QAAD,EAAW,UAAX,EAAuB,WAAvB,CAAjC;AACA,MAAI,MAAJ;;AACA,MAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,IAAA,MAAM,GAAG,eAAe,CAAC,KAAD,EAAQ,OAAR,EAAiB,WAAjB,CAAxB;AACD;;AACD,MAAI,OAAJ;;AACA,MAAI,MAAM,IAAI,IAAd,EAAoB;AAClB,IAAA,OAAO,GAAG,eAAe,CAAC,MAAD,EAAS,QAAT,EAAmB,WAAnB,CAAzB;AACD;;AAED,EAAA,IAAI,CAAC,MAAL,CACI,KAAK,CAAC,IAAN,KAAe,SAAS,CAAC,IAD7B,EAEI,MAAM,qEACF,cAHR;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,OAAO,IAAI,IAAX,IAAmB,KAAK,CAAC,IAAN,KAAe,OAAO,CAAC,IAD9C,EAEI,MAAM,mEACF,cAHR;AAIA,EAAA,IAAI,CAAC,MAAL,CACI,MAAM,IAAI,IAAV,IAAkB,KAAK,CAAC,IAAN,KAAe,MAAM,CAAC,IAD5C,EAEI,MAAM,kEACF,cAHR;AAKA,QAAM,GAAG,GAAa,KAAK,CAAC,EAAD,CAA3B;AAEA,QAAM,MAAM,GAAyB;AACnC,IAAA,CAAC,EAAE,GADgC;AAEnC,IAAA,KAAK,EAAE,MAF4B;AAGnC,IAAA,MAAM,EAAE,OAH2B;AAInC,IAAA,IAAI,EAAE,KAJ6B;AAKnC,IAAA,QAAQ,EAAE;AALyB,GAArC;AAQA,QAAM,KAAK,GAAwB;AAAC,IAAA;AAAD,GAAnC,CAvC0B,CAyC1B;;AACA,QAAM,GAAG,GAAG,MAAM,CAAC,SAAP,CACI,cADJ,EACoB,MADpB,EAEI,KAFJ,CAAZ;AAIA,SAAO,OAAO,CAAC,GAAD,EAAM,EAAE,CAAC,KAAT,CAAd;AACD;;AAED,OAAO,MAAM,SAAS,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAApB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { FusedBatchNorm } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { xAs4D } from './batchnorm_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Batch normalization.\n *\n * As described in\n * [http://arxiv.org/abs/1502.03167](http://arxiv.org/abs/1502.03167).\n *\n * Mean, variance, scale, and offset can be of two shapes:\n *   - The same shape as the input.\n *   - In the common case, the depth dimension is the last dimension of x, so\n *     the values would be an `tf.Tensor1D` of shape [depth].\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that parameters passed are of given rank\n *   - `tf.batchNorm2d`\n *   - `tf.batchNorm3d`\n *   - `tf.batchNorm4d`\n *\n * @param x The input Tensor.\n * @param mean A mean Tensor.\n * @param variance A variance Tensor.\n * @param offset An offset Tensor.\n * @param scale A scale Tensor.\n * @param varianceEpsilon A small float number to avoid dividing by 0.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction batchNorm_(x, mean, variance, offset, scale, varianceEpsilon) {\n    if (varianceEpsilon == null) {\n        varianceEpsilon = 0.001;\n    }\n    const $x = convertToTensor(x, 'x', 'batchNorm');\n    const $mean = convertToTensor(mean, 'mean', 'batchNorm');\n    const $variance = convertToTensor(variance, 'variance', 'batchNorm');\n    let $scale;\n    if (scale != null) {\n        $scale = convertToTensor(scale, 'scale', 'batchNorm');\n    }\n    let $offset;\n    if (offset != null) {\n        $offset = convertToTensor(offset, 'offset', 'batchNorm');\n    }\n    util.assert($mean.rank === $variance.rank, () => 'Batch normalization gradient requires mean and variance to have ' +\n        'equal ranks.');\n    util.assert($offset == null || $mean.rank === $offset.rank, () => 'Batch normalization gradient requires mean and offset to have ' +\n        'equal ranks.');\n    util.assert($scale == null || $mean.rank === $scale.rank, () => 'Batch normalization gradient requires mean and scale to have ' +\n        'equal ranks.');\n    const x4D = xAs4D($x);\n    const inputs = {\n        x: x4D,\n        scale: $scale,\n        offset: $offset,\n        mean: $mean,\n        variance: $variance\n    };\n    const attrs = { varianceEpsilon };\n    // tslint:disable-next-line: no-unnecessary-type-assertion\n    const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);\n    return reshape(res, $x.shape);\n}\nexport const batchNorm = op({ batchNorm_ });\n//# sourceMappingURL=batchnorm.js.map"]},"metadata":{},"sourceType":"module"}