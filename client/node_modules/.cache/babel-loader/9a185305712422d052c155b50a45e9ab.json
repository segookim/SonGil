{"ast":null,"code":"import _regeneratorRuntime from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\n\nexport function deepMap(input, mapFn) {\n  return deepMapInternal(input, mapFn);\n}\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\n\nfunction deepMapInternal(input, mapFn) {\n  var seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  var containedIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n\n  if (input == null) {\n    return null;\n  }\n\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n\n  if (seen.has(input)) {\n    return seen.get(input);\n  }\n\n  var result = mapFn(input);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error('A deep map function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    seen.set(input, result.value);\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    var mappedIterable = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n\n    for (var k in input) {\n      var child = input[k];\n      var childResult = deepMapInternal(child, mapFn, seen, containedIn);\n      mappedIterable[k] = childResult;\n    }\n\n    containedIn.delete(input);\n    return mappedIterable;\n  } else {\n    throw new Error(\"Can't recurse into non-iterable type: \".concat(input));\n  }\n} // TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\n\n\nexport function deepZip(inputs) {\n  var zipFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : zipToList;\n  return deepZipInternal(inputs, zipFn);\n}\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\n\nfunction deepZipInternal(inputs, zipFn) {\n  var containedIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  // The recursion follows the structure of input 0; it's assumed that all the\n  // other inputs have the same structure.\n  var input = inputs[0];\n\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n\n  var result = zipFn(inputs);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error('A deep zip function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    var mappedIterable = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n\n    var _loop = function _loop(k) {\n      var children = inputs.map(function (x) {\n        return x[k];\n      });\n      var childResult = deepZipInternal(children, zipFn, containedIn);\n      mappedIterable[k] = childResult;\n    };\n\n    for (var k in input) {\n      _loop(k);\n    }\n\n    containedIn.delete(input);\n    return mappedIterable;\n  } else {\n    throw new Error(\"Can't recurse into non-iterable type: \".concat(input));\n  }\n} // tslint:disable-next-line:no-any\n\n\nexport function zipToList(x) {\n  if (x === null) {\n    return null;\n  } // TODO(soergel): validate array type?\n\n\n  if (isIterable(x[0])) {\n    return {\n      value: null,\n      recurse: true\n    };\n  } else {\n    return {\n      value: x,\n      recurse: false\n    };\n  }\n}\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\n\nexport function deepMapAndAwaitAll(_x, _x2) {\n  return _deepMapAndAwaitAll.apply(this, arguments);\n}\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\n\nfunction _deepMapAndAwaitAll() {\n  _deepMapAndAwaitAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input, mapFn) {\n    var seen, _i, _Array$from, key, value, mappedValue, result;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            seen = new Map(); // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n\n            deepMapInternal(input, mapFn, seen); // Replace the Promises in 'seen' in place.\n            // Note TypeScript provides no async map iteration, and regular map iteration\n            // is broken too, so sadly we have to do Array.from() to make it work.\n            // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n\n            _i = 0, _Array$from = Array.from(seen.keys());\n\n          case 3:\n            if (!(_i < _Array$from.length)) {\n              _context.next = 14;\n              break;\n            }\n\n            key = _Array$from[_i];\n            value = seen.get(key);\n\n            if (!tf.util.isPromise(value)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 9;\n            return value;\n\n          case 9:\n            mappedValue = _context.sent;\n            seen.set(key, mappedValue);\n\n          case 11:\n            _i++;\n            _context.next = 3;\n            break;\n\n          case 14:\n            // Normal deepMap again, this time filling in the resolved values.\n            // It's unfortunate that we have to do two passes.\n            // TODO(soergel): test performance and think harder about a fast solution.\n            result = deepMapInternal(input, mapFn, seen);\n            return _context.abrupt(\"return\", result);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _deepMapAndAwaitAll.apply(this, arguments);\n}\n\nexport function isIterable(obj) {\n  return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === 'object' && !(obj instanceof tf.Tensor));\n}\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\n\nexport function canTensorify(obj) {\n  return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === 'object' && obj instanceof tf.Tensor || tf.util.isTypedArray(obj);\n}\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\n\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object' && typeof value !== 'function';\n}","map":{"version":3,"sources":["../../src/util/deep_map.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\nexport function deepMap(input, mapFn) {\n    return deepMapInternal(input, mapFn);\n}\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepMapInternal(input, mapFn, seen = new Map(), containedIn = new Set()) {\n    if (input == null) {\n        return null;\n    }\n    if (containedIn.has(input)) {\n        throw new Error('Circular references are not supported.');\n    }\n    if (seen.has(input)) {\n        return seen.get(input);\n    }\n    const result = mapFn(input);\n    if (result.recurse && result.value !== null) {\n        throw new Error('A deep map function may not return both a value and recurse=true.');\n    }\n    if (!result.recurse) {\n        seen.set(input, result.value);\n        return result.value;\n    }\n    else if (isIterable(input)) {\n        // tslint:disable-next-line:no-any\n        const mappedIterable = Array.isArray(input) ? [] : {};\n        containedIn.add(input);\n        for (const k in input) {\n            const child = input[k];\n            const childResult = deepMapInternal(child, mapFn, seen, containedIn);\n            mappedIterable[k] = childResult;\n        }\n        containedIn.delete(input);\n        return mappedIterable;\n    }\n    else {\n        throw new Error(`Can't recurse into non-iterable type: ${input}`);\n    }\n}\n// TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\nexport function deepZip(inputs, zipFn = zipToList) {\n    return deepZipInternal(inputs, zipFn);\n}\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepZipInternal(inputs, zipFn, containedIn = new Set()) {\n    // The recursion follows the structure of input 0; it's assumed that all the\n    // other inputs have the same structure.\n    const input = inputs[0];\n    if (containedIn.has(input)) {\n        throw new Error('Circular references are not supported.');\n    }\n    const result = zipFn(inputs);\n    if (result.recurse && result.value !== null) {\n        throw new Error('A deep zip function may not return both a value and recurse=true.');\n    }\n    if (!result.recurse) {\n        return result.value;\n    }\n    else if (isIterable(input)) {\n        // tslint:disable-next-line:no-any\n        const mappedIterable = Array.isArray(input) ? [] : {};\n        containedIn.add(input);\n        for (const k in input) {\n            const children = inputs.map(x => x[k]);\n            const childResult = deepZipInternal(children, zipFn, containedIn);\n            mappedIterable[k] = childResult;\n        }\n        containedIn.delete(input);\n        return mappedIterable;\n    }\n    else {\n        throw new Error(`Can't recurse into non-iterable type: ${input}`);\n    }\n}\n// tslint:disable-next-line:no-any\nexport function zipToList(x) {\n    if (x === null) {\n        return null;\n    }\n    // TODO(soergel): validate array type?\n    if (isIterable(x[0])) {\n        return { value: null, recurse: true };\n    }\n    else {\n        return { value: x, recurse: false };\n    }\n}\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\nexport async function deepMapAndAwaitAll(input, mapFn) {\n    const seen = new Map();\n    // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n    deepMapInternal(input, mapFn, seen);\n    // Replace the Promises in 'seen' in place.\n    // Note TypeScript provides no async map iteration, and regular map iteration\n    // is broken too, so sadly we have to do Array.from() to make it work.\n    // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n    for (const key of Array.from(seen.keys())) {\n        const value = seen.get(key);\n        if (tf.util.isPromise(value)) {\n            const mappedValue = await value;\n            seen.set(key, mappedValue);\n        }\n    }\n    // Normal deepMap again, this time filling in the resolved values.\n    // It's unfortunate that we have to do two passes.\n    // TODO(soergel): test performance and think harder about a fast solution.\n    const result = deepMapInternal(input, mapFn, seen);\n    return result;\n}\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\nexport function isIterable(obj) {\n    return obj != null && (!ArrayBuffer.isView(obj)) &&\n        (Array.isArray(obj) ||\n            (typeof obj === 'object' && !(obj instanceof tf.Tensor)));\n}\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\nexport function canTensorify(obj) {\n    return obj == null || isPrimitive(obj) || Array.isArray(obj) ||\n        (typeof obj === 'object' && (obj instanceof tf.Tensor)) ||\n        tf.util.isTypedArray(obj);\n}\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\nfunction isPrimitive(value) {\n    return (value === null ||\n        (typeof value !== 'object' && typeof value !== 'function'));\n}\n//# sourceMappingURL=deep_map.js.map"]},"metadata":{},"sourceType":"module"}