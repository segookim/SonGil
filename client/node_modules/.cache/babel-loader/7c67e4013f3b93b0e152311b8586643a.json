{"ast":null,"code":"import _toConsumableArray from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\n\nexport function prepareAndValidate(tensor, indices) {\n  var tensorRank = tensor.shape.length;\n  var indicesRank = indices.shape.length;\n\n  if (tensorRank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + \" but the rank was \".concat(tensorRank, \".\"));\n  }\n\n  if (indicesRank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + \" but the rank was \".concat(indicesRank, \".\"));\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + \" but the dtype was \".concat(indices.dtype, \".\"));\n  }\n\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + \"\".concat(indices.shape[indicesRank - 1], \" vs. \").concat(tensorRank));\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + \" Input shape: \".concat(tensor.shape, \".\"));\n  }\n\n  var indicesShape = indices.shape;\n  var sliceRank = indicesShape[indicesShape.length - 1]; // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\n  var nResult = 1;\n\n  for (var i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  var inputShape = tensor.shape;\n  var resultShape = indicesShape.slice();\n  resultShape.pop();\n  var sliceSize = 1;\n\n  for (var _i = sliceRank; _i < tensorRank; ++_i) {\n    sliceSize *= inputShape[_i];\n    resultShape.push(inputShape[_i]);\n  }\n\n  var strides = [].concat(_toConsumableArray(computeStrides(tensor.shape).map(function (stride) {\n    return stride / sliceSize;\n  })), [1]).slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"sources":["../../src/ops/gather_nd_util.ts"],"names":[],"mappings":";AAiBA,SAAQ,cAAR,EAAwB,aAAxB,QAA4C,SAA5C;AAEA;;;;;;;AAOG;;AACH,OAAM,SAAU,kBAAV,CAA6B,MAA7B,EAAiD,OAAjD,EAAoE;AAExE,MAAM,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,MAAhC;AACA,MAAM,WAAW,GAAG,OAAO,CAAC,KAAR,CAAc,MAAlC;;AACA,MAAI,UAAU,GAAG,CAAjB,EAAoB;AAClB,UAAM,IAAI,KAAJ,CACF,wFACqB,UADrB,MADE,CAAN;AAGD;;AACD,MAAI,WAAW,GAAG,CAAlB,EAAqB;AACnB,UAAM,IAAI,KAAJ,CACF,0FACqB,WADrB,MADE,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,KAAR,KAAkB,OAAtB,EAA+B;AAC7B,UAAM,IAAI,KAAJ,CACF,qFACsB,OAAO,CAAC,KAD9B,MADE,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,KAAR,CAAc,WAAW,GAAG,CAA5B,IAAiC,UAArC,EAAiD;AAC/C,UAAM,IAAI,KAAJ,CACF,6EACG,OAAO,CAAC,KAAR,CAAc,WAAW,GAAG,CAA5B,CADH,kBACyC,UADzC,CADE,CAAN;AAGD;;AAED,MAAI,aAAa,CAAC,MAAM,CAAC,KAAR,CAAb,KAAgC,CAApC,EAAuC;AACrC,UAAM,IAAI,KAAJ,CACF,+EACiB,MAAM,CAAC,KADxB,MADE,CAAN;AAGD;;AAED,MAAM,YAAY,GAAG,OAAO,CAAC,KAA7B;AACA,MAAM,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAA9B,CAhCwE,CAkCxE;AACA;;AACA,MAAI,OAAO,GAAG,CAAd;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAb,GAAsB,CAA1C,EAA6C,EAAE,CAA/C,EAAkD;AAChD,IAAA,OAAO,IAAI,YAAY,CAAC,CAAD,CAAvB;AACD;;AAED,MAAM,UAAU,GAAG,MAAM,CAAC,KAA1B;AAEA,MAAM,WAAW,GAAG,YAAY,CAAC,KAAb,EAApB;AACA,EAAA,WAAW,CAAC,GAAZ;AAEA,MAAI,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAI,EAAC,GAAG,SAAb,EAAwB,EAAC,GAAG,UAA5B,EAAwC,EAAE,EAA1C,EAA6C;AAC3C,IAAA,SAAS,IAAI,UAAU,CAAC,EAAD,CAAvB;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,UAAU,CAAC,EAAD,CAA3B;AACD;;AAED,MAAM,OAAO,GACT,6BAAI,cAAc,CAAC,MAAM,CAAC,KAAR,CAAd,CAA6B,GAA7B,CAAiC,UAAA,MAAM;AAAA,WAAI,MAAM,GAAG,SAAb;AAAA,GAAvC,CAAJ,IACC,CADD,GACI,KADJ,CACU,CADV,EACa,SADb,CADJ;AAIA,SAAO,CAAC,WAAD,EAAc,OAAd,EAAuB,SAAvB,EAAkC,OAAlC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    const tensorRank = tensor.shape.length;\n    const indicesRank = indices.shape.length;\n    if (tensorRank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensorRank}.`);\n    }\n    if (indicesRank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indicesRank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indicesRank - 1] > tensorRank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n    }\n    if (sizeFromShape(tensor.shape) === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensorRank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n//# sourceMappingURL=gather_nd_util.js.map"]},"metadata":{},"sourceType":"module"}