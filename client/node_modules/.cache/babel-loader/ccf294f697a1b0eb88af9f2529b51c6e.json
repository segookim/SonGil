{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      segmentIds = inputs.segmentIds;\n  var numSegments = attrs.numSegments;\n  assertNotComplex(x, 'unsortedSegmentSum');\n  var xRank = x.shape.length;\n  var segmentIdsRank = segmentIds.shape.length;\n  var res = [];\n  var intermediates = []; // Reshape the segment id's so that they can be broadcast with\n  // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n\n  var numIters = xRank - segmentIdsRank;\n  var $segmentIds = segmentIds;\n\n  for (var i = 0; i < numIters; ++i) {\n    var expanded = expandDims({\n      inputs: {\n        input: $segmentIds\n      },\n      backend: backend,\n      attrs: {\n        dim: i + 1\n      }\n    });\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n\n  for (var _i = 0; _i < numSegments; ++_i) {\n    var scalarValue = util.createScalarValue(_i, 'int32');\n    var segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    var mask = equal({\n      inputs: {\n        a: segmentId,\n        b: $segmentIds\n      },\n      backend: backend\n    });\n    var maskCasted = cast({\n      inputs: {\n        x: mask\n      },\n      backend: backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    var mul = multiply({\n      inputs: {\n        a: maskCasted,\n        b: x\n      },\n      backend: backend\n    });\n    var sumTensorInfo = sum({\n      inputs: {\n        x: mul\n      },\n      backend: backend,\n      attrs: {\n        axis: 0,\n        keepDims: false\n      }\n    });\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n\n  var result = pack({\n    inputs: res,\n    backend: backend,\n    attrs: {\n      axis: 0\n    }\n  });\n  intermediates.forEach(function (t) {\n    return backend.disposeIntermediateTensorInfo(t);\n  });\n  return result;\n}\nexport var unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"sources":["../../src/kernels/UnsortedSegmentSum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, segmentIds } = inputs;\n    const { numSegments } = attrs;\n    assertNotComplex(x, 'unsortedSegmentSum');\n    const xRank = x.shape.length;\n    const segmentIdsRank = segmentIds.shape.length;\n    const res = [];\n    const intermediates = [];\n    // Reshape the segment id's so that they can be broadcast with\n    // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n    const numIters = xRank - segmentIdsRank;\n    let $segmentIds = segmentIds;\n    for (let i = 0; i < numIters; ++i) {\n        const expanded = expandDims({ inputs: { input: $segmentIds }, backend, attrs: { dim: i + 1 } });\n        $segmentIds = expanded;\n        intermediates.push(expanded);\n    }\n    for (let i = 0; i < numSegments; ++i) {\n        const scalarValue = util.createScalarValue(i, 'int32');\n        const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n        const mask = equal({ inputs: { a: segmentId, b: $segmentIds }, backend });\n        const maskCasted = cast({ inputs: { x: mask }, backend, attrs: { dtype: 'float32' } });\n        const mul = multiply({ inputs: { a: maskCasted, b: x }, backend });\n        const sumTensorInfo = sum({ inputs: { x: mul }, backend, attrs: { axis: 0, keepDims: false } });\n        res.push(sumTensorInfo);\n        intermediates.push(segmentId);\n        intermediates.push(mask);\n        intermediates.push(maskCasted);\n        intermediates.push(mul);\n        intermediates.push(sumTensorInfo);\n    }\n    const result = pack({ inputs: res, backend, attrs: { axis: 0 } });\n    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const unsortedSegmentSumConfig = {\n    kernelName: UnsortedSegmentSum,\n    backendName: 'cpu',\n    kernelFunc: unsortedSegmentSum\n};\n//# sourceMappingURL=UnsortedSegmentSum.js.map"]},"metadata":{},"sourceType":"module"}