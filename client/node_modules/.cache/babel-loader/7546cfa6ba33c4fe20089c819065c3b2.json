{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat } from '../concat';\nimport { fill } from '../fill';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { tensor2d } from '../tensor2d';\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\n\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n  let start = 0;\n  const output = [];\n\n  while (start + frameLength <= signal.size) {\n    output.push(slice(signal, start, frameLength));\n    start += frameStep;\n  }\n\n  if (padEnd) {\n    while (start < signal.size) {\n      const padLen = start + frameLength - signal.size;\n      const pad = concat([slice(signal, start, frameLength - padLen), fill([padLen], padValue)]);\n      output.push(pad);\n      start += frameStep;\n    }\n  }\n\n  if (output.length === 0) {\n    return tensor2d([], [0, frameLength]);\n  }\n\n  return reshape(concat(output), [output.length, frameLength]);\n}\n\nexport const frame = op({\n  frame_\n});","map":{"version":3,"sources":["../../../src/ops/signal/frame.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAQ,MAAR,QAAqB,WAArB;AACA,SAAQ,IAAR,QAAmB,SAAnB;AACA,SAAQ,EAAR,QAAiB,cAAjB;AACA,SAAQ,OAAR,QAAsB,YAAtB;AACA,SAAQ,KAAR,QAAoB,UAApB;AACA,SAAQ,QAAR,QAAuB,aAAvB;AAEA;;;;;;;;;;;;;;;AAeG;;AACH,SAAS,MAAT,CACI,MADJ,EACsB,WADtB,EAC2C,SAD3C,EAC8D,MAAM,GAAG,KADvE,EAEI,QAAQ,GAAG,CAFf,EAEgB;AACd,MAAI,KAAK,GAAG,CAAZ;AACA,QAAM,MAAM,GAAa,EAAzB;;AACA,SAAO,KAAK,GAAG,WAAR,IAAuB,MAAM,CAAC,IAArC,EAA2C;AACzC,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAhB,CAAjB;AACA,IAAA,KAAK,IAAI,SAAT;AACD;;AAED,MAAI,MAAJ,EAAY;AACV,WAAO,KAAK,GAAG,MAAM,CAAC,IAAtB,EAA4B;AAC1B,YAAM,MAAM,GAAI,KAAK,GAAG,WAAT,GAAwB,MAAM,CAAC,IAA9C;AACA,YAAM,GAAG,GAAG,MAAM,CAAC,CACjB,KAAK,CAAC,MAAD,EAAS,KAAT,EAAgB,WAAW,GAAG,MAA9B,CADY,EAC2B,IAAI,CAAC,CAAC,MAAD,CAAD,EAAW,QAAX,CAD/B,CAAD,CAAlB;AAGA,MAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACA,MAAA,KAAK,IAAI,SAAT;AACD;AACF;;AAED,MAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO,QAAQ,CAAC,EAAD,EAAK,CAAC,CAAD,EAAI,WAAJ,CAAL,CAAf;AACD;;AAED,SAAO,OAAO,CAAC,MAAM,CAAC,MAAD,CAAP,EAAiB,CAAC,MAAM,CAAC,MAAR,EAAgB,WAAhB,CAAjB,CAAd;AACD;;AACD,OAAO,MAAM,KAAK,GAAG,EAAE,CAAC;AAAC,EAAA;AAAD,CAAD,CAAhB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat } from '../concat';\nimport { fill } from '../fill';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { tensor2d } from '../tensor2d';\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n    let start = 0;\n    const output = [];\n    while (start + frameLength <= signal.size) {\n        output.push(slice(signal, start, frameLength));\n        start += frameStep;\n    }\n    if (padEnd) {\n        while (start < signal.size) {\n            const padLen = (start + frameLength) - signal.size;\n            const pad = concat([\n                slice(signal, start, frameLength - padLen), fill([padLen], padValue)\n            ]);\n            output.push(pad);\n            start += frameStep;\n        }\n    }\n    if (output.length === 0) {\n        return tensor2d([], [0, frameLength]);\n    }\n    return reshape(concat(output), [output.length, frameLength]);\n}\nexport const frame = op({ frame_ });\n//# sourceMappingURL=frame.js.map"]},"metadata":{},"sourceType":"module"}