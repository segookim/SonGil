{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images,\n      dy = inputs.dy;\n  var alignCorners = attrs.alignCorners;\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n  var imagesStrides = util.computeStrides(images.shape);\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      xHeight = _images$shape[1],\n      xWidth = _images$shape[2],\n      depth = _images$shape[3];\n\n  var _dy$shape = _slicedToArray(dy.shape, 3),\n      yHeight = _dy$shape[1],\n      yWidth = _dy$shape[2];\n\n  var output = new Float32Array(batch * xHeight * xWidth * depth); // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n\n  var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  var heightScale = effectiveXSize[0] / effectiveYSize[0];\n  var widthScale = effectiveXSize[1] / effectiveYSize[1]; // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n\n  var dyValues = backend.data.get(dy.dataId).values;\n  var offset = 0;\n\n  for (var b = 0; b < batch; b++) {\n    var bOffset = b * imagesStrides[0];\n\n    for (var r = 0; r < yHeight; r++) {\n      var dxR = r * heightScale;\n      var topDxRIndex = Math.floor(dxR);\n      var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n      var topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      var bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n      var dxRLerp = dxR - topDxRIndex;\n      var inverseDxRLerp = 1.0 - dxRLerp;\n\n      for (var c = 0; c < yWidth; c++) {\n        var dxC = c * widthScale;\n        var leftDxCIndex = Math.floor(dxC);\n        var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        var dxCLerp = dxC - leftDxCIndex;\n        var inverseDxCLerp = 1.0 - dxCLerp;\n        var topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        var topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n        var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n        var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n        var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n\n        for (var d = 0; d < depth; d++) {\n          var dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport var resizeBilinearGradConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad\n};","map":{"version":3,"sources":["../../src/kernels/ResizeBilinearGrad.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkC,kBAAlC,EAAiI,IAAjI,QAA4I,uBAA5I;AAGA,SAAQ,gBAAR,QAA+B,aAA/B;AAEA,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAIL;AAAA,MACQ,MADR,GACkC,IADlC,CACQ,MADR;AAAA,MACgB,OADhB,GACkC,IADlC,CACgB,OADhB;AAAA,MACyB,KADzB,GACkC,IADlC,CACyB,KADzB;AAAA,MAEQ,MAFR,GAEsB,MAFtB,CAEQ,MAFR;AAAA,MAEgB,EAFhB,GAEsB,MAFtB,CAEgB,EAFhB;AAAA,MAGQ,YAHR,GAGwB,KAHxB,CAGQ,YAHR;AAKC,EAAA,gBAAgB,CAAC,CAAC,EAAD,EAAK,MAAL,CAAD,EAAe,oBAAf,CAAhB;AAEA,MAAM,aAAa,GAAG,IAAI,CAAC,cAAL,CAAoB,MAAM,CAAC,KAA3B,CAAtB;;AAPD,qCASyC,MAAM,CAAC,KAThD;AAAA,MASQ,KATR;AAAA,MASe,OATf;AAAA,MASwB,MATxB;AAAA,MASgC,KAThC;;AAAA,iCAU6B,EAAE,CAAC,KAVhC;AAAA,MAUU,OAVV;AAAA,MAUmB,MAVnB;;AAYC,MAAM,MAAM,GAAG,IAAI,YAAJ,CAAiB,KAAK,GAAG,OAAR,GAAkB,MAAlB,GAA2B,KAA5C,CAAf,CAZD,CAcC;AACA;AACA;AACA;;AAEA,MAAM,cAAc,GAAqB,CACtC,YAAY,IAAI,OAAO,GAAG,CAA3B,GAAgC,OAAO,GAAG,CAA1C,GAA8C,OADP,EAEtC,YAAY,IAAI,MAAM,GAAG,CAA1B,GAA+B,MAAM,GAAG,CAAxC,GAA4C,MAFL,CAAzC;AAKA,MAAM,cAAc,GAAqB,CACtC,YAAY,IAAI,OAAO,GAAG,CAA3B,GAAgC,OAAO,GAAG,CAA1C,GAA8C,OADP,EAEtC,YAAY,IAAI,MAAM,GAAG,CAA1B,GAA+B,MAAM,GAAG,CAAxC,GAA4C,MAFL,CAAzC;AAKA,MAAM,WAAW,GAAG,cAAc,CAAC,CAAD,CAAd,GAAoB,cAAc,CAAC,CAAD,CAAtD;AACA,MAAM,UAAU,GAAG,cAAc,CAAC,CAAD,CAAd,GAAoB,cAAc,CAAC,CAAD,CAArD,CA9BD,CAgCC;AACA;AACA;;AACA,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,EAAE,CAAC,MAApB,EAA4B,MAA7C;AACA,MAAI,MAAM,GAAG,CAAb;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,QAAM,OAAO,GAAG,CAAC,GAAG,aAAa,CAAC,CAAD,CAAjC;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAApB,EAA6B,CAAC,EAA9B,EAAkC;AAChC,UAAM,GAAG,GAAG,CAAC,GAAG,WAAhB;AACA,UAAM,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAApB;AACA,UAAM,cAAc,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,IAAL,CAAU,GAAV,CAAT,EAAyB,OAAO,GAAG,CAAnC,CAAvB;AAEA,UAAM,YAAY,GAAG,OAAO,GAAG,WAAW,GAAG,aAAa,CAAC,CAAD,CAA1D;AACA,UAAM,eAAe,GAAG,OAAO,GAAG,cAAc,GAAG,aAAa,CAAC,CAAD,CAAhE;AAEA,UAAM,OAAO,GAAG,GAAG,GAAG,WAAtB;AACA,UAAM,cAAc,GAAG,MAAM,OAA7B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,CAAC,EAA7B,EAAiC;AAC/B,YAAM,GAAG,GAAG,CAAC,GAAG,UAAhB;AACA,YAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAArB;AACA,YAAM,aAAa,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,IAAL,CAAU,GAAV,CAAT,EAAyB,MAAM,GAAG,CAAlC,CAAtB;AACA,YAAM,OAAO,GAAG,GAAG,GAAG,YAAtB;AACA,YAAM,cAAc,GAAG,MAAM,OAA7B;AAEA,YAAM,eAAe,GAAG,YAAY,GAAG,YAAY,GAAG,aAAa,CAAC,CAAD,CAAnE;AACA,YAAM,gBAAgB,GAClB,YAAY,GAAG,aAAa,GAAG,aAAa,CAAC,CAAD,CADhD;AAEA,YAAM,kBAAkB,GACpB,eAAe,GAAG,YAAY,GAAG,aAAa,CAAC,CAAD,CADlD;AAEA,YAAM,mBAAmB,GACrB,eAAe,GAAG,aAAa,GAAG,aAAa,CAAC,CAAD,CADnD;AAGA,YAAM,iCAAiC,GACnC,cAAc,GAAG,cADrB;AAEA,YAAM,0BAA0B,GAAG,cAAc,GAAG,OAApD;AACA,YAAM,0BAA0B,GAAG,OAAO,GAAG,cAA7C;AACA,YAAM,mBAAmB,GAAG,OAAO,GAAG,OAAtC;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,cAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,EAAP,CAAtB;AACA,UAAA,MAAM,CAAC,eAAe,GAAG,CAAnB,CAAN,IACI,KAAK,GAAG,iCADZ;AAEA,UAAA,MAAM,CAAC,gBAAgB,GAAG,CAApB,CAAN,IAAgC,KAAK,GAAG,0BAAxC;AACA,UAAA,MAAM,CAAC,kBAAkB,GAAG,CAAtB,CAAN,IAAkC,KAAK,GAAG,0BAA1C;AACA,UAAA,MAAM,CAAC,mBAAmB,GAAG,CAAvB,CAAN,IAAmC,KAAK,GAAG,mBAA3C;AACD;AACF;AACF;AACF;;AAED,SAAO,OAAO,CAAC,cAAR,CACH,CAAC,KAAD,EAAQ,MAAR,EAAgB,OAAhB,EAAyB,KAAzB,CADG,EAC8B,SAD9B,EACyC,MADzC,CAAP;AAED;AAED,OAAO,IAAM,wBAAwB,GAAiB;AACpD,EAAA,UAAU,EAAE,kBADwC;AAEpD,EAAA,WAAW,EAAE,KAFuC;AAGpD,EAAA,UAAU,EAAE;AAHwC,CAA/C","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { images, dy } = inputs;\n    const { alignCorners } = attrs;\n    assertNotComplex([dy, images], 'resizeBilinearGrad');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [batch, xHeight, xWidth, depth] = images.shape;\n    const [, yHeight, yWidth] = dy.shape;\n    const output = new Float32Array(batch * xHeight * xWidth * depth);\n    // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass and add the\n    // corresponding coefficient from dy to the gradient (with some\n    // interpolation).\n    const effectiveXSize = [\n        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n    const effectiveYSize = [\n        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n    const dyValues = backend.data.get(dy.dataId).values;\n    let offset = 0;\n    for (let b = 0; b < batch; b++) {\n        const bOffset = b * imagesStrides[0];\n        for (let r = 0; r < yHeight; r++) {\n            const dxR = r * heightScale;\n            const topDxRIndex = Math.floor(dxR);\n            const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n            const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n            const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n            const dxRLerp = dxR - topDxRIndex;\n            const inverseDxRLerp = 1.0 - dxRLerp;\n            for (let c = 0; c < yWidth; c++) {\n                const dxC = c * widthScale;\n                const leftDxCIndex = Math.floor(dxC);\n                const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                const dxCLerp = dxC - leftDxCIndex;\n                const inverseDxCLerp = 1.0 - dxCLerp;\n                const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n                const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n                const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n                const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n                const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                for (let d = 0; d < depth; d++) {\n                    const dyVal = dyValues[offset++];\n                    output[topLeftRCOffset + d] +=\n                        dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                    output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                    output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n                    output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport const resizeBilinearGradConfig = {\n    kernelName: ResizeBilinearGrad,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinearGrad\n};\n//# sourceMappingURL=ResizeBilinearGrad.js.map"]},"metadata":{},"sourceType":"module"}