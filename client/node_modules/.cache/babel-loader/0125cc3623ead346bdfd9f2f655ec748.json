{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\n\nasync function inTopKAsync_(predictions, targets, k = 1) {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n  assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' + `but got ${$predictions.rank}`);\n  assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` + `targets rank, but got predictions rank ` + `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` + 'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` + `dimension (${lastDim}), but got ${k}`);\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data(); // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd = [];\n\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({\n        value: vals[i],\n        index: i\n      });\n    }\n\n    valAndInd.sort((a, b) => b.value - a.value);\n    precision[b] = 0;\n\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n\n  if (targets !== $targets) {\n    $targets.dispose();\n  } // Output precision has the same shape as targets.\n\n\n  return tensor(precision, $targets.shape, 'bool');\n}\n\nexport const inTopKAsync = inTopKAsync_;","map":{"version":3,"sources":["../../src/ops/in_top_k.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_(predictions, targets, k = 1) {\n    const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n    const $targets = convertToTensor(targets, 'targets', 'inTopK');\n    assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n        `but got ${$predictions.rank}`);\n    assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` +\n        `targets rank, but got predictions rank ` +\n        `${$predictions.rank} and targets rank ${$targets.rank}`);\n    assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` +\n        'except the last dimension.');\n    const lastDim = $predictions.shape[$predictions.shape.length - 1];\n    assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n        `dimension (${lastDim}), but got ${k}`);\n    const predictionsVals = await $predictions.data();\n    const targetsVals = await $targets.data();\n    // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n    // and look up topK along lastDim.\n    const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n    const precision = getTypedArrayFromDType('bool', batch);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = predictionsVals.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        precision[b] = 0;\n        for (let i = 0; i < k; i++) {\n            if (valAndInd[i].index === targetsVals[b]) {\n                precision[b] = 1;\n                break;\n            }\n        }\n    }\n    if (predictions !== $predictions) {\n        $predictions.dispose();\n    }\n    if (targets !== $targets) {\n        $targets.dispose();\n    }\n    // Output precision has the same shape as targets.\n    return tensor(precision, $targets.shape, 'bool');\n}\nexport const inTopKAsync = inTopKAsync_;\n//# sourceMappingURL=in_top_k.js.map"]},"metadata":{},"sourceType":"module"}