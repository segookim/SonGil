{"ast":null,"code":"import _regeneratorRuntime from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nvar whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport var MathBackendCPU = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendCPU, _KernelBackend);\n\n  var _super = _createSuper(MathBackendCPU);\n\n  function MathBackendCPU() {\n    var _this;\n\n    _classCallCheck(this, MathBackendCPU);\n\n    _this = _super.call(this);\n    _this.blockSize = 48;\n    _this.firstUse = true;\n    _this.data = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n\n  _createClass(MathBackendCPU, [{\n    key: \"nextDataId\",\n    value: function nextDataId() {\n      return MathBackendCPU.nextDataId++;\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (this.firstUse) {\n        this.firstUse = false;\n\n        if (env().get('IS_NODE')) {\n          backend_util.warn('\\n============================\\n' + 'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, which binds to TensorFlow C++, by running ' + 'npm i @tensorflow/tfjs-node, ' + 'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' + 'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' + 'suffix for CUDA) at the start of your program. ' + 'Visit https://github.com/tensorflow/tfjs-node for more details.' + '\\n============================');\n        }\n      }\n\n      var dataId = {\n        id: this.nextDataId()\n      };\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var outId;\n\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        outId = this.write(encodedValues, shape, dtype);\n      } else {\n        outId = this.write(values, shape, dtype);\n      }\n\n      return {\n        dataId: outId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n    /** Return refCount of a `TensorData`. */\n\n  }, {\n    key: \"refCount\",\n    value: function refCount(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        return tensorData.refCount;\n      }\n\n      return 0;\n    }\n    /** Increase refCount of a `TensorData`. */\n\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var tensorData = this.data.get(dataId);\n      tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype, refCount) {\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: refCount\n      });\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.data.numDataIds();\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataId) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.readSync(dataId));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var _this$data$get = this.data.get(dataId),\n          dtype = _this$data$get.dtype,\n          complexTensorInfos = _this$data$get.complexTensorInfos;\n\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      }\n\n      return this.data.get(dataId).values;\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      var decodedData = data;\n\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          decodedData = data.map(function (d) {\n            return util.decodeString(d);\n          });\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n\n      return buffer(t.shape, t.dtype, decodedData);\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(values, shape, dtype) {\n      var dataId = this.write(values, shape, dtype);\n      return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released or memory is not managed in this backend, false if memory is\n     * not cleared.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.data.has(dataId)) {\n        this.data.get(dataId).refCount--;\n\n        if (!force && this.data.get(dataId).refCount > 0) {\n          return false;\n        }\n\n        var _this$data$get2 = this.data.get(dataId),\n            complexTensorInfos = _this$data$get2.complexTensorInfos;\n\n        if (complexTensorInfos != null) {\n          this.disposeData(complexTensorInfos.real.dataId, true);\n          this.disposeData(complexTensorInfos.imag.dataId, true);\n        }\n\n        this.data.delete(dataId);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      this.disposeData(tensorInfo.dataId);\n    }\n  }, {\n    key: \"time\",\n    value: function () {\n      var _time = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(f) {\n        var start, kernelMs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                start = util.now();\n                f();\n                kernelMs = util.now() - start;\n                return _context2.abrupt(\"return\", {\n                  kernelMs: kernelMs\n                });\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function time(_x2) {\n        return _time.apply(this, arguments);\n      }\n\n      return time;\n    }()\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        // Unreliable due to automatic gc. The numbers above are cumulative.\n        unreliable: true,\n        reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n      };\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      assertNotComplex([condition], 'where');\n      var condVals = this.readSync(condition.dataId);\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      return 32;\n    }\n    /** Returns the smallest representable number.  */\n\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return _get(_getPrototypeOf(MathBackendCPU.prototype), \"epsilon\", this).call(this);\n    }\n  }]);\n\n  return MathBackendCPU;\n}(KernelBackend);\nMathBackendCPU.nextDataId = 0;","map":{"version":3,"sources":["../src/backend_cpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nconst whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n    constructor() {\n        super();\n        this.blockSize = 48;\n        this.firstUse = true;\n        this.data = new DataStorage(this, engine());\n    }\n    nextDataId() {\n        return MathBackendCPU.nextDataId++;\n    }\n    write(values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (env().get('IS_NODE')) {\n                backend_util.warn('\\n============================\\n' +\n                    'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        const dataId = { id: this.nextDataId() };\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n        return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n    makeTensorInfo(shape, dtype, values) {\n        let outId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            util.isString(values[0])) {\n            const encodedValues = values.map(d => util.encodeString(d));\n            outId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            outId = this.write(values, shape, dtype);\n        }\n        return { dataId: outId, shape, dtype };\n    }\n    /** Return refCount of a `TensorData`. */\n    refCount(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            return tensorData.refCount;\n        }\n        return 0;\n    }\n    /** Increase refCount of a `TensorData`. */\n    incRef(dataId) {\n        const tensorData = this.data.get(dataId);\n        tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n    decRef(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n        }\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        this.data.set(dataId, { values, dtype, refCount });\n    }\n    numDataIds() {\n        return this.data.numDataIds();\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { dtype, complexTensorInfos } = this.data.get(dataId);\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensorInfos.real.dataId);\n            const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return buffer(t.shape, t.dtype, decodedData);\n    }\n    makeOutput(values, shape, dtype) {\n        const dataId = this.write(values, shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released or memory is not managed in this backend, false if memory is\n     * not cleared.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n    disposeData(dataId, force = false) {\n        if (this.data.has(dataId)) {\n            this.data.get(dataId).refCount--;\n            if (!force && this.data.get(dataId).refCount > 0) {\n                return false;\n            }\n            const { complexTensorInfos } = this.data.get(dataId);\n            if (complexTensorInfos != null) {\n                this.disposeData(complexTensorInfos.real.dataId, true);\n                this.disposeData(complexTensorInfos.imag.dataId, true);\n            }\n            this.data.delete(dataId);\n        }\n        return true;\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        this.disposeData(tensorInfo.dataId);\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    memory() {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    }\n    where(condition) {\n        assertNotComplex([condition], 'where');\n        const condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    }\n    dispose() { }\n    floatPrecision() {\n        return 32;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return super.epsilon();\n    }\n}\nMathBackendCPU.nextDataId = 0;\n//# sourceMappingURL=backend_cpu.js.map"]},"metadata":{},"sourceType":"module"}