{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n  if (real.length !== imag.length) {\n    throw new Error(`Cannot merge real and imag arrays of different lengths. real:` + `${real.length}, imag: ${imag.length}.`);\n  }\n\n  const result = new Float32Array(real.length * 2);\n\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n\n  return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\n\nexport function splitRealAndImagArrays(complex) {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithEvenIndex(complex) {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithOddIndex(complex) {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\n\nexport function getComplexWithIndex(complex, index) {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\n\nexport function assignToTypedArray(data, real, imag, index) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\n\nexport function exponents(n, inverse) {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Make the exponent term used by FFT.\n */\n\nexport function exponent(k, n, inverse) {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {\n    real,\n    imag\n  };\n}","map":{"version":3,"sources":["../../src/backends/complex_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n    if (real.length !== imag.length) {\n        throw new Error(`Cannot merge real and imag arrays of different lengths. real:` +\n            `${real.length}, imag: ${imag.length}.`);\n    }\n    const result = new Float32Array(real.length * 2);\n    for (let i = 0; i < result.length; i += 2) {\n        result[i] = real[i / 2];\n        result[i + 1] = imag[i / 2];\n    }\n    return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex) {\n    const real = new Float32Array(complex.length / 2);\n    const imag = new Float32Array(complex.length / 2);\n    for (let i = 0; i < complex.length; i += 2) {\n        real[i / 2] = complex[i];\n        imag[i / 2] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex) {\n    const len = Math.ceil(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 0; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex) {\n    const len = Math.floor(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 2; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(complex, index) {\n    const real = complex[index * 2];\n    const imag = complex[index * 2 + 1];\n    return { real, imag };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(data, real, imag, index) {\n    data[index * 2] = real;\n    data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(n, inverse) {\n    const real = new Float32Array(n / 2);\n    const imag = new Float32Array(n / 2);\n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n        const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n        real[i] = Math.cos(x);\n        imag[i] = Math.sin(x);\n    }\n    return { real, imag };\n}\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(k, n, inverse) {\n    const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n    const real = Math.cos(x);\n    const imag = Math.sin(x);\n    return { real, imag };\n}\n//# sourceMappingURL=complex_util.js.map"]},"metadata":{},"sourceType":"module"}