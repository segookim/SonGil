{"ast":null,"code":"import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\n\nexport function prepareAndValidate(tensor, indices) {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n\n  if (tensorRank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + ` but the rank was ${tensorRank}.`);\n  }\n\n  if (indicesRank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indicesRank}.`);\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + ` but the dtype was ${indices.dtype}.`);\n  }\n\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1]; // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\n  let nResult = 1;\n\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n  let sliceSize = 1;\n\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize), 1].slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"sources":["../../src/ops/gather_nd_util.ts"],"names":[],"mappings":"AAiBA,SAAQ,cAAR,EAAwB,aAAxB,QAA4C,SAA5C;AAEA;;;;;;;AAOG;;AACH,OAAM,SAAU,kBAAV,CAA6B,MAA7B,EAAiD,OAAjD,EAAoE;AAExE,QAAM,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,MAAhC;AACA,QAAM,WAAW,GAAG,OAAO,CAAC,KAAR,CAAc,MAAlC;;AACA,MAAI,UAAU,GAAG,CAAjB,EAAoB;AAClB,UAAM,IAAI,KAAJ,CACF,4DACA,qBAAqB,UAAU,GAF7B,CAAN;AAGD;;AACD,MAAI,WAAW,GAAG,CAAlB,EAAqB;AACnB,UAAM,IAAI,KAAJ,CACF,8DACA,qBAAqB,WAAW,GAF9B,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,KAAR,KAAkB,OAAtB,EAA+B;AAC7B,UAAM,IAAI,KAAJ,CACF,wDACA,sBAAsB,OAAO,CAAC,KAAK,GAFjC,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,KAAR,CAAc,WAAW,GAAG,CAA5B,IAAiC,UAArC,EAAiD;AAC/C,UAAM,IAAI,KAAJ,CACF,mEACA,GAAG,OAAO,CAAC,KAAR,CAAc,WAAW,GAAG,CAA5B,CAA8B,QAAQ,UAAU,EAFjD,CAAN;AAGD;;AAED,MAAI,aAAa,CAAC,MAAM,CAAC,KAAR,CAAb,KAAgC,CAApC,EAAuC;AACrC,UAAM,IAAI,KAAJ,CACF,uDACA,iBAAiB,MAAM,CAAC,KAAK,GAF3B,CAAN;AAGD;;AAED,QAAM,YAAY,GAAG,OAAO,CAAC,KAA7B;AACA,QAAM,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAA9B,CAhCwE,CAkCxE;AACA;;AACA,MAAI,OAAO,GAAG,CAAd;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAb,GAAsB,CAA1C,EAA6C,EAAE,CAA/C,EAAkD;AAChD,IAAA,OAAO,IAAI,YAAY,CAAC,CAAD,CAAvB;AACD;;AAED,QAAM,UAAU,GAAG,MAAM,CAAC,KAA1B;AAEA,QAAM,WAAW,GAAG,YAAY,CAAC,KAAb,EAApB;AACA,EAAA,WAAW,CAAC,GAAZ;AAEA,MAAI,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAI,CAAC,GAAG,SAAb,EAAwB,CAAC,GAAG,UAA5B,EAAwC,EAAE,CAA1C,EAA6C;AAC3C,IAAA,SAAS,IAAI,UAAU,CAAC,CAAD,CAAvB;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,UAAU,CAAC,CAAD,CAA3B;AACD;;AAED,QAAM,OAAO,GACT,CAAC,GAAG,cAAc,CAAC,MAAM,CAAC,KAAR,CAAd,CAA6B,GAA7B,CAAiC,MAAM,IAAI,MAAM,GAAG,SAApD,CAAJ,EACC,CADD,EACI,KADJ,CACU,CADV,EACa,SADb,CADJ;AAIA,SAAO,CAAC,WAAD,EAAc,OAAd,EAAuB,SAAvB,EAAkC,OAAlC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    const tensorRank = tensor.shape.length;\n    const indicesRank = indices.shape.length;\n    if (tensorRank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensorRank}.`);\n    }\n    if (indicesRank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indicesRank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indicesRank - 1] > tensorRank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n    }\n    if (sizeFromShape(tensor.shape) === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensorRank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n//# sourceMappingURL=gather_nd_util.js.map"]},"metadata":{},"sourceType":"module"}