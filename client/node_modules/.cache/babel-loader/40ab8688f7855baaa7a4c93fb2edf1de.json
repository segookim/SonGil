{"ast":null,"code":"import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n  constructor(shape, exclusive, reverse) {\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = ''; // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = reverse ? 'end + pow2' : 'end - pow2';\n    }\n\n    this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(index) {\n    return (gpgpu, webGLProgram) => {\n      if (this.index == null) {\n        this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n      }\n\n      gpgpu.gl.uniform1f(this.index, index);\n    };\n  }\n\n}\n\nfunction getCoords(rank, name) {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank, name) {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}","map":{"version":3,"sources":["../src/cumsum_gpu.ts"],"names":[],"mappings":"AAkBA,SAAQ,iBAAR,QAAgC,mBAAhC;AAEA,OAAM,MAAO,aAAP,CAAoB;AAQxB,EAAA,WAAA,CAAY,KAAZ,EAA6B,SAA7B,EAAiD,OAAjD,EAAiE;AAPjE,SAAA,aAAA,GAAgB,CAAC,GAAD,CAAhB;AAQE,SAAK,WAAL,GAAmB,KAAnB;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,MAAnB;AACA,UAAM,GAAG,GAAG,SAAS,GAAG,KAAH,GAAW,QAAQ,SAAS,CAAC,IAAD,EAAO,QAAP,CAAgB,GAAjE;AACA,UAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAApB;AACA,QAAI,SAAS,GAAG,EAAhB;AACA,QAAI,SAAS,GAAG,EAAhB,CAN+D,CAO/D;AACA;AACA;;AACA,QAAI,SAAJ,EAAe;AACb,MAAA,SAAS,GAAG,OAAO,GAAG,UAAU,MAAM,GAAG,CAAC,EAAvB,GAA4B,UAA/C;AACA,MAAA,SAAS,GAAG,OAAO,GAAG,SAAH,GAAe,SAAlC;AACD,KAHD,MAGO;AACL,MAAA,SAAS,GAAG,OAAO,GAAG,gBAAgB,MAAM,EAAzB,GAA8B,aAAjD;AACA,MAAA,SAAS,GAAI,OAAO,GAAG,YAAH,GAAkB,YAAtC;AACD;;AAED,SAAK,QAAL,GAAgB;;;UAGV,iBAAiB,CAAC,IAAD,CAAM;oBACb,aAAa,CAAC,IAAD,EAAO,QAAP,CAAgB;sBAC3B,GAAG;;cAEX,SAAS;sBACD,SAAS;YACnB,aAAa,CAAC,IAAD,EAAO,QAAP,CAAgB;wBACjB,SAAS,CAAC,IAAD,EAAO,QAAP,CAAgB;;;;AAI5C,KAdD;AAeD;;AAED,EAAA,kBAAkB,CAAC,KAAD,EAAc;AAC9B,WAAO,CAAC,KAAD,EAAsB,YAAtB,KAAoD;AACzD,UAAI,KAAK,KAAL,IAAc,IAAlB,EAAwB;AACtB,aAAK,KAAL,GAAa,KAAK,CAAC,kBAAN,CAAyB,YAAzB,EAAuC,OAAvC,CAAb;AACD;;AACD,MAAA,KAAK,CAAC,EAAN,CAAS,SAAT,CAAmB,KAAK,KAAxB,EAA+B,KAA/B;AACD,KALD;AAMD;;AAlDuB;;AAqD1B,SAAS,SAAT,CAAmB,IAAnB,EAAiC,IAAjC,EAA6C;AAC3C,MAAI,IAAI,KAAK,CAAb,EAAgB;AACd,WAAO,GAAG,IAAI,EAAd;AACD,GAFD,MAEO,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAG,IAAI,OAAO,IAAI,IAAzB;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAG,IAAI,OAAO,IAAI,OAAO,IAAI,IAApC;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAG,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,IAA/C;AACD,GAFM,MAEA;AACL,UAAM,KAAK,CAAC,2BAA2B,IAAI,uBAAhC,CAAX;AACD;AACF;;AAED,SAAS,aAAT,CAAuB,IAAvB,EAAqC,IAArC,EAAiD;AAC/C,MAAI,IAAI,KAAK,CAAb,EAAgB;AACd,WAAO,GAAG,IAAI,EAAd;AACD,GAFD,MAEO,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAG,IAAI,IAAd;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAG,IAAI,IAAd;AACD,GAFM,MAEA,IAAI,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAG,IAAI,IAAd;AACD,GAFM,MAEA;AACL,UAAM,KAAK,CAAC,2BAA2B,IAAI,uBAAhC,CAAX;AACD;AACF","sourceRoot":"","sourcesContent":["import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n    constructor(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        const rank = shape.length;\n        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n        const length = shape[shape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n    getCustomSetupFunc(index) {\n        return (gpgpu, webGLProgram) => {\n            if (this.index == null) {\n                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(this.index, index);\n        };\n    }\n}\nfunction getCoords(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=cumsum_gpu.js.map"]},"metadata":{},"sourceType":"module"}