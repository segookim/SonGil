{"ast":null,"code":"import _regeneratorRuntime from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\n\nexport var MicrophoneIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(MicrophoneIterator, _LazyIterator);\n\n  var _super = _createSuper(MicrophoneIterator);\n\n  function MicrophoneIterator(microphoneConfig) {\n    var _this;\n\n    _classCallCheck(this, MicrophoneIterator);\n\n    _this = _super.call(this);\n    _this.microphoneConfig = microphoneConfig;\n    _this.isClosed = false;\n    _this.fftSize = microphoneConfig.fftSize || 1024;\n    var fftSizeLog2 = Math.log2(_this.fftSize);\n\n    if (_this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(\"Invalid fftSize: it must be a power of 2 between \" + \"2 to 4 and 2 to 14, but got \".concat(_this.fftSize));\n    }\n\n    _this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    _this.sampleRateHz = microphoneConfig.sampleRateHz;\n    _this.columnTruncateLength = microphoneConfig.columnTruncateLength || _this.fftSize;\n    _this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    _this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    _this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    _this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n\n    if (!_this.includeSpectrogram && !_this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n\n    return _this;\n  }\n\n  _createClass(MicrophoneIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"microphone\";\n    } // Construct a MicrophoneIterator and start the audio stream.\n\n  }, {\n    key: \"start\",\n    value: // Start the audio stream and FFT.\n    function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var ctxConstructor, streamSource;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return navigator.mediaDevices.getUserMedia({\n                  audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,\n                  video: false\n                });\n\n              case 3:\n                this.stream = _context.sent;\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                throw new Error(\"Error thrown while initializing video stream: \".concat(_context.t0.message));\n\n              case 9:\n                if (this.stream) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error('Could not obtain audio from microphone.');\n\n              case 11:\n                ctxConstructor = // tslint:disable-next-line:no-any\n                window.AudioContext || window.webkitAudioContext;\n                this.audioContext = new ctxConstructor();\n\n                if (this.sampleRateHz) {\n                  _context.next = 17;\n                  break;\n                }\n\n                // If sample rate is not provided, use the available sample rate on\n                // device.\n                this.sampleRateHz = this.audioContext.sampleRate;\n                _context.next = 19;\n                break;\n\n              case 17:\n                if (!(this.audioContext.sampleRate !== this.sampleRateHz)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw new Error(\"Mismatch in sampling rate: \" + \"Expected: \".concat(this.sampleRateHz, \"; \") + \"Actual: \".concat(this.audioContext.sampleRate));\n\n              case 19:\n                streamSource = this.audioContext.createMediaStreamSource(this.stream);\n                this.analyser = this.audioContext.createAnalyser();\n                this.analyser.fftSize = this.fftSize * 2;\n                this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n                streamSource.connect(this.analyser);\n                this.freqData = new Float32Array(this.fftSize);\n                this.timeData = new Float32Array(this.fftSize);\n                return _context.abrupt(\"return\");\n\n              case 27:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var spectrogramTensor, waveformTensor, audioDataQueue, freqData, timeData;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.isClosed) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 2:\n                _context2.next = 4;\n                return this.getAudioData();\n\n              case 4:\n                audioDataQueue = _context2.sent;\n\n                if (this.includeSpectrogram) {\n                  freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n                  spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n                }\n\n                if (this.includeWaveform) {\n                  timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n                  waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: {\n                    'spectrogram': spectrogramTensor,\n                    'waveform': waveformTensor\n                  },\n                  done: false\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function next() {\n        return _next.apply(this, arguments);\n      }\n\n      return next;\n    }() // Capture one result from the audio stream, and extract the value from\n    // iterator.next() result.\n\n  }, {\n    key: \"capture\",\n    value: function () {\n      var _capture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.next();\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent.value);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function capture() {\n        return _capture.apply(this, arguments);\n      }\n\n      return capture;\n    }()\n  }, {\n    key: \"getAudioData\",\n    value: function () {\n      var _getAudioData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this2 = this;\n\n        var freqDataQueue, timeDataQueue, currentFrames;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                freqDataQueue = [];\n                timeDataQueue = [];\n                currentFrames = 0;\n                return _context4.abrupt(\"return\", new Promise(function (resolve) {\n                  var intervalID = setInterval(function () {\n                    if (_this2.includeSpectrogram) {\n                      _this2.analyser.getFloatFrequencyData(_this2.freqData); // If the audio stream is initializing, return empty queue.\n\n\n                      if (_this2.freqData[0] === -Infinity) {\n                        resolve({\n                          freqDataQueue: freqDataQueue,\n                          timeDataQueue: timeDataQueue\n                        });\n                      }\n\n                      freqDataQueue.push(_this2.freqData.slice(0, _this2.columnTruncateLength));\n                    }\n\n                    if (_this2.includeWaveform) {\n                      _this2.analyser.getFloatTimeDomainData(_this2.timeData);\n\n                      timeDataQueue.push(_this2.timeData.slice());\n                    } // Clean interval and return when all frames have been collected\n\n\n                    if (++currentFrames === _this2.numFrames) {\n                      clearInterval(intervalID);\n                      resolve({\n                        freqDataQueue: freqDataQueue,\n                        timeDataQueue: timeDataQueue\n                      });\n                    }\n                  }, _this2.fftSize / _this2.sampleRateHz * 1e3);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function getAudioData() {\n        return _getAudioData.apply(this, arguments);\n      }\n\n      return getAudioData;\n    }() // Stop the audio stream and pause the iterator.\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.isClosed) {\n        this.isClosed = true;\n        this.analyser.disconnect();\n        this.audioContext.close();\n\n        if (this.stream != null && this.stream.getTracks().length > 0) {\n          this.stream.getTracks()[0].stop();\n        }\n      }\n    } // Override toArray() function to prevent collecting.\n\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      throw new Error('Can not convert infinite audio stream to array.');\n    } // Return audio sampling rate in Hz\n\n  }, {\n    key: \"getSampleRate\",\n    value: function getSampleRate() {\n      return this.sampleRateHz;\n    }\n  }, {\n    key: \"flattenQueue\",\n    value: function flattenQueue(queue) {\n      var frameSize = queue[0].length;\n      var freqData = new Float32Array(queue.length * frameSize);\n      queue.forEach(function (data, i) {\n        return freqData.set(data, i * frameSize);\n      });\n      return freqData;\n    }\n  }, {\n    key: \"getTensorFromAudioDataArray\",\n    value: function getTensorFromAudioDataArray(freqData, shape) {\n      var vals = new Float32Array(util.sizeFromShape(shape)); // If the data is less than the output shape, the rest is padded with zeros.\n\n      vals.set(freqData, vals.length - freqData.length);\n      return tensor(vals, shape);\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var microphoneConfig,\n            microphoneIterator,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                microphoneConfig = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n\n                if (!env().get('IS_NODE')) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new Error('microphone API is only supported in browser environment.');\n\n              case 3:\n                microphoneIterator = new MicrophoneIterator(microphoneConfig); // Call async function start() to initialize the audio stream.\n\n                _context5.next = 6;\n                return microphoneIterator.start();\n\n              case 6:\n                return _context5.abrupt(\"return\", microphoneIterator);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function create() {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return MicrophoneIterator;\n}(LazyIterator);","map":{"version":3,"sources":["../../src/iterators/microphone_iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator {\n    constructor(microphoneConfig) {\n        super();\n        this.microphoneConfig = microphoneConfig;\n        this.isClosed = false;\n        this.fftSize = microphoneConfig.fftSize || 1024;\n        const fftSizeLog2 = Math.log2(this.fftSize);\n        if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n            !Number.isInteger(fftSizeLog2)) {\n            throw new Error(`Invalid fftSize: it must be a power of 2 between ` +\n                `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n        }\n        this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n        this.sampleRateHz = microphoneConfig.sampleRateHz;\n        this.columnTruncateLength =\n            microphoneConfig.columnTruncateLength || this.fftSize;\n        this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n        this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n        this.includeSpectrogram =\n            microphoneConfig.includeSpectrogram === false ? false : true;\n        this.includeWaveform =\n            microphoneConfig.includeWaveform === true ? true : false;\n        if (!this.includeSpectrogram && !this.includeWaveform) {\n            throw new Error('Both includeSpectrogram and includeWaveform are false. ' +\n                'At least one type of data should be returned.');\n        }\n    }\n    summary() {\n        return `microphone`;\n    }\n    // Construct a MicrophoneIterator and start the audio stream.\n    static async create(microphoneConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('microphone API is only supported in browser environment.');\n        }\n        const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n        // Call async function start() to initialize the audio stream.\n        await microphoneIterator.start();\n        return microphoneIterator;\n    }\n    // Start the audio stream and FFT.\n    async start() {\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                audio: this.audioTrackConstraints == null ? true :\n                    this.audioTrackConstraints,\n                video: false\n            });\n        }\n        catch (e) {\n            throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain audio from microphone.');\n        }\n        const ctxConstructor = \n        // tslint:disable-next-line:no-any\n        window.AudioContext || window.webkitAudioContext;\n        this.audioContext = new ctxConstructor();\n        if (!this.sampleRateHz) {\n            // If sample rate is not provided, use the available sample rate on\n            // device.\n            this.sampleRateHz = this.audioContext.sampleRate;\n        }\n        else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n            throw new Error(`Mismatch in sampling rate: ` +\n                `Expected: ${this.sampleRateHz}; ` +\n                `Actual: ${this.audioContext.sampleRate}`);\n        }\n        const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n        this.analyser = this.audioContext.createAnalyser();\n        this.analyser.fftSize = this.fftSize * 2;\n        this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n        streamSource.connect(this.analyser);\n        this.freqData = new Float32Array(this.fftSize);\n        this.timeData = new Float32Array(this.fftSize);\n        return;\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let spectrogramTensor;\n        let waveformTensor;\n        const audioDataQueue = await this.getAudioData();\n        if (this.includeSpectrogram) {\n            const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n            spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n        }\n        if (this.includeWaveform) {\n            const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n            waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n        }\n        return {\n            value: { 'spectrogram': spectrogramTensor, 'waveform': waveformTensor },\n            done: false\n        };\n    }\n    // Capture one result from the audio stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    async getAudioData() {\n        const freqDataQueue = [];\n        const timeDataQueue = [];\n        let currentFrames = 0;\n        return new Promise(resolve => {\n            const intervalID = setInterval(() => {\n                if (this.includeSpectrogram) {\n                    this.analyser.getFloatFrequencyData(this.freqData);\n                    // If the audio stream is initializing, return empty queue.\n                    if (this.freqData[0] === -Infinity) {\n                        resolve({ freqDataQueue, timeDataQueue });\n                    }\n                    freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n                }\n                if (this.includeWaveform) {\n                    this.analyser.getFloatTimeDomainData(this.timeData);\n                    timeDataQueue.push(this.timeData.slice());\n                }\n                // Clean interval and return when all frames have been collected\n                if (++currentFrames === this.numFrames) {\n                    clearInterval(intervalID);\n                    resolve({ freqDataQueue, timeDataQueue });\n                }\n            }, this.fftSize / this.sampleRateHz * 1e3);\n        });\n    }\n    // Stop the audio stream and pause the iterator.\n    stop() {\n        if (!this.isClosed) {\n            this.isClosed = true;\n            this.analyser.disconnect();\n            this.audioContext.close();\n            if (this.stream != null && this.stream.getTracks().length > 0) {\n                this.stream.getTracks()[0].stop();\n            }\n        }\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite audio stream to array.');\n    }\n    // Return audio sampling rate in Hz\n    getSampleRate() {\n        return this.sampleRateHz;\n    }\n    flattenQueue(queue) {\n        const frameSize = queue[0].length;\n        const freqData = new Float32Array(queue.length * frameSize);\n        queue.forEach((data, i) => freqData.set(data, i * frameSize));\n        return freqData;\n    }\n    getTensorFromAudioDataArray(freqData, shape) {\n        const vals = new Float32Array(util.sizeFromShape(shape));\n        // If the data is less than the output shape, the rest is padded with zeros.\n        vals.set(freqData, vals.length - freqData.length);\n        return tensor(vals, shape);\n    }\n}\n//# sourceMappingURL=microphone_iterator.js.map"]},"metadata":{},"sourceType":"module"}