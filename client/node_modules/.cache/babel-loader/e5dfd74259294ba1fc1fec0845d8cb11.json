{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\n\nexport function printSummary(model, lineLength, positions) {\n  var printFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;\n  var sequentialLike = isModelSequentialLike(model); // Header names for different log elements.\n\n  var toDisplay = ['Layer (type)', 'Output shape', 'Param #'];\n\n  if (sequentialLike) {\n    lineLength = lineLength || 65;\n    positions = positions || [0.45, 0.85, 1];\n  } else {\n    lineLength = lineLength || 98;\n    positions = positions || [0.33, 0.55, 0.67, 1]; // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(function (p) {\n      return Math.floor(lineLength * p);\n    });\n  }\n\n  var relevantNodes;\n\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n\n    for (var depth in model.nodesByDepth) {\n      var _relevantNodes;\n\n      (_relevantNodes = relevantNodes).push.apply(_relevantNodes, _toConsumableArray(model.nodesByDepth[depth]));\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n  var layers = model.layers;\n\n  for (var i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n    }\n\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  } // tslint:disable-next-line:no-any\n\n\n  model.checkTrainableWeightsConsistency();\n  var trainableCount = countTrainableParams(model);\n  var nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n  printFn(\"Total params: \".concat(trainableCount + nonTrainableCount));\n  printFn(\"Trainable params: \".concat(trainableCount));\n  printFn(\"Non-trainable params: \".concat(nonTrainableCount));\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model) {\n  var trainableCount; // tslint:disable:no-any\n\n  if (model.collectedTrainableWeights != null) {\n    trainableCount = countParamsInWeights(model.collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  } // tslint:enable:no-any\n\n\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model) {\n  var sequentialLike = true;\n  var nodesByDepth = [];\n  var nodes = [];\n\n  for (var depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n\n  for (var _i = 0, _nodesByDepth = nodesByDepth; _i < _nodesByDepth.length; _i++) {\n    var depthNodes = _nodesByDepth[_i];\n\n    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n\n    nodes.push.apply(nodes, _toConsumableArray(depthNodes));\n  }\n\n  if (sequentialLike) {\n    // Search for shared layers.\n    var _iterator = _createForOfIteratorHelper(model.layers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var layer = _step.value;\n        var flag = false;\n\n        var _iterator2 = _createForOfIteratorHelper(layer.inboundNodes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var node = _step2.value;\n\n            if (nodes.indexOf(node) !== -1) {\n              if (flag) {\n                sequentialLike = false;\n                break;\n              } else {\n                flag = true;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!sequentialLike) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return sequentialLike;\n}\n\nfunction printRow(fields, positions) {\n  var printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n  var line = '';\n\n  for (var i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n\n  printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\n\n\nfunction printLayerSummary(layer, positions, // tslint:disable-next-line:no-any\nprintFn) {\n  var outputShape;\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  var name = layer.name;\n  var className = layer.getClassName();\n  var fields = [\"\".concat(name, \" (\").concat(className, \")\"), outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\n\n\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, // tslint:disable-next-line:no-any\nprintFn) {\n  var outputShape;\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  var connections = [];\n\n  var _iterator3 = _createForOfIteratorHelper(layer.inboundNodes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var node = _step3.value;\n\n      if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {\n        continue;\n      }\n\n      for (var _i2 = 0; _i2 < node.inboundLayers.length; ++_i2) {\n        var inboundLayer = node.inboundLayers[_i2].name;\n        var inboundLayerIndex = node.nodeIndices[_i2];\n        var inboundTensorIndex = node.tensorIndices[_i2];\n        connections.push(\"\".concat(inboundLayer, \"[\").concat(inboundLayerIndex, \"][\").concat(inboundTensorIndex, \"]\"));\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var name = layer.name;\n  var className = layer.getClassName();\n  var firstConnection = connections.length === 0 ? '' : connections[0];\n  var fields = [\"\".concat(name, \" (\").concat(className, \")\"), outputShape, layer.countParams().toString(), firstConnection];\n  printRow(fields, positions, printFn);\n\n  for (var i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', connections[i]], positions, printFn);\n  }\n}","map":{"version":3,"sources":["../../src/utils/layer_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(model, lineLength, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    const sequentialLike = isModelSequentialLike(model);\n    // Header names for different log elements.\n    const toDisplay = ['Layer (type)', 'Output shape', 'Param #'];\n    if (sequentialLike) {\n        lineLength = lineLength || 65;\n        positions = positions || [0.45, 0.85, 1];\n    }\n    else {\n        lineLength = lineLength || 98;\n        positions = positions || [0.33, 0.55, 0.67, 1];\n        // Header names for different log elements.\n    }\n    if (positions[positions.length - 1] <= 1) {\n        // `positions` is relative. Convert it to absolute positioning.\n        positions = positions.map(p => Math.floor(lineLength * p));\n    }\n    let relevantNodes;\n    if (!sequentialLike) {\n        toDisplay.push('Receives inputs');\n        relevantNodes = [];\n        for (const depth in model.nodesByDepth) {\n            relevantNodes.push(...model.nodesByDepth[depth]);\n        }\n    }\n    printFn('_'.repeat(lineLength));\n    printRow(toDisplay, positions, printFn);\n    printFn('='.repeat(lineLength));\n    const layers = model.layers;\n    for (let i = 0; i < layers.length; ++i) {\n        if (sequentialLike) {\n            printLayerSummary(layers[i], positions, printFn);\n        }\n        else {\n            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n        }\n        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n    }\n    // tslint:disable-next-line:no-any\n    model.checkTrainableWeightsConsistency();\n    const trainableCount = countTrainableParams(model);\n    const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n    printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n    printFn(`Trainable params: ${trainableCount}`);\n    printFn(`Non-trainable params: ${nonTrainableCount}`);\n    printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n    let trainableCount;\n    // tslint:disable:no-any\n    if (model.collectedTrainableWeights != null) {\n        trainableCount =\n            countParamsInWeights(model.collectedTrainableWeights);\n    }\n    else {\n        trainableCount = countParamsInWeights(model.trainableWeights);\n    }\n    // tslint:enable:no-any\n    return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n    let sequentialLike = true;\n    const nodesByDepth = [];\n    const nodes = [];\n    for (const depth in model.nodesByDepth) {\n        nodesByDepth.push(model.nodesByDepth[depth]);\n    }\n    for (const depthNodes of nodesByDepth) {\n        if (depthNodes.length > 1 ||\n            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n            sequentialLike = false;\n            break;\n        }\n        nodes.push(...depthNodes);\n    }\n    if (sequentialLike) {\n        // Search for shared layers.\n        for (const layer of model.layers) {\n            let flag = false;\n            for (const node of layer.inboundNodes) {\n                if (nodes.indexOf(node) !== -1) {\n                    if (flag) {\n                        sequentialLike = false;\n                        break;\n                    }\n                    else {\n                        flag = true;\n                    }\n                }\n            }\n            if (!sequentialLike) {\n                break;\n            }\n        }\n    }\n    return sequentialLike;\n}\nfunction printRow(fields, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    let line = '';\n    for (let i = 0; i < fields.length; ++i) {\n        if (i > 0) {\n            line = line.slice(0, line.length - 1) + ' ';\n        }\n        line += fields[i];\n        line = line.slice(0, positions[i]);\n        line += ' '.repeat(positions[i] - line.length);\n    }\n    printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const fields = [`${name} (${className})`, outputShape, layer.countParams().toString()];\n    printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const connections = [];\n    for (const node of layer.inboundNodes) {\n        if (relevantNodes != null && relevantNodes.length > 0 &&\n            relevantNodes.indexOf(node) === -1) {\n            continue;\n        }\n        for (let i = 0; i < node.inboundLayers.length; ++i) {\n            const inboundLayer = node.inboundLayers[i].name;\n            const inboundLayerIndex = node.nodeIndices[i];\n            const inboundTensorIndex = node.tensorIndices[i];\n            connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n        }\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const firstConnection = connections.length === 0 ? '' : connections[0];\n    const fields = [\n        `${name} (${className})`, outputShape, layer.countParams().toString(),\n        firstConnection\n    ];\n    printRow(fields, positions, printFn);\n    for (let i = 1; i < connections.length; ++i) {\n        printRow(['', '', '', connections[i]], positions, printFn);\n    }\n}\n//# sourceMappingURL=layer_utils.js.map"]},"metadata":{},"sourceType":"module"}