{"ast":null,"code":"import _toConsumableArray from \"/Users/kimkiwoong/songil2/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util'; // Maximum number of values before we decide to show ellipsis.\n\nvar FORMAT_LIMIT_NUM_VALS = 20; // Number of first and last values to show when displaying a, b,...,y, z.\n\nvar FORMAT_NUM_FIRST_LAST_VALS = 3; // Number of significant digits to show.\n\nvar FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  var strides = computeStrides(shape);\n  var padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  var rank = shape.length;\n  var valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  var lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(\"  dtype: \".concat(dtype));\n    lines.push(\"  rank: \".concat(rank));\n    lines.push(\"  shape: [\".concat(shape, \"]\"));\n    lines.push(\"  values:\");\n  }\n\n  lines.push(valsLines.map(function (l) {\n    return '    ' + l;\n  }).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  var n = sizeFromShape(shape);\n  var numCols = strides[strides.length - 1];\n  var padPerCol = new Array(numCols).fill(0);\n  var rank = shape.length;\n  var valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (var row = 0; row < n / numCols; row++) {\n      var offset = row * numCols;\n\n      for (var j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad, dtype) {\n  var valStr;\n\n  if (Array.isArray(val)) {\n    valStr = \"\".concat(parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS)), \" + \") + \"\".concat(parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS)), \"j\");\n  } else if (isString(val)) {\n    valStr = \"'\".concat(val, \"'\");\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol) {\n  var isLast = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var storagePerElement = dtype === 'complex64' ? 2 : 1;\n  var size = shape[0];\n  var rank = shape.length;\n\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      var complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      var firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      var firstVals = Array.from(vals.slice(0, firstValsSize));\n      var lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n\n      return ['[' + firstVals.map(function (x, i) {\n        return valToString(x, padPerCol[i], dtype);\n      }).join(', ') + ', ..., ' + lastVals.map(function (x, i) {\n        return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype);\n      }).join(', ') + ']'];\n    }\n\n    var displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map(function (x, i) {\n      return valToString(x, padPerCol[i], dtype);\n    }).join(', ') + ']'];\n  } // The array is rank 2 or more.\n\n\n  var subshape = shape.slice(1);\n  var substrides = strides.slice(1);\n  var stride = strides[0] * storagePerElement;\n  var lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      var start = i * stride;\n      var end = start + stride;\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false\n      /* isLast */\n      )));\n    }\n\n    lines.push('...');\n\n    for (var _i = size - FORMAT_NUM_FIRST_LAST_VALS; _i < size; _i++) {\n      var _start = _i * stride;\n\n      var _end = _start + stride;\n\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(_start, _end), subshape, dtype, substrides, padPerCol, _i === size - 1\n      /* isLast */\n      )));\n    }\n  } else {\n    for (var _i2 = 0; _i2 < size; _i2++) {\n      var _start2 = _i2 * stride;\n\n      var _end2 = _start2 + stride;\n\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(_start2, _end2), subshape, dtype, substrides, padPerCol, _i2 === size - 1\n      /* isLast */\n      )));\n    }\n  }\n\n  var sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (var _i3 = 1; _i3 < lines.length - 1; _i3++) {\n    lines[_i3] = ' ' + lines[_i3] + sep;\n  }\n\n  var newLineSep = ',\\n';\n\n  for (var _i4 = 2; _i4 < rank; _i4++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals) {\n  var complexTuples = [];\n\n  for (var i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n\n  return complexTuples;\n}","map":{"version":3,"sources":["../src/tensor_format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n//# sourceMappingURL=tensor_format.js.map"]},"metadata":{},"sourceType":"module"}