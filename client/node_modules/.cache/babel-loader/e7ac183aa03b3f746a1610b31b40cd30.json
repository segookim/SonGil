{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\n\nexport function fftBatch(input, inverse, cpuBackend) {\n  var inputShape = input.shape;\n  var batch = inputShape[0];\n  var innerDim = inputShape[1];\n  var inputVals = cpuBackend.data.get(input.dataId);\n  var real2D = inputVals.complexTensorInfos.real;\n  var imag2D = inputVals.complexTensorInfos.imag; // Collects real and imaginary values separately.\n\n  var resultShape = [batch, innerDim];\n  var resultSize = util.sizeFromShape(resultShape);\n  var resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  var resultImag = util.getTypedArrayFromDType('float32', resultSize);\n\n  for (var b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    var r = slice({\n      inputs: {\n        x: real2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    var i = slice({\n      inputs: {\n        x: imag2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n\n    var _input = complex({\n      inputs: {\n        real: r,\n        imag: i\n      },\n      backend: cpuBackend\n    }); // Run FFT by batch element.\n\n\n    var _fftImpl = fftImpl(_input, inverse, cpuBackend),\n        _real = _fftImpl.real,\n        _imag = _fftImpl.imag;\n\n    var res = backend_util.mergeRealAndImagArrays(_real, _imag);\n\n    for (var d = 0; d < innerDim; d++) {\n      var c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(_input);\n  }\n\n  var $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  var $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n  var result = complex({\n    inputs: {\n      real: $realInfo,\n      imag: $imagInfo\n    },\n    backend: cpuBackend\n  });\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n  return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n  var inputSize = util.sizeFromShape(input.shape);\n  var inputVals = cpuBackend.data.get(input.dataId);\n  var realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n  var imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n\n  if (isExponentOf2(inputSize)) {\n    var result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n    var resultShape = [input.shape[0], input.shape[1]];\n\n    if (inverse) {\n      var realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      var imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n      var sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n      var sizeInfoCopy = identity({\n        inputs: {\n          x: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      var divRealInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: realInfo,\n          b: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      var divImagInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: imagInfo,\n          b: sizeInfoCopy\n        },\n        backend: cpuBackend\n      });\n      var divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n      var divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n      return {\n        real: divRealVals,\n        imag: divImagVals\n      };\n    }\n\n    return result;\n  } else {\n    var data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    var rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\n\nfunction isExponentOf2(size) {\n  return (size & size - 1) === 0;\n} // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n\n\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n  if (size === 1) {\n    return {\n      real: realVals,\n      imag: imagVals\n    };\n  }\n\n  var data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n  var half = size / 2;\n  var evenComplex = backend_util.complexWithEvenIndex(data);\n  var evenRealVals = evenComplex.real;\n  var evenImagVals = evenComplex.imag;\n  var evenShape = [evenRealVals.length];\n  var evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  var evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n  var evenTensorInfo = complex({\n    inputs: {\n      real: evenRealInfo,\n      imag: evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  var oddComplex = backend_util.complexWithOddIndex(data);\n  var oddRealVals = oddComplex.real;\n  var oddImagVals = oddComplex.imag;\n  var oddShape = [oddRealVals.length];\n  var oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  var oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n  var oddTensorInfo = complex({\n    inputs: {\n      real: oddRealInfo,\n      imag: oddImagInfo\n    },\n    backend: cpuBackend\n  }); // Recursive call for half part of original input.\n\n  var $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n  var $evenRealVals = $evenComplex.real;\n  var $evenImagVals = $evenComplex.imag;\n  var $evenShape = [$evenRealVals.length];\n  var $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  var $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n  var $evenTensorInfo = complex({\n    inputs: {\n      real: $evenRealInfo,\n      imag: $evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  var $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n  var $oddRealVals = $oddComplex.real;\n  var $oddImagVals = $oddComplex.imag;\n  var $oddShape = [$oddRealVals.length];\n  var $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  var $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n  var $oddTensorInfo = complex({\n    inputs: {\n      real: $oddRealInfo,\n      imag: $oddImagInfo\n    },\n    backend: cpuBackend\n  });\n  var e = backend_util.exponents(size, inverse);\n  var eShape = [e.real.length];\n  var eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  var eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n  var complexInfo = complex({\n    inputs: {\n      real: eRealInfo,\n      imag: eImagInfo\n    },\n    backend: cpuBackend\n  });\n  var exponentInfo = multiply({\n    inputs: {\n      a: complexInfo,\n      b: $oddTensorInfo\n    },\n    backend: cpuBackend\n  });\n  var addPart = add({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  var subPart = sub({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  var addPartReal = real({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  var subPartReal = real({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  var addPartImag = imag({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  var subPartImag = imag({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  var $real = concat({\n    inputs: [addPartReal, subPartReal],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  var $imag = concat({\n    inputs: [addPartImag, subPartImag],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  var $realVals = cpuBackend.data.get($real.dataId).values;\n  var $imagVals = cpuBackend.data.get($imag.dataId).values;\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n  return {\n    real: $realVals,\n    imag: $imagVals\n  };\n} // Calculate fourier transform by multplying sinusoid matrix.\n\n\nfunction fourierTransformByMatmul(data, size, inverse) {\n  var ret = new Float32Array(size * 2); // TODO: Use matmul instead once it supports complex64 type.\n\n  for (var r = 0; r < size; r++) {\n    var _real2 = 0.0;\n    var _imag2 = 0.0;\n\n    for (var c = 0; c < size; c++) {\n      var e = backend_util.exponent(r * c, size, inverse);\n      var term = backend_util.getComplexWithIndex(data, c);\n      _real2 += term.real * e.real - term.imag * e.imag;\n      _imag2 += term.real * e.imag + term.imag * e.real;\n    }\n\n    if (inverse) {\n      _real2 /= size;\n      _imag2 /= size;\n    }\n\n    backend_util.assignToTypedArray(ret, _real2, _imag2, r);\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["../../src/utils/fft_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\nexport function fftBatch(input, inverse, cpuBackend) {\n    const inputShape = input.shape;\n    const batch = inputShape[0];\n    const innerDim = inputShape[1];\n    const inputVals = cpuBackend.data.get(input.dataId);\n    const real2D = inputVals.complexTensorInfos.real;\n    const imag2D = inputVals.complexTensorInfos.imag;\n    // Collects real and imaginary values separately.\n    const resultShape = [batch, innerDim];\n    const resultSize = util.sizeFromShape(resultShape);\n    const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n    const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n    for (let b = 0; b < batch; b++) {\n        // TODO: Support slice ops for complex type.\n        const r = slice({\n            inputs: { x: real2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        const i = slice({\n            inputs: { x: imag2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        const input = complex({ inputs: { real: r, imag: i }, backend: cpuBackend });\n        // Run FFT by batch element.\n        const { real, imag } = fftImpl(input, inverse, cpuBackend);\n        const res = backend_util.mergeRealAndImagArrays(real, imag);\n        for (let d = 0; d < innerDim; d++) {\n            const c = backend_util.getComplexWithIndex(res, d);\n            resultReal[b * innerDim + d] = c.real;\n            resultImag[b * innerDim + d] = c.imag;\n        }\n        cpuBackend.disposeIntermediateTensorInfo(r);\n        cpuBackend.disposeIntermediateTensorInfo(i);\n        cpuBackend.disposeIntermediateTensorInfo(input);\n    }\n    const $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n    const $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n    const result = complex({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });\n    cpuBackend.disposeIntermediateTensorInfo($realInfo);\n    cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n    return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n    const inputSize = util.sizeFromShape(input.shape);\n    const inputVals = cpuBackend.data.get(input.dataId);\n    const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n    const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n    if (isExponentOf2(inputSize)) {\n        const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n        const resultShape = [input.shape[0], input.shape[1]];\n        if (inverse) {\n            const realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n            const imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n            const sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n            const sizeInfoCopy = identity({ inputs: { x: sizeInfo }, backend: cpuBackend });\n            const divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });\n            const divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });\n            const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n            const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n            cpuBackend.disposeIntermediateTensorInfo(realInfo);\n            cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n            cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n            cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n            return { real: divRealVals, imag: divImagVals };\n        }\n        return result;\n    }\n    else {\n        const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n        const rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n        return backend_util.splitRealAndImagArrays(rawOutput);\n    }\n}\nfunction isExponentOf2(size) {\n    return (size & size - 1) === 0;\n}\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n    if (size === 1) {\n        return { real: realVals, imag: imagVals };\n    }\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    const half = size / 2;\n    const evenComplex = backend_util.complexWithEvenIndex(data);\n    const evenRealVals = evenComplex.real;\n    const evenImagVals = evenComplex.imag;\n    const evenShape = [evenRealVals.length];\n    const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n    const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n    const evenTensorInfo = complex({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });\n    const oddComplex = backend_util.complexWithOddIndex(data);\n    const oddRealVals = oddComplex.real;\n    const oddImagVals = oddComplex.imag;\n    const oddShape = [oddRealVals.length];\n    const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n    const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n    const oddTensorInfo = complex({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });\n    // Recursive call for half part of original input.\n    const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n    const $evenRealVals = $evenComplex.real;\n    const $evenImagVals = $evenComplex.imag;\n    const $evenShape = [$evenRealVals.length];\n    const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n    const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n    const $evenTensorInfo = complex({\n        inputs: { real: $evenRealInfo, imag: $evenImagInfo },\n        backend: cpuBackend\n    });\n    const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n    const $oddRealVals = $oddComplex.real;\n    const $oddImagVals = $oddComplex.imag;\n    const $oddShape = [$oddRealVals.length];\n    const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n    const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n    const $oddTensorInfo = complex({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });\n    const e = backend_util.exponents(size, inverse);\n    const eShape = [e.real.length];\n    const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n    const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n    const complexInfo = complex({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });\n    const exponentInfo = multiply({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });\n    const addPart = add({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    const subPart = sub({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    const addPartReal = real({ inputs: { input: addPart }, backend: cpuBackend });\n    const subPartReal = real({ inputs: { input: subPart }, backend: cpuBackend });\n    const addPartImag = imag({ inputs: { input: addPart }, backend: cpuBackend });\n    const subPartImag = imag({ inputs: { input: subPart }, backend: cpuBackend });\n    const $real = concat({\n        inputs: [addPartReal, subPartReal],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    const $imag = concat({\n        inputs: [addPartImag, subPartImag],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    const $realVals = cpuBackend.data.get($real.dataId).values;\n    const $imagVals = cpuBackend.data.get($imag.dataId).values;\n    cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n    cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n    cpuBackend.disposeIntermediateTensorInfo(addPart);\n    cpuBackend.disposeIntermediateTensorInfo(subPart);\n    cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n    cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n    cpuBackend.disposeIntermediateTensorInfo($real);\n    cpuBackend.disposeIntermediateTensorInfo($imag);\n    return { real: $realVals, imag: $imagVals };\n}\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(data, size, inverse) {\n    const ret = new Float32Array(size * 2);\n    // TODO: Use matmul instead once it supports complex64 type.\n    for (let r = 0; r < size; r++) {\n        let real = 0.0;\n        let imag = 0.0;\n        for (let c = 0; c < size; c++) {\n            const e = backend_util.exponent(r * c, size, inverse);\n            const term = backend_util.getComplexWithIndex(data, c);\n            real += term.real * e.real - term.imag * e.imag;\n            imag += term.real * e.imag + term.imag * e.real;\n        }\n        if (inverse) {\n            real /= size;\n            imag /= size;\n        }\n        backend_util.assignToTypedArray(ret, real, imag, r);\n    }\n    return ret;\n}\n//# sourceMappingURL=fft_utils.js.map"]},"metadata":{},"sourceType":"module"}