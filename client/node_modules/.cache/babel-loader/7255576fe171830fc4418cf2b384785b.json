{"ast":null,"code":"import * as losses from './losses';\nimport * as metrics from './metrics';\n/**\n * Binary accuracy metric function.\n *\n * `yTrue` and `yPred` can have 0-1 values. Example:\n * ```js\n * const x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);\n * const y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * `yTrue` and `yPred` can also have floating-number values between 0 and 1, in\n * which case the values will be thresholded at 0.5 to yield 0-1 values (i.e.,\n * a value >= 0.5 and <= 1.0 is interpreted as 1.\n * )\n * Example:\n * ```js\n * const x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);\n * const y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function binaryAccuracy(yTrue, yPred) {\n  return metrics.binaryAccuracy(yTrue, yPred);\n}\n/**\n * Binary crossentropy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0], [1], [1], [1]]);\n * const y = tf.tensor2d([[0], [0], [0.5], [1]]);\n * const crossentropy = tf.metrics.binaryCrossentropy(x, y);\n * crossentropy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction, probabilities for the `1` case.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function binaryCrossentropy(yTrue, yPred) {\n  return metrics.binaryCrossentropy(yTrue, yPred);\n}\n/**\n * Sparse categorical accuracy metric function.\n *\n * Example:\n * ```js\n *\n * const yTrue = tf.tensor1d([1, 1, 2, 2, 0]);\n * const yPred = tf.tensor2d(\n *      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);\n * const crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);\n * crossentropy.print();\n * ```\n *\n * @param yTrue True labels: indices.\n * @param yPred Predicted probabilities or logits.\n * @returns Accuracy tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n  return metrics.sparseCategoricalAccuracy(yTrue, yPred);\n}\n/**\n * Categorical accuracy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);\n * const y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);\n * const accuracy = tf.metrics.categoricalAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth: one-hot encoding of categories.\n * @param yPred Binary Tensor of prediction: probabilities or logits for the\n *   same categories as in `yTrue`.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function categoricalAccuracy(yTrue, yPred) {\n  return metrics.categoricalAccuracy(yTrue, yPred);\n}\n/**\n * Categorical crossentropy between an output tensor and a target tensor.\n *\n * @param target A tensor of the same shape as `output`.\n * @param output A tensor resulting from a softmax (unless `fromLogits` is\n *  `true`, in which case `output` is expected to be the logits).\n * @param fromLogits Boolean, whether `output` is the result of a softmax, or is\n *   a tensor of logits.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function categoricalCrossentropy(yTrue, yPred) {\n  return metrics.categoricalCrossentropy(yTrue, yPred);\n}\n/**\n * Computes the precision of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const precision = tf.metrics.precision(x, y);\n * precision.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Precision Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function precision(yTrue, yPred) {\n  return metrics.precision(yTrue, yPred);\n}\n/**\n * Computes the recall of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const recall = tf.metrics.recall(x, y);\n * recall.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Recall Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function recall(yTrue, yPred) {\n  return metrics.recall(yTrue, yPred);\n}\n/**\n * Loss or metric function: Cosine proximity.\n *\n * Mathematically, cosine proximity is defined as:\n *   `-sum(l2Normalize(yTrue) * l2Normalize(yPred))`,\n * wherein `l2Normalize()` normalizes the L2 norm of the input to 1 and `*`\n * represents element-wise multiplication.\n *\n * ```js\n * const yTrue = tf.tensor2d([[1, 0], [1, 0]]);\n * const yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);\n * const proximity = tf.metrics.cosineProximity(yTrue, yPred);\n * proximity.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Cosine proximity Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function cosineProximity(yTrue, yPred) {\n  return losses.cosineProximity(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean absolute error.\n *\n * Mathematically, mean absolute error is defined as:\n *   `mean(abs(yPred - yTrue))`,\n * wherein the `mean` is applied over feature dimensions.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);\n * const yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);\n * const mse = tf.metrics.meanAbsoluteError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function meanAbsoluteError(yTrue, yPred) {\n  return losses.meanAbsoluteError(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean absolute percentage error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [10, 20]]);\n * const yPred = tf.tensor2d([[0, 1], [11, 24]]);\n * const mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MAPE`, `tf.metrics.mape`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute percentage error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function meanAbsolutePercentageError(yTrue, yPred) {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\nexport function MAPE(yTrue, yPred) {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\nexport function mape(yTrue, yPred) {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean squared error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [3, 4]]);\n * const yPred = tf.tensor2d([[0, 1], [-3, -4]]);\n * const mse = tf.metrics.meanSquaredError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MSE`, `tf.metrics.mse`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean squared error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function meanSquaredError(yTrue, yPred) {\n  return losses.meanSquaredError(yTrue, yPred);\n}\nexport function MSE(yTrue, yPred) {\n  return losses.meanSquaredError(yTrue, yPred);\n}\nexport function mse(yTrue, yPred) {\n  return losses.meanSquaredError(yTrue, yPred);\n}","map":{"version":3,"sources":["../src/exports_metrics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as losses from './losses';\nimport * as metrics from './metrics';\n/**\n * Binary accuracy metric function.\n *\n * `yTrue` and `yPred` can have 0-1 values. Example:\n * ```js\n * const x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);\n * const y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * `yTrue` and `yPred` can also have floating-number values between 0 and 1, in\n * which case the values will be thresholded at 0.5 to yield 0-1 values (i.e.,\n * a value >= 0.5 and <= 1.0 is interpreted as 1.\n * )\n * Example:\n * ```js\n * const x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);\n * const y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function binaryAccuracy(yTrue, yPred) {\n    return metrics.binaryAccuracy(yTrue, yPred);\n}\n/**\n * Binary crossentropy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0], [1], [1], [1]]);\n * const y = tf.tensor2d([[0], [0], [0.5], [1]]);\n * const crossentropy = tf.metrics.binaryCrossentropy(x, y);\n * crossentropy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction, probabilities for the `1` case.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function binaryCrossentropy(yTrue, yPred) {\n    return metrics.binaryCrossentropy(yTrue, yPred);\n}\n/**\n * Sparse categorical accuracy metric function.\n *\n * Example:\n * ```js\n *\n * const yTrue = tf.tensor1d([1, 1, 2, 2, 0]);\n * const yPred = tf.tensor2d(\n *      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);\n * const crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);\n * crossentropy.print();\n * ```\n *\n * @param yTrue True labels: indices.\n * @param yPred Predicted probabilities or logits.\n * @returns Accuracy tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n    return metrics.sparseCategoricalAccuracy(yTrue, yPred);\n}\n/**\n * Categorical accuracy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);\n * const y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);\n * const accuracy = tf.metrics.categoricalAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth: one-hot encoding of categories.\n * @param yPred Binary Tensor of prediction: probabilities or logits for the\n *   same categories as in `yTrue`.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function categoricalAccuracy(yTrue, yPred) {\n    return metrics.categoricalAccuracy(yTrue, yPred);\n}\n/**\n * Categorical crossentropy between an output tensor and a target tensor.\n *\n * @param target A tensor of the same shape as `output`.\n * @param output A tensor resulting from a softmax (unless `fromLogits` is\n *  `true`, in which case `output` is expected to be the logits).\n * @param fromLogits Boolean, whether `output` is the result of a softmax, or is\n *   a tensor of logits.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function categoricalCrossentropy(yTrue, yPred) {\n    return metrics.categoricalCrossentropy(yTrue, yPred);\n}\n/**\n * Computes the precision of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const precision = tf.metrics.precision(x, y);\n * precision.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Precision Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function precision(yTrue, yPred) {\n    return metrics.precision(yTrue, yPred);\n}\n/**\n * Computes the recall of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const recall = tf.metrics.recall(x, y);\n * recall.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Recall Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function recall(yTrue, yPred) {\n    return metrics.recall(yTrue, yPred);\n}\n/**\n * Loss or metric function: Cosine proximity.\n *\n * Mathematically, cosine proximity is defined as:\n *   `-sum(l2Normalize(yTrue) * l2Normalize(yPred))`,\n * wherein `l2Normalize()` normalizes the L2 norm of the input to 1 and `*`\n * represents element-wise multiplication.\n *\n * ```js\n * const yTrue = tf.tensor2d([[1, 0], [1, 0]]);\n * const yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);\n * const proximity = tf.metrics.cosineProximity(yTrue, yPred);\n * proximity.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Cosine proximity Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function cosineProximity(yTrue, yPred) {\n    return losses.cosineProximity(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean absolute error.\n *\n * Mathematically, mean absolute error is defined as:\n *   `mean(abs(yPred - yTrue))`,\n * wherein the `mean` is applied over feature dimensions.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);\n * const yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);\n * const mse = tf.metrics.meanAbsoluteError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function meanAbsoluteError(yTrue, yPred) {\n    return losses.meanAbsoluteError(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean absolute percentage error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [10, 20]]);\n * const yPred = tf.tensor2d([[0, 1], [11, 24]]);\n * const mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MAPE`, `tf.metrics.mape`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute percentage error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function meanAbsolutePercentageError(yTrue, yPred) {\n    return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\nexport function MAPE(yTrue, yPred) {\n    return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\nexport function mape(yTrue, yPred) {\n    return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean squared error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [3, 4]]);\n * const yPred = tf.tensor2d([[0, 1], [-3, -4]]);\n * const mse = tf.metrics.meanSquaredError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MSE`, `tf.metrics.mse`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean squared error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function meanSquaredError(yTrue, yPred) {\n    return losses.meanSquaredError(yTrue, yPred);\n}\nexport function MSE(yTrue, yPred) {\n    return losses.meanSquaredError(yTrue, yPred);\n}\nexport function mse(yTrue, yPred) {\n    return losses.meanSquaredError(yTrue, yPred);\n}\n//# sourceMappingURL=exports_metrics.js.map"]},"metadata":{},"sourceType":"module"}