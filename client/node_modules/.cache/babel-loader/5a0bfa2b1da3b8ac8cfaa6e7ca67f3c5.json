{"ast":null,"code":"import _slicedToArray from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, CropAndResize, util } from '@tensorflow/tfjs-core';\nexport function cropAndResize(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var image = inputs.image,\n      boxes = inputs.boxes,\n      boxInd = inputs.boxInd;\n  var cropSize = attrs.cropSize,\n      method = attrs.method,\n      extrapolationValue = attrs.extrapolationValue;\n\n  var _image$shape = _slicedToArray(image.shape, 4),\n      batch = _image$shape[0],\n      imageHeight = _image$shape[1],\n      imageWidth = _image$shape[2],\n      numChannels = _image$shape[3];\n\n  var numBoxes = boxes.shape[0];\n\n  var _cropSize = _slicedToArray(cropSize, 2),\n      cropHeight = _cropSize[0],\n      cropWidth = _cropSize[1];\n\n  var output = buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n  var boxVals = backend.data.get(boxes.dataId).values;\n  var boxIndVals = backend.data.get(boxInd.dataId).values;\n  var imageVals = backend.data.get(image.dataId).values;\n  var inStride = util.computeStrides(image.shape); // to calculate flat indexes into image\n\n  var outStride = util.computeStrides(output.shape); // to calculate flat indexes into output\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n\n  for (var b = 0; b < numBoxes; b++) {\n    var startInd = b * 4;\n    var y1 = boxVals[startInd];\n    var x1 = boxVals[startInd + 1];\n    var y2 = boxVals[startInd + 2];\n    var x2 = boxVals[startInd + 3];\n    var bInd = boxIndVals[b];\n\n    if (bInd >= batch) {\n      continue;\n    }\n\n    var heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n    var widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n\n    for (var y = 0; y < cropHeight; y++) {\n      var yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);\n\n      if (yInd < 0 || yInd > imageHeight - 1) {\n        for (var x = 0; x < cropWidth; x++) {\n          for (var c = 0; c < numChannels; c++) {\n            var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = extrapolationValue;\n          }\n        }\n\n        continue;\n      }\n\n      if (method === 'bilinear') {\n        var topInd = Math.floor(yInd);\n        var bottomInd = Math.ceil(yInd);\n        var yLerp = yInd - topInd;\n\n        for (var _x = 0; _x < cropWidth; _x++) {\n          var xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + _x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (var _c = 0; _c < numChannels; _c++) {\n              var _ind = _c + _x * outStride[2] + y * outStride[1] + b * outStride[0];\n\n              output.values[_ind] = extrapolationValue;\n            }\n\n            continue;\n          }\n\n          var leftInd = Math.floor(xInd);\n          var rightInd = Math.ceil(xInd);\n          var xLerp = xInd - leftInd;\n\n          for (var _c2 = 0; _c2 < numChannels; _c2++) {\n            var _ind2 = _c2 + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n\n            var topLeft = imageVals[_ind2];\n            _ind2 = _c2 + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n            var topRight = imageVals[_ind2];\n            _ind2 = _c2 + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n            var bottomLeft = imageVals[_ind2];\n            _ind2 = _c2 + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n            var bottomRight = imageVals[_ind2];\n            var top = topLeft + (topRight - topLeft) * xLerp;\n            var bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n            _ind2 = _c2 + _x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[_ind2] = top + (bottom - top) * yLerp;\n          }\n        }\n      } else {\n        // method == \"nearest\"\n        for (var _x2 = 0; _x2 < cropWidth; ++_x2) {\n          var _xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + _x2 * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (_xInd < 0 || _xInd > imageWidth - 1) {\n            for (var _c3 = 0; _c3 < numChannels; _c3++) {\n              var _ind3 = _c3 + _x2 * outStride[2] + y * outStride[1] + b * outStride[0];\n\n              output.values[_ind3] = extrapolationValue;\n            }\n\n            continue;\n          }\n\n          var closestX = Math.round(_xInd);\n          var closestY = Math.round(yInd);\n\n          for (var _c4 = 0; _c4 < numChannels; _c4++) {\n            var inInd = _c4 + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];\n            var outInd = _c4 + _x2 * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[outInd] = imageVals[inInd];\n          }\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\nexport var cropAndResizeConfig = {\n  kernelName: CropAndResize,\n  backendName: 'cpu',\n  kernelFunc: cropAndResize\n};","map":{"version":3,"sources":["../../src/kernels/CropAndResize.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAR,EAAgB,aAAhB,EAA0H,IAA1H,QAAqI,uBAArI;AAIA,OAAM,SAAU,aAAV,CAAwB,IAAxB,EAIL;AAAA,MACQ,MADR,GACkC,IADlC,CACQ,MADR;AAAA,MACgB,OADhB,GACkC,IADlC,CACgB,OADhB;AAAA,MACyB,KADzB,GACkC,IADlC,CACyB,KADzB;AAAA,MAEQ,KAFR,GAEgC,MAFhC,CAEQ,KAFR;AAAA,MAEe,KAFf,GAEgC,MAFhC,CAEe,KAFf;AAAA,MAEsB,MAFtB,GAEgC,MAFhC,CAEsB,MAFtB;AAAA,MAGQ,QAHR,GAGgD,KAHhD,CAGQ,QAHR;AAAA,MAGkB,MAHlB,GAGgD,KAHhD,CAGkB,MAHlB;AAAA,MAG0B,kBAH1B,GAGgD,KAHhD,CAG0B,kBAH1B;;AAAA,oCAKuD,KAAK,CAAC,KAL7D;AAAA,MAKQ,KALR;AAAA,MAKe,WALf;AAAA,MAK4B,UAL5B;AAAA,MAKwC,WALxC;;AAMC,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAjB;;AAND,iCAQiC,QARjC;AAAA,MAQQ,UARR;AAAA,MAQoB,SARpB;;AASC,MAAM,MAAM,GACR,MAAM,CAAC,CAAC,QAAD,EAAW,UAAX,EAAuB,SAAvB,EAAkC,WAAlC,CAAD,EAAiD,SAAjD,CADV;AAGA,MAAM,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,KAAK,CAAC,MAAvB,EAA+B,MAA/C;AACA,MAAM,UAAU,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,MAAM,CAAC,MAAxB,EAAgC,MAAnD;AACA,MAAM,SAAS,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,KAAK,CAAC,MAAvB,EAA+B,MAAjD;AAEA,MAAM,QAAQ,GACV,IAAI,CAAC,cAAL,CAAoB,KAAK,CAAC,KAA1B,CADJ,CAhBD,CAiBwC;;AACvC,MAAM,SAAS,GAAG,IAAI,CAAC,cAAL,CACd,MAAM,CAAC,KADO,CAAlB,CAlBD,CAmBqB;AAEpB;AACA;AACA;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AACjC,QAAM,QAAQ,GAAG,CAAC,GAAG,CAArB;AACA,QAAM,EAAE,GAAG,OAAO,CAAC,QAAD,CAAlB;AACA,QAAM,EAAE,GAAG,OAAO,CAAC,QAAQ,GAAG,CAAZ,CAAlB;AACA,QAAM,EAAE,GAAG,OAAO,CAAC,QAAQ,GAAG,CAAZ,CAAlB;AACA,QAAM,EAAE,GAAG,OAAO,CAAC,QAAQ,GAAG,CAAZ,CAAlB;AAEA,QAAM,IAAI,GAAW,UAAU,CAAC,CAAD,CAA/B;;AACA,QAAI,IAAI,IAAI,KAAZ,EAAmB;AACjB;AACD;;AAED,QAAM,WAAW,GACZ,UAAU,GAAG,CAAd,GAAmB,CAAC,EAAE,GAAG,EAAN,KAAa,WAAW,GAAG,CAA3B,KAAiC,UAAU,GAAG,CAA9C,CAAnB,GAAsE,CAD1E;AAEA,QAAM,UAAU,GACX,SAAS,GAAG,CAAb,GAAkB,CAAC,EAAE,GAAG,EAAN,KAAa,UAAU,GAAG,CAA1B,KAAgC,SAAS,GAAG,CAA5C,CAAlB,GAAmE,CADvE;;AAGA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,UAAM,IAAI,GAAY,UAAU,GAAG,CAAd,GACjB,EAAE,IAAI,WAAW,GAAG,CAAlB,CAAF,GAAyB,CAAC,GAAI,WADb,GAEjB,OAAO,EAAE,GAAG,EAAZ,KAAmB,WAAW,GAAG,CAAjC,CAFJ;;AAIA,UAAI,IAAI,GAAG,CAAP,IAAY,IAAI,GAAG,WAAW,GAAG,CAArC,EAAwC;AACtC,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,EAAhC,EAAoC;AAClC,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,gBAAM,GAAG,GACL,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,CAAD,CAAjB,GAAuB,CAAC,GAAG,SAAS,CAAC,CAAD,CAApC,GAA0C,CAAC,GAAG,SAAS,CAAC,CAAD,CAD3D;AAEA,YAAA,MAAM,CAAC,MAAP,CAAc,GAAd,IAAqB,kBAArB;AACD;AACF;;AACD;AACD;;AAED,UAAI,MAAM,KAAK,UAAf,EAA2B;AACzB,YAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAf;AACA,YAAM,SAAS,GAAG,IAAI,CAAC,IAAL,CAAU,IAAV,CAAlB;AACA,YAAM,KAAK,GAAG,IAAI,GAAG,MAArB;;AAEA,aAAK,IAAI,EAAC,GAAG,CAAb,EAAgB,EAAC,GAAG,SAApB,EAA+B,EAAC,EAAhC,EAAoC;AAClC,cAAM,IAAI,GAAI,SAAS,GAAG,CAAb,GACT,EAAE,IAAI,UAAU,GAAG,CAAjB,CAAF,GAAwB,EAAC,GAAG,UADnB,GAET,OAAO,EAAE,GAAG,EAAZ,KAAmB,UAAU,GAAG,CAAhC,CAFJ;;AAIA,cAAI,IAAI,GAAG,CAAP,IAAY,IAAI,GAAG,UAAU,GAAG,CAApC,EAAuC;AACrC,iBAAK,IAAI,EAAC,GAAG,CAAb,EAAgB,EAAC,GAAG,WAApB,EAAiC,EAAC,EAAlC,EAAsC;AACpC,kBAAM,IAAG,GACL,EAAC,GAAG,EAAC,GAAG,SAAS,CAAC,CAAD,CAAjB,GAAuB,CAAC,GAAG,SAAS,CAAC,CAAD,CAApC,GAA0C,CAAC,GAAG,SAAS,CAAC,CAAD,CAD3D;;AAEA,cAAA,MAAM,CAAC,MAAP,CAAc,IAAd,IAAqB,kBAArB;AACD;;AACD;AACD;;AAED,cAAM,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAhB;AACA,cAAM,QAAQ,GAAG,IAAI,CAAC,IAAL,CAAU,IAAV,CAAjB;AACA,cAAM,KAAK,GAAG,IAAI,GAAG,OAArB;;AAEA,eAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,WAApB,EAAiC,GAAC,EAAlC,EAAsC;AACpC,gBAAI,KAAG,GAAG,GAAC,GAAG,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAtB,GAA4B,MAAM,GAAG,QAAQ,CAAC,CAAD,CAA7C,GACN,IAAI,GAAG,QAAQ,CAAC,CAAD,CADnB;;AAEA,gBAAM,OAAO,GAAG,SAAS,CAAC,KAAD,CAAzB;AAEA,YAAA,KAAG,GAAG,GAAC,GAAG,QAAQ,GAAG,QAAQ,CAAC,CAAD,CAAvB,GAA6B,MAAM,GAAG,QAAQ,CAAC,CAAD,CAA9C,GACF,IAAI,GAAG,QAAQ,CAAC,CAAD,CADnB;AAEA,gBAAM,QAAQ,GAAG,SAAS,CAAC,KAAD,CAA1B;AAEA,YAAA,KAAG,GAAG,GAAC,GAAG,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAtB,GAA4B,SAAS,GAAG,QAAQ,CAAC,CAAD,CAAhD,GACF,IAAI,GAAG,QAAQ,CAAC,CAAD,CADnB;AAEA,gBAAM,UAAU,GAAG,SAAS,CAAC,KAAD,CAA5B;AAEA,YAAA,KAAG,GAAG,GAAC,GAAG,QAAQ,GAAG,QAAQ,CAAC,CAAD,CAAvB,GAA6B,SAAS,GAAG,QAAQ,CAAC,CAAD,CAAjD,GACF,IAAI,GAAG,QAAQ,CAAC,CAAD,CADnB;AAEA,gBAAM,WAAW,GAAG,SAAS,CAAC,KAAD,CAA7B;AAEA,gBAAM,GAAG,GAAG,OAAO,GAAG,CAAC,QAAQ,GAAG,OAAZ,IAAuB,KAA7C;AACA,gBAAM,MAAM,GAAG,UAAU,GAAG,CAAC,WAAW,GAAG,UAAf,IAA6B,KAAzD;AAEA,YAAA,KAAG,GAAG,GAAC,GAAG,EAAC,GAAG,SAAS,CAAC,CAAD,CAAjB,GAAuB,CAAC,GAAG,SAAS,CAAC,CAAD,CAApC,GAA0C,CAAC,GAAG,SAAS,CAAC,CAAD,CAA7D;AACA,YAAA,MAAM,CAAC,MAAP,CAAc,KAAd,IAAqB,GAAG,GAAI,CAAC,MAAM,GAAG,GAAV,IAAiB,KAA7C;AACD;AACF;AACF,OA/CD,MA+CO;AAAG;AACR,aAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,SAApB,EAA+B,EAAE,GAAjC,EAAoC;AAClC,cAAM,KAAI,GAAI,SAAS,GAAG,CAAb,GACT,EAAE,IAAI,UAAU,GAAG,CAAjB,CAAF,GAAwB,GAAC,GAAG,UADnB,GAET,OAAO,EAAE,GAAG,EAAZ,KAAmB,UAAU,GAAG,CAAhC,CAFJ;;AAIA,cAAI,KAAI,GAAG,CAAP,IAAY,KAAI,GAAG,UAAU,GAAG,CAApC,EAAuC;AACrC,iBAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,WAApB,EAAiC,GAAC,EAAlC,EAAsC;AACpC,kBAAM,KAAG,GACL,GAAC,GAAG,GAAC,GAAG,SAAS,CAAC,CAAD,CAAjB,GAAuB,CAAC,GAAG,SAAS,CAAC,CAAD,CAApC,GAA0C,CAAC,GAAG,SAAS,CAAC,CAAD,CAD3D;;AAEA,cAAA,MAAM,CAAC,MAAP,CAAc,KAAd,IAAqB,kBAArB;AACD;;AACD;AACD;;AAED,cAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAjB;AACA,cAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAjB;;AACA,eAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,WAApB,EAAiC,GAAC,EAAlC,EAAsC;AACpC,gBAAM,KAAK,GAAG,GAAC,GAAG,QAAQ,GAAG,QAAQ,CAAC,CAAD,CAAvB,GAA6B,QAAQ,GAAG,QAAQ,CAAC,CAAD,CAAhD,GACV,IAAI,GAAG,QAAQ,CAAC,CAAD,CADnB;AAEA,gBAAM,MAAM,GACR,GAAC,GAAG,GAAC,GAAG,SAAS,CAAC,CAAD,CAAjB,GAAuB,CAAC,GAAG,SAAS,CAAC,CAAD,CAApC,GAA0C,CAAC,GAAG,SAAS,CAAC,CAAD,CAD3D;AAEA,YAAA,MAAM,CAAC,MAAP,CAAc,MAAd,IAAwB,SAAS,CAAC,KAAD,CAAjC;AACD;AACF;AACF;AACF;AACF;;AAED,SAAO,OAAO,CAAC,cAAR,CAAuB,MAAM,CAAC,KAA9B,EAAqC,MAAM,CAAC,KAA5C,EAAmD,MAAM,CAAC,MAA1D,CAAP;AACD;AAED,OAAO,IAAM,mBAAmB,GAAiB;AAC/C,EAAA,UAAU,EAAE,aADmC;AAE/C,EAAA,WAAW,EAAE,KAFkC;AAG/C,EAAA,UAAU,EAAE;AAHmC,CAA1C","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, CropAndResize, util } from '@tensorflow/tfjs-core';\nexport function cropAndResize(args) {\n    const { inputs, backend, attrs } = args;\n    const { image, boxes, boxInd } = inputs;\n    const { cropSize, method, extrapolationValue } = attrs;\n    const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n    const numBoxes = boxes.shape[0];\n    const [cropHeight, cropWidth] = cropSize;\n    const output = buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n    const boxVals = backend.data.get(boxes.dataId).values;\n    const boxIndVals = backend.data.get(boxInd.dataId).values;\n    const imageVals = backend.data.get(image.dataId).values;\n    const inStride = util.computeStrides(image.shape); // to calculate flat indexes into image\n    const outStride = util.computeStrides(output.shape); // to calculate flat indexes into output\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n    for (let b = 0; b < numBoxes; b++) {\n        const startInd = b * 4;\n        const y1 = boxVals[startInd];\n        const x1 = boxVals[startInd + 1];\n        const y2 = boxVals[startInd + 2];\n        const x2 = boxVals[startInd + 3];\n        const bInd = boxIndVals[b];\n        if (bInd >= batch) {\n            continue;\n        }\n        const heightScale = (cropHeight > 1) ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n        const widthScale = (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n        for (let y = 0; y < cropHeight; y++) {\n            const yInd = (cropHeight > 1) ?\n                y1 * (imageHeight - 1) + y * (heightScale) :\n                0.5 * (y1 + y2) * (imageHeight - 1);\n            if (yInd < 0 || yInd > imageHeight - 1) {\n                for (let x = 0; x < cropWidth; x++) {\n                    for (let c = 0; c < numChannels; c++) {\n                        const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                        output.values[ind] = extrapolationValue;\n                    }\n                }\n                continue;\n            }\n            if (method === 'bilinear') {\n                const topInd = Math.floor(yInd);\n                const bottomInd = Math.ceil(yInd);\n                const yLerp = yInd - topInd;\n                for (let x = 0; x < cropWidth; x++) {\n                    const xInd = (cropWidth > 1) ?\n                        x1 * (imageWidth - 1) + x * widthScale :\n                        0.5 * (x1 + x2) * (imageWidth - 1);\n                    if (xInd < 0 || xInd > imageWidth - 1) {\n                        for (let c = 0; c < numChannels; c++) {\n                            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                        continue;\n                    }\n                    const leftInd = Math.floor(xInd);\n                    const rightInd = Math.ceil(xInd);\n                    const xLerp = xInd - leftInd;\n                    for (let c = 0; c < numChannels; c++) {\n                        let ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                            bInd * inStride[0];\n                        const topLeft = imageVals[ind];\n                        ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                            bInd * inStride[0];\n                        const topRight = imageVals[ind];\n                        ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                            bInd * inStride[0];\n                        const bottomLeft = imageVals[ind];\n                        ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                            bInd * inStride[0];\n                        const bottomRight = imageVals[ind];\n                        const top = topLeft + (topRight - topLeft) * xLerp;\n                        const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n                        ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                        output.values[ind] = top + ((bottom - top) * yLerp);\n                    }\n                }\n            }\n            else { // method == \"nearest\"\n                for (let x = 0; x < cropWidth; ++x) {\n                    const xInd = (cropWidth > 1) ?\n                        x1 * (imageWidth - 1) + x * widthScale :\n                        0.5 * (x1 + x2) * (imageWidth - 1);\n                    if (xInd < 0 || xInd > imageWidth - 1) {\n                        for (let c = 0; c < numChannels; c++) {\n                            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                        continue;\n                    }\n                    const closestX = Math.round(xInd);\n                    const closestY = Math.round(yInd);\n                    for (let c = 0; c < numChannels; c++) {\n                        const inInd = c + closestX * inStride[2] + closestY * inStride[1] +\n                            bInd * inStride[0];\n                        const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                        output.values[outInd] = imageVals[inInd];\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\nexport const cropAndResizeConfig = {\n    kernelName: CropAndResize,\n    backendName: 'cpu',\n    kernelFunc: cropAndResize\n};\n//# sourceMappingURL=CropAndResize.js.map"]},"metadata":{},"sourceType":"module"}