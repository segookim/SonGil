{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var Rank;\n\n(function (Rank) {\n  Rank[\"R0\"] = \"R0\";\n  Rank[\"R1\"] = \"R1\";\n  Rank[\"R2\"] = \"R2\";\n  Rank[\"R3\"] = \"R3\";\n  Rank[\"R4\"] = \"R4\";\n  Rank[\"R5\"] = \"R5\";\n  Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {})); // Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\n\n\nvar UpcastInt32AndMap;\n\n(function (UpcastInt32AndMap) {\n  UpcastInt32AndMap[\"float32\"] = \"float32\";\n  UpcastInt32AndMap[\"int32\"] = \"int32\";\n  UpcastInt32AndMap[\"bool\"] = \"int32\";\n  UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\n\nvar UpcastBoolAndMap;\n\n(function (UpcastBoolAndMap) {\n  UpcastBoolAndMap[\"float32\"] = \"float32\";\n  UpcastBoolAndMap[\"int32\"] = \"int32\";\n  UpcastBoolAndMap[\"bool\"] = \"bool\";\n  UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\n\nvar UpcastFloat32AndMap;\n\n(function (UpcastFloat32AndMap) {\n  UpcastFloat32AndMap[\"float32\"] = \"float32\";\n  UpcastFloat32AndMap[\"int32\"] = \"float32\";\n  UpcastFloat32AndMap[\"bool\"] = \"float32\";\n  UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\n\nvar UpcastComplex64AndMap;\n\n(function (UpcastComplex64AndMap) {\n  UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n  UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n  UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n  UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\n\nconst upcastTypeMap = {\n  'float32': UpcastFloat32AndMap,\n  'int32': UpcastInt32AndMap,\n  'bool': UpcastBoolAndMap,\n  'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n  if (typeA === 'string' || typeB === 'string') {\n    if (typeA === 'string' && typeB === 'string') {\n      return 'string';\n    }\n\n    throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n  }\n\n  return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\n\nexport function sumOutType(type) {\n  return upcastType(type, 'int32');\n}","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAiDH,OAAA,IAAY,IAAZ;;AAAA,CAAA,UAAY,IAAZ,EAAgB;AACd,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA;AACD,CARD,EAAY,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAhB,E,CAmBA;AACA;;;AACA,IAAK,iBAAL;;AAAA,CAAA,UAAK,iBAAL,EAAsB;AACpB,EAAA,iBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,iBAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACA,EAAA,iBAAA,CAAA,MAAA,CAAA,GAAA,OAAA;AACA,EAAA,iBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,iBAAiB,KAAjB,iBAAiB,GAAA,EAAA,CAAtB;;AAOA,IAAK,gBAAL;;AAAA,CAAA,UAAK,gBAAL,EAAqB;AACnB,EAAA,gBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,gBAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACA,EAAA,gBAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AACA,EAAA,gBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,gBAAgB,KAAhB,gBAAgB,GAAA,EAAA,CAArB;;AAOA,IAAK,mBAAL;;AAAA,CAAA,UAAK,mBAAL,EAAwB;AACtB,EAAA,mBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,mBAAA,CAAA,OAAA,CAAA,GAAA,SAAA;AACA,EAAA,mBAAA,CAAA,MAAA,CAAA,GAAA,SAAA;AACA,EAAA,mBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,mBAAmB,KAAnB,mBAAmB,GAAA,EAAA,CAAxB;;AAOA,IAAK,qBAAL;;AAAA,CAAA,UAAK,qBAAL,EAA0B;AACxB,EAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,WAAA;AACA,EAAA,qBAAA,CAAA,OAAA,CAAA,GAAA,WAAA;AACA,EAAA,qBAAA,CAAA,MAAA,CAAA,GAAA,WAAA;AACA,EAAA,qBAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CALD,EAAK,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA1B;;AAOA,MAAM,aAAa,GAAG;AACpB,aAAW,mBADS;AAEpB,WAAS,iBAFW;AAGpB,UAAQ,gBAHY;AAIpB,eAAa;AAJO,CAAtB;AAOA,OAAM,SAAU,UAAV,CAAqB,KAArB,EAAsC,KAAtC,EAAqD;AACzD,MAAI,KAAK,KAAK,QAAV,IAAsB,KAAK,KAAK,QAApC,EAA8C;AAC5C,QAAI,KAAK,KAAK,QAAV,IAAsB,KAAK,KAAK,QAApC,EAA8C;AAC5C,aAAO,QAAP;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,kBAAkB,KAAK,SAAS,KAAK,EAA/C,CAAN;AACD;;AACD,SAAO,aAAa,CAAC,KAAD,CAAb,CAAqB,KAArB,CAAP;AACD;AAED;;AACA,OAAM,SAAU,UAAV,CAAqB,IAArB,EAAmC;AACvC,SAAO,UAAU,CAAC,IAAD,EAAO,OAAP,CAAjB;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var Rank;\n(function (Rank) {\n    Rank[\"R0\"] = \"R0\";\n    Rank[\"R1\"] = \"R1\";\n    Rank[\"R2\"] = \"R2\";\n    Rank[\"R3\"] = \"R3\";\n    Rank[\"R4\"] = \"R4\";\n    Rank[\"R5\"] = \"R5\";\n    Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {}));\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\nvar UpcastInt32AndMap;\n(function (UpcastInt32AndMap) {\n    UpcastInt32AndMap[\"float32\"] = \"float32\";\n    UpcastInt32AndMap[\"int32\"] = \"int32\";\n    UpcastInt32AndMap[\"bool\"] = \"int32\";\n    UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\nvar UpcastBoolAndMap;\n(function (UpcastBoolAndMap) {\n    UpcastBoolAndMap[\"float32\"] = \"float32\";\n    UpcastBoolAndMap[\"int32\"] = \"int32\";\n    UpcastBoolAndMap[\"bool\"] = \"bool\";\n    UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\nvar UpcastFloat32AndMap;\n(function (UpcastFloat32AndMap) {\n    UpcastFloat32AndMap[\"float32\"] = \"float32\";\n    UpcastFloat32AndMap[\"int32\"] = \"float32\";\n    UpcastFloat32AndMap[\"bool\"] = \"float32\";\n    UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\nvar UpcastComplex64AndMap;\n(function (UpcastComplex64AndMap) {\n    UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n    UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\nconst upcastTypeMap = {\n    'float32': UpcastFloat32AndMap,\n    'int32': UpcastInt32AndMap,\n    'bool': UpcastBoolAndMap,\n    'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n    if (typeA === 'string' || typeB === 'string') {\n        if (typeA === 'string' && typeB === 'string') {\n            return 'string';\n        }\n        throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n    }\n    return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\nexport function sumOutType(type) {\n    return upcastType(type, 'int32');\n}\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"module"}