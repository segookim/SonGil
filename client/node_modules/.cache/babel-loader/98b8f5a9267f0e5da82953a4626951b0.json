{"ast":null,"code":"import _regeneratorRuntime from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\n\nexport function modelFromJSON(_x, _x2) {\n  return _modelFromJSON.apply(this, arguments);\n}\n/**\n * Load a model, including its topology and optionally weights.  See the\n * Tutorial named \"How to import a Keras Model\" for usage examples.\n *\n * Example 1: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 2. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * Example 4. Load a model from an HTTP server.\n *\n * ```js\n * const model = await\n *     tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. This path will be\n *      interpreted as a relative HTTP path, to which `fetch` will be used to\n *      request the model topology and weight manifest JSON.\n *      The content of the JSON file is assumed to be a JSON object with the\n *      following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. An `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n */\n\nfunction _modelFromJSON() {\n  _modelFromJSON = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(modelAndWeightsConfig, customObjects) {\n    var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _iterator4, _step4, weight;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!('modelTopology' in modelAndWeightsConfig)) {\n              modelAndWeightsConfig = {\n                modelTopology: modelAndWeightsConfig\n              };\n            }\n\n            modelAndWeightsConfig = modelAndWeightsConfig;\n            modelTopology = modelAndWeightsConfig.modelTopology;\n\n            if (modelTopology['model_config'] != null) {\n              // If the model-topology JSON contains a 'model_config' field, then it is\n              // a full model JSON (e.g., from `keras.Model.save()`), which contains\n              // not only the model's architecture in its 'model_config' field, but\n              // additional information such as the model's optimizer. We use only the\n              // 'model_config' field currently.\n              modelTopology = modelTopology['model_config'];\n            }\n\n            tsConfig = convertPythonicToTs(modelTopology);\n            model = deserialize(tsConfig, customObjects);\n\n            if (!(modelAndWeightsConfig.weightsManifest != null)) {\n              _context5.next = 15;\n              break;\n            }\n\n            _context5.next = 9;\n            return io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) {\n              return weight.originalName;\n            }));\n\n          case 9:\n            weightValues = _context5.sent;\n            // Map the weights to the unique tensor names generated during model loading\n            uniqueWeightValues = {};\n            _iterator4 = _createForOfIteratorHelper(model.weights);\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                weight = _step4.value;\n                uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            model.loadWeights(uniqueWeightValues); // Dispose temporary weight values.\n\n            dispose(weightValues);\n\n          case 15:\n            return _context5.abrupt(\"return\", model);\n\n          case 16:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _modelFromJSON.apply(this, arguments);\n}\n\nexport function loadLayersModelInternal(_x3, _x4) {\n  return _loadLayersModelInternal.apply(this, arguments);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\n\nfunction _loadLayersModelInternal() {\n  _loadLayersModelInternal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(pathOrIOHandler, options) {\n    var handlers;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (options == null) {\n              options = {};\n            }\n\n            if (!(typeof pathOrIOHandler === 'string')) {\n              _context6.next = 10;\n              break;\n            }\n\n            handlers = io.getLoadHandlers(pathOrIOHandler, options);\n\n            if (!(handlers.length === 0)) {\n              _context6.next = 7;\n              break;\n            }\n\n            // For backward compatibility: if no load handler can be found,\n            // assume it is a relative http path.\n            // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n            // is refactored.\n            handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n            _context6.next = 9;\n            break;\n\n          case 7:\n            if (!(handlers.length > 1)) {\n              _context6.next = 9;\n              break;\n            }\n\n            throw new ValueError(\"Found more than one (\".concat(handlers.length, \") load handlers for \") + \"URL '\".concat(pathOrIOHandler, \"'\"));\n\n          case 9:\n            pathOrIOHandler = handlers[0];\n\n          case 10:\n            return _context6.abrupt(\"return\", loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options));\n\n          case 11:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _loadLayersModelInternal.apply(this, arguments);\n}\n\nexport function loadLayersModelFromIOHandler(_x5, _x6, _x7) {\n  return _loadLayersModelFromIOHandler.apply(this, arguments);\n}\n\nfunction _loadLayersModelFromIOHandler() {\n  _loadLayersModelFromIOHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(handler, customObjects, options) {\n    var artifacts, modelTopology, strict, fastWeightInit, model, trainingConfig, _decodeModelAndOptimi, modelWeights, optimizerWeights;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (options == null) {\n              options = {};\n            }\n\n            if (!(handler.load == null)) {\n              _context7.next = 3;\n              break;\n            }\n\n            throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' + 'does not have the `load` method implemented.');\n\n          case 3:\n            _context7.next = 5;\n            return handler.load();\n\n          case 5:\n            artifacts = _context7.sent;\n            modelTopology = artifacts.modelTopology;\n\n            if (modelTopology['model_config'] != null) {\n              modelTopology = modelTopology['model_config'];\n            }\n\n            strict = options.strict == null ? true : options.strict; // If weights are provided and the weight-loading mode is strict, use\n            // fast weight initialization. This skips costly initializers such as\n            // 'orthogonal' and saves unnecessary computation in cases where\n            // the initialized weight values will immediately be overwritten by\n            // loaded weight values.\n\n            fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n            model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n            trainingConfig = artifacts.trainingConfig;\n\n            if (trainingConfig != null) {\n              model.loadTrainingConfig(trainingConfig);\n            }\n\n            if (artifacts.userDefinedMetadata != null) {\n              model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n            } // If weightData is present, load the weights into the model.\n\n\n            if (!(artifacts.weightData != null)) {\n              _context7.next = 24;\n              break;\n            }\n\n            if (!(artifacts.weightSpecs == null)) {\n              _context7.next = 17;\n              break;\n            }\n\n            throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' + 'Therefore loading of weights cannot proceed.');\n\n          case 17:\n            _decodeModelAndOptimi = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs), modelWeights = _decodeModelAndOptimi.modelWeights, optimizerWeights = _decodeModelAndOptimi.optimizerWeights;\n            model.loadWeights(modelWeights, strict);\n\n            if (!(model.optimizer != null && optimizerWeights.length > 0)) {\n              _context7.next = 22;\n              break;\n            }\n\n            _context7.next = 22;\n            return model.optimizer.setWeights(optimizerWeights);\n\n          case 22:\n            // Dispose temporary weight values.\n            dispose(modelWeights);\n            dispose(optimizerWeights.map(function (w) {\n              return w.tensor;\n            }));\n\n          case 24:\n            return _context7.abrupt(\"return\", model);\n\n          case 25:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _loadLayersModelFromIOHandler.apply(this, arguments);\n}\n\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n  var name2Tensor = io.decodeWeights(buffer, specs);\n  var modelWeights = {};\n  var optimizerWeights = [];\n  specs.forEach(function (spec) {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({\n        name: spec.name,\n        tensor: name2Tensor[spec.name]\n      });\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {\n    modelWeights: modelWeights,\n    optimizerWeights: optimizerWeights\n  };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\n\n\nexport var Sequential = /*#__PURE__*/function (_LayersModel) {\n  _inherits(Sequential, _LayersModel);\n\n  var _super = _createSuper(Sequential);\n\n  function Sequential(args) {\n    var _this;\n\n    _classCallCheck(this, Sequential);\n\n    _this = _super.call(this, {\n      inputs: [],\n      outputs: []\n    });\n    args = args || {};\n    _this.trainable = true;\n    _this.built = false; // Set model name.\n\n    _this.name = args.name != null ? args.name : getUid('sequential_'); // Add to the model any layers passed to the constructor.\n\n    if (args.layers != null) {\n      var _iterator = _createForOfIteratorHelper(args.layers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n\n          _this.add(layer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return _this;\n  } // Helper function to Sequential.add  Throws if the new output shape will be\n  // invalid.\n\n\n  _createClass(Sequential, [{\n    key: \"checkShape\",\n    value: function checkShape(layer) {\n      var shape = layer.inboundNodes[0].outputTensors[0].shape;\n\n      if (shape.some(function (x) {\n        return x < 0;\n      })) {\n        throw new ValueError('Negative dimension size caused by adding layer ' + \"\".concat(layer.name, \" with input shape [\") + \"\".concat(layer.inboundNodes[0].inputTensors[0].shape, \"]\"));\n      }\n    }\n    /**\n     * Adds a layer instance on top of the layer stack.\n     *\n     * ```js\n     *  const model = tf.sequential();\n     *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n     *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n     *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n     *  // Note that the untrained model is random at this point.\n     *  model.predict(tf.randomNormal([10, 1])).print();\n     * ```\n     * @param layer Layer instance.\n     *\n     * @exception ValueError In case the `layer` argument does not know its\n     * input shape.\n     * @exception ValueError In case the `layer` argument has multiple output\n     *   tensors, or is already connected somewhere else (forbidden in\n     *   `Sequential` models).\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(layer) {\n      var isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n      var modelLayer;\n\n      if (isLayerModelInstance) {\n        modelLayer = layer;\n\n        if (modelLayer.outputs.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n\n        if (modelLayer.inputs.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single input tensor. ' + 'For multi-input layers, ' + 'use the functional API.');\n        }\n      }\n\n      if (this.outputs.length === 0) {\n        // first layer in model: check that it is an input layer\n        if (layer.inboundNodes.length === 0) {\n          // create an input layer\n          if (layer.batchInputShape == null) {\n            throw new ValueError('The first layer in a Sequential model must ' + 'get an `inputShape` or `batchInputShape` argument.');\n          } // Instantiate the input layer.\n\n\n          var x = Input({\n            batchShape: layer.batchInputShape,\n            dtype: layer.dtype,\n            name: layer.name + '_input'\n          }); // This will build the current layer and create the node connecting\n          // the current layer to the input layer we just created.\n\n          layer.apply(x);\n        }\n\n        if (isLayerModelInstance) {\n          this.outputs = modelLayer.outputs;\n          this.inputs = modelLayer.inputs;\n        } else {\n          if (layer.inboundNodes.length !== 1) {\n            throw new ValueError('A layer added to a Sequential model must not already be ' + \"connected somewhere else. LayersModel received layer \".concat(layer.name, \" \") + \"which has \".concat(layer.inboundNodes.length, \" pre-existing inbound \") + 'connections.');\n          }\n\n          if (layer.inboundNodes[0].outputTensors.length !== 1) {\n            throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n          }\n\n          this.checkShape(layer);\n          this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n          this.inputs = getSourceInputs(this.outputs[0]);\n        }\n\n        this.inboundNodes = []; // We create an input node, which we will keep updated\n        // as we add more layers.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n\n        new Node({\n          outboundLayer: this,\n          inboundLayers: [],\n          nodeIndices: [],\n          tensorIndices: [],\n          inputTensors: this.inputs,\n          outputTensors: this.outputs,\n          // no model-level masking for now\n          inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n          outputMasks: [null],\n          inputShapes: this.inputs.map(function (x) {\n            return x.shape;\n          }),\n          outputShapes: this.outputs[0].shape\n        });\n      } else {\n        var outputTensor = layer.apply(this.outputs[0]);\n\n        if (Array.isArray(outputTensor)) {\n          throw new TypeError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n\n        this.checkShape(layer);\n        this.outputs = [outputTensor]; // update self.inbound_nodes\n\n        this.inboundNodes[0].outputTensors = this.outputs;\n        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n      }\n\n      this.layers.push(layer);\n      this.built = false;\n    }\n    /**\n     * Removes the last layer in the model.\n     *\n     * @exception TypeError if there are no layers in the model.\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.layers.length === 0) {\n        throw new TypeError('There are no layers in the model.');\n      }\n\n      this.layers.pop();\n\n      if (this.layers.length === 0) {\n        this.outputs = [];\n        this.inboundNodes = [];\n        this.outboundNodes = [];\n      } else {\n        var lastLayerIndex = this.layers.length - 1;\n        this.layers[lastLayerIndex].outboundNodes = [];\n        this.outputs = [this.layers[lastLayerIndex].output]; // update self.inbound_nodes\n\n        this.inboundNodes[0].outputTensors = this.outputs;\n        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      if (this.model == null) {\n        this.build();\n      }\n\n      return this.model.call(inputs, kwargs);\n    }\n  }, {\n    key: \"build\",\n    value: function build(inputShape) {\n      // Call `getExactlyOneShape` without using its return value,\n      // to verify that exactly one input shape is provided.\n      getExactlyOneShape(inputShape);\n\n      if (this.inputs.length === 0 || this.outputs.length === 0) {\n        throw new TypeError('Sequential model cannot be built: model is empty.' + ' Add some layers first.');\n      } // actually create the model\n\n\n      this.model = new LayersModel({\n        inputs: this.inputs,\n        outputs: this.outputs[0],\n        name: this.name + '_model'\n      });\n      this.model.trainable = this.trainable; // mirror model attributes\n\n      this.supportsMasking = this.model.supportsMasking; // TODO(michaelterry): Add caches\n\n      this.inputLayers = this.model.inputLayers;\n      this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n      this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n      this.outputLayers = this.model.outputLayers;\n      this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n      this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n      this.nodesByDepth = this.model.nodesByDepth;\n      this.containerNodes = this.model.containerNodes;\n      this.outputNames = this.model.outputNames;\n      this.inputNames = this.model.inputNames; // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n      // TODO(michaelterry): Add callbackModel if needed.\n\n      this.built = true;\n    }\n  }, {\n    key: \"countParams\",\n    value: function countParams() {\n      if (!this.built) {\n        this.build();\n      }\n\n      return _get(_getPrototypeOf(Sequential.prototype), \"countParams\", this).call(this);\n    }\n    /**\n     * Print a text summary of the Sequential model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - The total number of trainable and non-trainable parameters of the\n     * model.\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(\n     *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n     * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n     *\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"summary\",\n    value: function summary(lineLength, positions) {\n      var printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n\n      if (!this.built) {\n        this.build();\n      }\n\n      _get(_getPrototypeOf(Sequential.prototype), \"summary\", this).call(this, lineLength, positions, printFn);\n    }\n    /**\n     * Sets the weights of the model.\n     *\n     * @param weights Should be a list of Tensors with shapes and types matching\n     *   the output of `model.getWeights()`.\n     */\n\n  }, {\n    key: \"setWeights\",\n    value: function setWeights(weights) {\n      if (this.model == null) {\n        this.build();\n      }\n\n      this.model.setWeights(weights);\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     * });\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateConfig`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(x, y) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!this.built) {\n        throw new RuntimeError('The model needs to be compiled before being used.');\n      }\n\n      return this.model.evaluate(x, y, args);\n    } // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"evaluateDataset\",\n    value: function () {\n      var _evaluateDataset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataset, args) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.built) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new RuntimeError('The model needs to be compiled before being used.');\n\n              case 2:\n                return _context.abrupt(\"return\", this.model.evaluateDataset(dataset, args));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function evaluateDataset(_x8, _x9) {\n        return _evaluateDataset.apply(this, arguments);\n      }\n\n      return evaluateDataset;\n    }()\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([2, 10])).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param conifg A `ModelPredictConfig` object containing optional fields.\n     *\n     * @return `tf.Tensor`(s) of predictions.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"predict\",\n    value: function predict(x) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.model == null) {\n        this.build();\n      }\n\n      return this.model.predict(x, args);\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n     *   has multiple inputs).\n     * @return Tensor(s) of predictions\n     */\n\n  }, {\n    key: \"predictOnBatch\",\n    value: function predictOnBatch(x) {\n      if (this.model == null) {\n        this.build();\n      }\n\n      return this.model.predictOnBatch(x);\n    }\n    /**\n     * See `LayersModel.compile`.\n     *\n     * @param args\n     */\n\n  }, {\n    key: \"compile\",\n    value: function compile(args) {\n      this.build();\n      this.model.compile(args);\n      this.optimizer_ = this.model.optimizer; // tslint:disable-next-line:no-any\n\n      this.isOptimizerOwned = this.model.isOptimizerOwned;\n      this.loss = this.model.loss;\n      this.metrics = this.model.metrics; // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n      //   this.weightedMetrics, this.targets.\n\n      this.metricsTensors = this.model.metricsTensors;\n      this.metricsNames = this.model.metricsNames; // TODO(cais): Add sampleWeights.\n    }\n  }, {\n    key: \"optimizer\",\n    get: function get() {\n      return this.model == null ? undefined : this.model.optimizer;\n    },\n    set: function set(optimizer) {\n      this.model.optimizer = optimizer;\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     *   epochs: 3\n     * });\n     * console.log(history.history.loss[0]);\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you can\n     * also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named, you\n     *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args  A `ModelFitConfig`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"fit\",\n    value: function () {\n      var _fit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(x, y) {\n        var args,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                args = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n\n                if (this.built) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n\n              case 3:\n                return _context2.abrupt(\"return\", this.model.fit(x, y, args));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fit(_x10, _x11) {\n        return _fit.apply(this, arguments);\n      }\n\n      return fit;\n    }()\n    /**\n     * Trains the model using a dataset object.\n     *\n     * ```js\n     * const xArray = [\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     * ];\n     * const yArray = [1, 1, 1, 1];\n     * // Create a dataset from the JavaScript array.\n     * const xDataset = tf.data.array(xArray);\n     * const yDataset = tf.data.array(yArray);\n     * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n     * // iterator of which will return an object containing of two tensors,\n     * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n     * // four such samples into a single object, with the same keys now pointing\n     * // to tensors that hold 4 examples, organized along the batch dimension.\n     * // The call to `shuffle(4)` causes each iteration through the dataset to\n     * // happen in a different order.  The size of the shuffle window is 4.\n     * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n     *     .batch(4)\n     *     .shuffle(4);\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fitDataset(xyDataset, {\n     *   epochs: 4,\n     *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n     * });\n     * ```\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected to\n     *   generate a dataset iterator object, the `next()` method of which is\n     *   expected to produce data batches for evaluation. The return value of the\n     *   `next()` call ought to contain a boolean `done` field and a `value`\n     *   field.\n     *\n     *   The `value` field is expected to be an object of with fields\n     *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n     *   respectively. This case is for models with exactly one input and one\n     *   output (e.g.. a sequential model). For example:\n     *   ```js\n     *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n     *   ```\n     *\n     *   If the model has multiple inputs, the `xs` field of `value` should\n     *   be an object mapping input names to their respective feature tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: {\n     *         input_1: xsTensor1,\n     *         input_2: xsTensor2\n     *       },\n     *       ys: ysTensor\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     *   If the model has multiple outputs, the `ys` field of `value` should\n     *   be an object mapping output names to their respective target tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: xsTensor,\n     *       ys: {\n     *         output_1: ysTensor1,\n     *         output_2: ysTensor2\n     *       },\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n\n  }, {\n    key: \"fitDataset\",\n    value: function () {\n      var _fitDataset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(dataset, args) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.built) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n\n              case 2:\n                return _context3.abrupt(\"return\", this.model.fitDataset(dataset, args));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function fitDataset(_x12, _x13) {\n        return _fitDataset.apply(this, arguments);\n      }\n\n      return fitDataset;\n    }()\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and matric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target darta. It could be either a `tf.Tensor` a multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n\n  }, {\n    key: \"trainOnBatch\",\n    value: function () {\n      var _trainOnBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(x, y) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.model.trainOnBatch(x, y));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function trainOnBatch(_x14, _x15) {\n        return _trainOnBatch.apply(this, arguments);\n      }\n\n      return trainOnBatch;\n    }()\n    /* See parent class for JsDoc */\n\n    /** @nocollapse */\n\n  }, {\n    key: \"stopTraining\",\n    get: function get() {\n      if (this.model == null) {\n        throw new ValueError('Cannot get the stopTraining property of a sequential model before ' + 'it is compiled.');\n      }\n\n      return this.model.stopTraining;\n    } // TODO(cais): Override get trainableWeights() here\n    // tslint:disable-next-line:no-any\n    ,\n    set:\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10 values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    function set(stop) {\n      // TODO(cais): When refactoring to remove the composition pattern happens,\n      // remove this method overriding.\n      if (this.model == null) {\n        throw new ValueError('Cannot set the stopTraining property of a sequential model before ' + 'it is compiled.');\n      }\n\n      this.model.stopTraining = stop;\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      // NOTE(cais): We override the return type of getConfig() to `any` here,\n      //   because the `Sequential` class is a special case among `Container`\n      //   subtypes in that its getConfig() method returns an Array (not a\n      //   dict).\n      var layers = [];\n\n      var _iterator2 = _createForOfIteratorHelper(this.layers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          var dict = {};\n          dict['className'] = layer.getClassName();\n          dict['config'] = layer.getConfig();\n          layers.push(dict);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return {\n        name: this.name,\n        layers: layers\n      };\n    }\n  }], [{\n    key: \"fromConfig\",\n    value: function fromConfig(cls, config) {\n      var customObjects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fastWeightInit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var configArray;\n      var extraModelConfig = {};\n\n      if (config instanceof Array) {\n        if (!(config[0].className != null) || config[0]['className'] === 'Merge') {\n          throw new ValueError('Legacy serialization format not supported yet.');\n        }\n\n        configArray = config;\n      } else {\n        util.assert(config['layers'] != null, function () {\n          return \"When the config data for a Sequential model is not an Array, \" + \"it must be an Object that contains the 'layers' field.\";\n        });\n        configArray = config['layers'];\n        delete config['layers'];\n        extraModelConfig = config;\n      }\n\n      var model = new cls(extraModelConfig);\n\n      if (!(model instanceof Sequential)) {\n        throw new NotImplementedError(\"Sequential.fromConfig called on non-Sequential input: \".concat(model));\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(configArray),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var conf = _step3.value;\n          var _customObjects = undefined;\n          var layer = deserialize(conf, _customObjects, fastWeightInit);\n\n          if (fastWeightInit) {\n            layer.setFastWeightInitDuringBuild(true);\n          }\n\n          model.add(layer);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return model;\n    }\n  }]);\n\n  return Sequential;\n}(LayersModel);\n/** @nocollapse */\n\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);","map":{"version":3,"sources":["../src/models.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(modelAndWeightsConfig, customObjects) {\n    if (!('modelTopology' in modelAndWeightsConfig)) {\n        modelAndWeightsConfig = { modelTopology: modelAndWeightsConfig };\n    }\n    modelAndWeightsConfig = modelAndWeightsConfig;\n    let modelTopology = modelAndWeightsConfig.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        // If the model-topology JSON contains a 'model_config' field, then it is\n        // a full model JSON (e.g., from `keras.Model.save()`), which contains\n        // not only the model's architecture in its 'model_config' field, but\n        // additional information such as the model's optimizer. We use only the\n        // 'model_config' field currently.\n        modelTopology = modelTopology['model_config'];\n    }\n    const tsConfig = convertPythonicToTs(modelTopology);\n    const model = deserialize(tsConfig, customObjects);\n    if (modelAndWeightsConfig.weightsManifest != null) {\n        // Load the weight values keyed by the original tensor names in the model\n        // file that was loaded.  These should match the keys of the weight\n        // manifest.\n        const weightValues = await io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(weight => weight.originalName));\n        // Map the weights to the unique tensor names generated during model loading\n        const uniqueWeightValues = {};\n        for (const weight of model.weights) {\n            uniqueWeightValues[weight.originalName] =\n                weightValues[weight.originalName];\n        }\n        model.loadWeights(uniqueWeightValues);\n        // Dispose temporary weight values.\n        dispose(weightValues);\n    }\n    return model;\n}\n/**\n * Load a model, including its topology and optionally weights.  See the\n * Tutorial named \"How to import a Keras Model\" for usage examples.\n *\n * Example 1: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 2. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * Example 4. Load a model from an HTTP server.\n *\n * ```js\n * const model = await\n *     tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. This path will be\n *      interpreted as a relative HTTP path, to which `fetch` will be used to\n *      request the model topology and weight manifest JSON.\n *      The content of the JSON file is assumed to be a JSON object with the\n *      following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. An `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n */\nexport async function loadLayersModelInternal(pathOrIOHandler, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (typeof pathOrIOHandler === 'string') {\n        const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n        if (handlers.length === 0) {\n            // For backward compatibility: if no load handler can be found,\n            // assume it is a relative http path.\n            // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n            // is refactored.\n            handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n        }\n        else if (handlers.length > 1) {\n            throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` +\n                `URL '${pathOrIOHandler}'`);\n        }\n        pathOrIOHandler = handlers[0];\n    }\n    return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(handler, customObjects, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (handler.load == null) {\n        throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' +\n            'does not have the `load` method implemented.');\n    }\n    const artifacts = await handler.load();\n    let modelTopology = artifacts.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        modelTopology = modelTopology['model_config'];\n    }\n    const strict = options.strict == null ? true : options.strict;\n    // If weights are provided and the weight-loading mode is strict, use\n    // fast weight initialization. This skips costly initializers such as\n    // 'orthogonal' and saves unnecessary computation in cases where\n    // the initialized weight values will immediately be overwritten by\n    // loaded weight values.\n    const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n    const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n    const trainingConfig = artifacts.trainingConfig;\n    if (trainingConfig != null) {\n        model.loadTrainingConfig(trainingConfig);\n    }\n    if (artifacts.userDefinedMetadata != null) {\n        model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n    }\n    // If weightData is present, load the weights into the model.\n    if (artifacts.weightData != null) {\n        // Loading weights requires weightSpecs.\n        if (artifacts.weightSpecs == null) {\n            throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' +\n                'Therefore loading of weights cannot proceed.');\n        }\n        const { modelWeights, optimizerWeights } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);\n        model.loadWeights(modelWeights, strict);\n        if (model.optimizer != null && optimizerWeights.length > 0) {\n            await model.optimizer.setWeights(optimizerWeights);\n        }\n        // Dispose temporary weight values.\n        dispose(modelWeights);\n        dispose(optimizerWeights.map(w => w.tensor));\n    }\n    return model;\n}\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n    const name2Tensor = io.decodeWeights(buffer, specs);\n    const modelWeights = {};\n    const optimizerWeights = [];\n    specs.forEach(spec => {\n        if (spec.group === 'optimizer') {\n            optimizerWeights.push({ name: spec.name, tensor: name2Tensor[spec.name] });\n        }\n        else {\n            modelWeights[spec.name] = name2Tensor[spec.name];\n        }\n    });\n    return { modelWeights, optimizerWeights };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class Sequential extends LayersModel {\n    constructor(args) {\n        super({ inputs: [], outputs: [] });\n        args = args || {};\n        this.trainable = true;\n        this.built = false;\n        // Set model name.\n        this.name = (args.name != null) ? args.name : getUid('sequential_');\n        // Add to the model any layers passed to the constructor.\n        if (args.layers != null) {\n            for (const layer of args.layers) {\n                this.add(layer);\n            }\n        }\n    }\n    // Helper function to Sequential.add  Throws if the new output shape will be\n    // invalid.\n    checkShape(layer) {\n        const shape = layer.inboundNodes[0].outputTensors[0].shape;\n        if (shape.some(x => x < 0)) {\n            throw new ValueError('Negative dimension size caused by adding layer ' +\n                `${layer.name} with input shape [` +\n                `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n        }\n    }\n    /**\n     * Adds a layer instance on top of the layer stack.\n     *\n     * ```js\n     *  const model = tf.sequential();\n     *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n     *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n     *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n     *  // Note that the untrained model is random at this point.\n     *  model.predict(tf.randomNormal([10, 1])).print();\n     * ```\n     * @param layer Layer instance.\n     *\n     * @exception ValueError In case the `layer` argument does not know its\n     * input shape.\n     * @exception ValueError In case the `layer` argument has multiple output\n     *   tensors, or is already connected somewhere else (forbidden in\n     *   `Sequential` models).\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    add(layer) {\n        const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n        let modelLayer;\n        if (isLayerModelInstance) {\n            modelLayer = layer;\n            if (modelLayer.outputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            if (modelLayer.inputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single input tensor. ' +\n                    'For multi-input layers, ' +\n                    'use the functional API.');\n            }\n        }\n        if (this.outputs.length === 0) {\n            // first layer in model: check that it is an input layer\n            if (layer.inboundNodes.length === 0) {\n                // create an input layer\n                if (layer.batchInputShape == null) {\n                    throw new ValueError('The first layer in a Sequential model must ' +\n                        'get an `inputShape` or `batchInputShape` argument.');\n                }\n                // Instantiate the input layer.\n                const x = Input({\n                    batchShape: layer.batchInputShape,\n                    dtype: layer.dtype,\n                    name: layer.name + '_input'\n                });\n                // This will build the current layer and create the node connecting\n                // the current layer to the input layer we just created.\n                layer.apply(x);\n            }\n            if (isLayerModelInstance) {\n                this.outputs = modelLayer.outputs;\n                this.inputs = modelLayer.inputs;\n            }\n            else {\n                if (layer.inboundNodes.length !== 1) {\n                    throw new ValueError('A layer added to a Sequential model must not already be ' +\n                        `connected somewhere else. LayersModel received layer ${layer.name} ` +\n                        `which has ${layer.inboundNodes.length} pre-existing inbound ` +\n                        'connections.');\n                }\n                if (layer.inboundNodes[0].outputTensors.length !== 1) {\n                    throw new ValueError('All layers in a Sequential model ' +\n                        'should have a single output tensor. ' +\n                        'For multi-output layers, ' +\n                        'use the functional API.');\n                }\n                this.checkShape(layer);\n                this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n                this.inputs = getSourceInputs(this.outputs[0]);\n            }\n            this.inboundNodes = [];\n            // We create an input node, which we will keep updated\n            // as we add more layers.\n            // (This call has side effects.)\n            // tslint:disable-next-line:no-unused-expression\n            new Node({\n                outboundLayer: this,\n                inboundLayers: [],\n                nodeIndices: [],\n                tensorIndices: [],\n                inputTensors: this.inputs,\n                outputTensors: this.outputs,\n                // no model-level masking for now\n                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n                outputMasks: [null],\n                inputShapes: this.inputs.map(x => x.shape),\n                outputShapes: this.outputs[0].shape\n            });\n        }\n        else {\n            const outputTensor = layer.apply(this.outputs[0]);\n            if (Array.isArray(outputTensor)) {\n                throw new TypeError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            this.checkShape(layer);\n            this.outputs = [outputTensor];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n        this.layers.push(layer);\n        this.built = false;\n    }\n    /**\n     * Removes the last layer in the model.\n     *\n     * @exception TypeError if there are no layers in the model.\n     */\n    pop() {\n        if (this.layers.length === 0) {\n            throw new TypeError('There are no layers in the model.');\n        }\n        this.layers.pop();\n        if (this.layers.length === 0) {\n            this.outputs = [];\n            this.inboundNodes = [];\n            this.outboundNodes = [];\n        }\n        else {\n            const lastLayerIndex = this.layers.length - 1;\n            this.layers[lastLayerIndex].outboundNodes = [];\n            this.outputs = [this.layers[lastLayerIndex].output];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n    }\n    call(inputs, kwargs) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.call(inputs, kwargs);\n    }\n    build(inputShape) {\n        // Call `getExactlyOneShape` without using its return value,\n        // to verify that exactly one input shape is provided.\n        getExactlyOneShape(inputShape);\n        if (this.inputs.length === 0 || this.outputs.length === 0) {\n            throw new TypeError('Sequential model cannot be built: model is empty.' +\n                ' Add some layers first.');\n        }\n        // actually create the model\n        this.model = new LayersModel({\n            inputs: this.inputs,\n            outputs: this.outputs[0],\n            name: this.name + '_model'\n        });\n        this.model.trainable = this.trainable;\n        // mirror model attributes\n        this.supportsMasking = this.model.supportsMasking;\n        // TODO(michaelterry): Add caches\n        this.inputLayers = this.model.inputLayers;\n        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n        this.outputLayers = this.model.outputLayers;\n        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n        this.nodesByDepth = this.model.nodesByDepth;\n        this.containerNodes = this.model.containerNodes;\n        this.outputNames = this.model.outputNames;\n        this.inputNames = this.model.inputNames;\n        // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n        // TODO(michaelterry): Add callbackModel if needed.\n        this.built = true;\n    }\n    countParams() {\n        if (!this.built) {\n            this.build();\n        }\n        return super.countParams();\n    }\n    /**\n     * Print a text summary of the Sequential model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - The total number of trainable and non-trainable parameters of the\n     * model.\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(\n     *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n     * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n     *\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    summary(lineLength, positions, printFn = console.log) {\n        if (!this.built) {\n            this.build();\n        }\n        super.summary(lineLength, positions, printFn);\n    }\n    /**\n     * Sets the weights of the model.\n     *\n     * @param weights Should be a list of Tensors with shapes and types matching\n     *   the output of `model.getWeights()`.\n     */\n    setWeights(weights) {\n        if (this.model == null) {\n            this.build();\n        }\n        this.model.setWeights(weights);\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     * });\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateConfig`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    evaluate(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluate(x, y, args);\n    }\n    // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async evaluateDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluateDataset(dataset, args);\n    }\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([2, 10])).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param conifg A `ModelPredictConfig` object containing optional fields.\n     *\n     * @return `tf.Tensor`(s) of predictions.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    predict(x, args = {}) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predict(x, args);\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n     *   has multiple inputs).\n     * @return Tensor(s) of predictions\n     */\n    predictOnBatch(x) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predictOnBatch(x);\n    }\n    /**\n     * See `LayersModel.compile`.\n     *\n     * @param args\n     */\n    compile(args) {\n        this.build();\n        this.model.compile(args);\n        this.optimizer_ = this.model.optimizer;\n        // tslint:disable-next-line:no-any\n        this.isOptimizerOwned = this.model.isOptimizerOwned;\n        this.loss = this.model.loss;\n        this.metrics = this.model.metrics;\n        // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n        //   this.weightedMetrics, this.targets.\n        this.metricsTensors = this.model.metricsTensors;\n        this.metricsNames = this.model.metricsNames;\n        // TODO(cais): Add sampleWeights.\n    }\n    get optimizer() {\n        return this.model == null ? undefined : this.model.optimizer;\n    }\n    set optimizer(optimizer) {\n        this.model.optimizer = optimizer;\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     *   epochs: 3\n     * });\n     * console.log(history.history.loss[0]);\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you can\n     * also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named, you\n     *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args  A `ModelFitConfig`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async fit(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fit(x, y, args);\n    }\n    /**\n     * Trains the model using a dataset object.\n     *\n     * ```js\n     * const xArray = [\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     * ];\n     * const yArray = [1, 1, 1, 1];\n     * // Create a dataset from the JavaScript array.\n     * const xDataset = tf.data.array(xArray);\n     * const yDataset = tf.data.array(yArray);\n     * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n     * // iterator of which will return an object containing of two tensors,\n     * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n     * // four such samples into a single object, with the same keys now pointing\n     * // to tensors that hold 4 examples, organized along the batch dimension.\n     * // The call to `shuffle(4)` causes each iteration through the dataset to\n     * // happen in a different order.  The size of the shuffle window is 4.\n     * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n     *     .batch(4)\n     *     .shuffle(4);\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fitDataset(xyDataset, {\n     *   epochs: 4,\n     *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n     * });\n     * ```\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected to\n     *   generate a dataset iterator object, the `next()` method of which is\n     *   expected to produce data batches for evaluation. The return value of the\n     *   `next()` call ought to contain a boolean `done` field and a `value`\n     *   field.\n     *\n     *   The `value` field is expected to be an object of with fields\n     *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n     *   respectively. This case is for models with exactly one input and one\n     *   output (e.g.. a sequential model). For example:\n     *   ```js\n     *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n     *   ```\n     *\n     *   If the model has multiple inputs, the `xs` field of `value` should\n     *   be an object mapping input names to their respective feature tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: {\n     *         input_1: xsTensor1,\n     *         input_2: xsTensor2\n     *       },\n     *       ys: ysTensor\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     *   If the model has multiple outputs, the `ys` field of `value` should\n     *   be an object mapping output names to their respective target tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: xsTensor,\n     *       ys: {\n     *         output_1: ysTensor1,\n     *         output_2: ysTensor2\n     *       },\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    async fitDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fitDataset(dataset, args);\n    }\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and matric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target darta. It could be either a `tf.Tensor` a multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async trainOnBatch(x, y) {\n        return this.model.trainOnBatch(x, y);\n    }\n    /* See parent class for JsDoc */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        let configArray;\n        let extraModelConfig = {};\n        if (config instanceof Array) {\n            if (!(config[0].className != null) ||\n                config[0]['className'] === 'Merge') {\n                throw new ValueError('Legacy serialization format not supported yet.');\n            }\n            configArray = config;\n        }\n        else {\n            util.assert(config['layers'] != null, () => `When the config data for a Sequential model is not an Array, ` +\n                `it must be an Object that contains the 'layers' field.`);\n            configArray = config['layers'];\n            delete config['layers'];\n            extraModelConfig = config;\n        }\n        const model = new cls(extraModelConfig);\n        if (!(model instanceof Sequential)) {\n            throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);\n        }\n        for (const conf of configArray) {\n            const customObjects = undefined;\n            const layer = deserialize(conf, customObjects, fastWeightInit);\n            if (fastWeightInit) {\n                layer.setFastWeightInitDuringBuild(true);\n            }\n            model.add(layer);\n        }\n        return model;\n    }\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10 values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    set stopTraining(stop) {\n        // TODO(cais): When refactoring to remove the composition pattern happens,\n        // remove this method overriding.\n        if (this.model == null) {\n            throw new ValueError('Cannot set the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        this.model.stopTraining = stop;\n    }\n    get stopTraining() {\n        if (this.model == null) {\n            throw new ValueError('Cannot get the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        return this.model.stopTraining;\n    }\n    // TODO(cais): Override get trainableWeights() here\n    // tslint:disable-next-line:no-any\n    getConfig() {\n        // NOTE(cais): We override the return type of getConfig() to `any` here,\n        //   because the `Sequential` class is a special case among `Container`\n        //   subtypes in that its getConfig() method returns an Array (not a\n        //   dict).\n        const layers = [];\n        for (const layer of this.layers) {\n            const dict = {};\n            dict['className'] = layer.getClassName();\n            dict['config'] = layer.getConfig();\n            layers.push(dict);\n        }\n        return { name: this.name, layers };\n    }\n}\n/** @nocollapse */\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);\n//# sourceMappingURL=models.js.map"]},"metadata":{},"sourceType":"module"}