{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nconst whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n  constructor() {\n    super();\n    this.blockSize = 48;\n    this.firstUse = true;\n    this.data = new DataStorage(this, engine());\n  }\n\n  nextDataId() {\n    return MathBackendCPU.nextDataId++;\n  }\n\n  write(values, shape, dtype) {\n    if (this.firstUse) {\n      this.firstUse = false;\n\n      if (env().get('IS_NODE')) {\n        backend_util.warn('\\n============================\\n' + 'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, which binds to TensorFlow C++, by running ' + 'npm i @tensorflow/tfjs-node, ' + 'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' + 'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' + 'suffix for CUDA) at the start of your program. ' + 'Visit https://github.com/tensorflow/tfjs-node for more details.' + '\\n============================');\n      }\n    }\n\n    const dataId = {\n      id: this.nextDataId()\n    };\n    this.data.set(dataId, {\n      values,\n      dtype,\n      refCount: 1\n    });\n    return dataId;\n  }\n  /**\n   * Create a data bucket in cpu backend.\n   * @param shape Shape of the `TensorInfo`.\n   * @param dtype DType of the `TensorInfo`.\n   * @param values The value of the `TensorInfo` stored as a flattened array.\n   */\n\n\n  makeTensorInfo(shape, dtype, values) {\n    let outId;\n\n    if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n      const encodedValues = values.map(d => util.encodeString(d));\n      outId = this.write(encodedValues, shape, dtype);\n    } else {\n      outId = this.write(values, shape, dtype);\n    }\n\n    return {\n      dataId: outId,\n      shape,\n      dtype\n    };\n  }\n  /** Return refCount of a `TensorData`. */\n\n\n  refCount(dataId) {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      return tensorData.refCount;\n    }\n\n    return 0;\n  }\n  /** Increase refCount of a `TensorData`. */\n\n\n  incRef(dataId) {\n    const tensorData = this.data.get(dataId);\n    tensorData.refCount++;\n  }\n  /** Decrease refCount of a `TensorData`. */\n\n\n  decRef(dataId) {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  move(dataId, values, shape, dtype, refCount) {\n    this.data.set(dataId, {\n      values,\n      dtype,\n      refCount\n    });\n  }\n\n  numDataIds() {\n    return this.data.numDataIds();\n  }\n\n  async read(dataId) {\n    return this.readSync(dataId);\n  }\n\n  readSync(dataId) {\n    const {\n      dtype,\n      complexTensorInfos\n    } = this.data.get(dataId);\n\n    if (dtype === 'complex64') {\n      const realValues = this.readSync(complexTensorInfos.real.dataId);\n      const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n      return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    }\n\n    return this.data.get(dataId).values;\n  }\n\n  bufferSync(t) {\n    const data = this.readSync(t.dataId);\n    let decodedData = data;\n\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        decodedData = data.map(d => util.decodeString(d));\n      } catch (_a) {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n\n    return buffer(t.shape, t.dtype, decodedData);\n  }\n\n  makeOutput(values, shape, dtype) {\n    const dataId = this.write(values, shape, dtype);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n  }\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or memory is not managed in this backend, false if memory is\n   * not cleared.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n\n\n  disposeData(dataId, force = false) {\n    if (this.data.has(dataId)) {\n      this.data.get(dataId).refCount--;\n\n      if (!force && this.data.get(dataId).refCount > 0) {\n        return false;\n      }\n\n      const {\n        complexTensorInfos\n      } = this.data.get(dataId);\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, true);\n        this.disposeData(complexTensorInfos.imag.dataId, true);\n      }\n\n      this.data.delete(dataId);\n    }\n\n    return true;\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo) {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  async time(f) {\n    const start = util.now();\n    f();\n    const kernelMs = util.now() - start;\n    return {\n      kernelMs\n    };\n  }\n\n  memory() {\n    return {\n      // Unreliable due to automatic gc. The numbers above are cumulative.\n      unreliable: true,\n      reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n    };\n  }\n\n  where(condition) {\n    assertNotComplex([condition], 'where');\n    const condVals = this.readSync(condition.dataId);\n    return whereImpl(condition.shape, condVals);\n  }\n\n  dispose() {}\n\n  floatPrecision() {\n    return 32;\n  }\n  /** Returns the smallest representable number.  */\n\n\n  epsilon() {\n    return super.epsilon();\n  }\n\n}\nMathBackendCPU.nextDataId = 0;","map":{"version":3,"sources":["../src/backend_cpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nconst whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n    constructor() {\n        super();\n        this.blockSize = 48;\n        this.firstUse = true;\n        this.data = new DataStorage(this, engine());\n    }\n    nextDataId() {\n        return MathBackendCPU.nextDataId++;\n    }\n    write(values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (env().get('IS_NODE')) {\n                backend_util.warn('\\n============================\\n' +\n                    'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        const dataId = { id: this.nextDataId() };\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n        return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n    makeTensorInfo(shape, dtype, values) {\n        let outId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            util.isString(values[0])) {\n            const encodedValues = values.map(d => util.encodeString(d));\n            outId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            outId = this.write(values, shape, dtype);\n        }\n        return { dataId: outId, shape, dtype };\n    }\n    /** Return refCount of a `TensorData`. */\n    refCount(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            return tensorData.refCount;\n        }\n        return 0;\n    }\n    /** Increase refCount of a `TensorData`. */\n    incRef(dataId) {\n        const tensorData = this.data.get(dataId);\n        tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n    decRef(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n        }\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        this.data.set(dataId, { values, dtype, refCount });\n    }\n    numDataIds() {\n        return this.data.numDataIds();\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { dtype, complexTensorInfos } = this.data.get(dataId);\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensorInfos.real.dataId);\n            const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return buffer(t.shape, t.dtype, decodedData);\n    }\n    makeOutput(values, shape, dtype) {\n        const dataId = this.write(values, shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released or memory is not managed in this backend, false if memory is\n     * not cleared.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n    disposeData(dataId, force = false) {\n        if (this.data.has(dataId)) {\n            this.data.get(dataId).refCount--;\n            if (!force && this.data.get(dataId).refCount > 0) {\n                return false;\n            }\n            const { complexTensorInfos } = this.data.get(dataId);\n            if (complexTensorInfos != null) {\n                this.disposeData(complexTensorInfos.real.dataId, true);\n                this.disposeData(complexTensorInfos.imag.dataId, true);\n            }\n            this.data.delete(dataId);\n        }\n        return true;\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        this.disposeData(tensorInfo.dataId);\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    memory() {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    }\n    where(condition) {\n        assertNotComplex([condition], 'where');\n        const condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    }\n    dispose() { }\n    floatPrecision() {\n        return 32;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return super.epsilon();\n    }\n}\nMathBackendCPU.nextDataId = 0;\n//# sourceMappingURL=backend_cpu.js.map"]},"metadata":{},"sourceType":"module"}