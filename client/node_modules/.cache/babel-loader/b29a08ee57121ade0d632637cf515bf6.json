{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _inherits from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _regeneratorRuntime from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer'; // Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n\n/**\n * Create a `LazyIterator` from an array of items.\n */\n\nexport function iteratorFromItems(items) {\n  return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\n\nexport function iteratorFromIncrementing(start) {\n  var i = start;\n  return iteratorFromFunction(function () {\n    return {\n      value: i++,\n      done: false\n    };\n  });\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\n\nexport function iteratorFromFunction(func) {\n  return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\n\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\n\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n  return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\n\nexport function iteratorFromZipped(iterators) {\n  var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n  return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\n\nexport var LazyIterator = /*#__PURE__*/function () {\n  function LazyIterator() {\n    _classCallCheck(this, LazyIterator);\n  }\n\n  _createClass(LazyIterator, [{\n    key: \"toArray\",\n    value:\n    /**\n     * Collect all remaining elements of a bounded stream into an array.\n     * Obviously this will succeed only for small streams that fit in memory.\n     * Useful for testing.\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    function () {\n      var _toArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var result, x;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                result = [];\n                _context.next = 3;\n                return this.next();\n\n              case 3:\n                x = _context.sent;\n\n              case 4:\n                if (x.done) {\n                  _context.next = 11;\n                  break;\n                }\n\n                result.push(x.value);\n                _context.next = 8;\n                return this.next();\n\n              case 8:\n                x = _context.sent;\n                _context.next = 4;\n                break;\n\n              case 11:\n                return _context.abrupt(\"return\", result);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function toArray() {\n        return _toArray.apply(this, arguments);\n      }\n\n      return toArray;\n    }()\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n\n  }, {\n    key: \"toArrayForTest\",\n    value: function () {\n      var _toArrayForTest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var stream, result, x;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                stream = this.prefetch(100);\n                result = [];\n                _context2.next = 4;\n                return stream.next();\n\n              case 4:\n                x = _context2.sent;\n\n              case 5:\n                if (x.done) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                result.push(x.value);\n                _context2.next = 9;\n                return stream.next();\n\n              case 9:\n                x = _context2.sent;\n                _context2.next = 5;\n                break;\n\n              case 12:\n                return _context2.abrupt(\"return\", result);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function toArrayForTest() {\n        return _toArrayForTest.apply(this, arguments);\n      }\n\n      return toArrayForTest;\n    }()\n    /**\n     * Draw items from the stream until it is exhausted.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n\n  }, {\n    key: \"resolveFully\",\n    value: function () {\n      var _resolveFully = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var x;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.next();\n\n              case 2:\n                x = _context3.sent;\n\n              case 3:\n                if (x.done) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.next = 6;\n                return this.next();\n\n              case 6:\n                x = _context3.sent;\n                _context3.next = 3;\n                break;\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function resolveFully() {\n        return _resolveFully.apply(this, arguments);\n      }\n\n      return resolveFully;\n    }()\n    /**\n     * Draw items from the stream until it is exhausted, or a predicate fails.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n\n  }, {\n    key: \"resolveWhile\",\n    value: function () {\n      var _resolveWhile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(predicate) {\n        var x, shouldContinue;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.next();\n\n              case 2:\n                x = _context4.sent;\n                shouldContinue = predicate(x.value);\n\n              case 4:\n                if (!(!x.done && shouldContinue)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this.next();\n\n              case 7:\n                x = _context4.sent;\n                shouldContinue = predicate(x.value);\n                _context4.next = 4;\n                break;\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function resolveWhile(_x) {\n        return _resolveWhile.apply(this, arguments);\n      }\n\n      return resolveWhile;\n    }()\n    /**\n     * Handles errors thrown on this stream using a provided handler function.\n     *\n     * @param handler A function that handles any `Error` thrown during a `next()`\n     *   call and returns true if the stream should continue (dropping the failed\n     *   call) or false if the stream should quietly terminate.  If the handler\n     *   itself throws (or rethrows) an `Error`, that will be propagated.\n     *\n     * @returns A `LazyIterator` of elements passed through from upstream,\n     *   possibly filtering or terminating on upstream `next()` calls that\n     *   throw an `Error`.\n     */\n\n  }, {\n    key: \"handleErrors\",\n    value: function handleErrors(handler) {\n      return new ErrorHandlingLazyIterator(this, handler);\n    } // TODO(soergel): Implement reduce() etc.\n\n    /**\n     * Filters this stream according to `predicate`.\n     *\n     * @param predicate A function mapping a stream element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `LazyIterator` of elements for which the predicate was true.\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(predicate) {\n      return new FilterIterator(this, predicate);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(transform) {\n      return new MapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through an async 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a `Promise` for a\n     *   transformed stream element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n\n  }, {\n    key: \"mapAsync\",\n    value: function mapAsync(transform) {\n      return new AsyncMapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform, forcing serial execution.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n\n  }, {\n    key: \"serialMapAsync\",\n    value: function serialMapAsync(transform) {\n      return new AsyncMapIterator(this, transform).serial();\n    }\n    /**\n     * Maps this stream through a 1-to-many transform.\n     *\n     * @param transform A function mapping a stream element to an array of\n     *   transformed elements.\n     *\n     * @returns A `DataStream` of transformed elements.\n     */\n\n  }, {\n    key: \"flatmap\",\n    value: function flatmap(transform) {\n      return new FlatmapIterator(this, transform);\n    }\n    /**\n     * Apply a function to every element of the stream.\n     *\n     * @param f A function to apply to each stream element.\n     */\n\n  }, {\n    key: \"forEachAsync\",\n    value: function () {\n      var _forEachAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(f) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.map(f).resolveFully());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function forEachAsync(_x2) {\n        return _forEachAsync.apply(this, arguments);\n      }\n\n      return forEachAsync;\n    }()\n    /**\n     * Apply a function to every element of the stream, forcing serial execution.\n     *\n     * @param f A function to apply to each stream element.  Should return 'true'\n     *   to indicate that the stream should continue, or 'false' to cause it to\n     *   terminate.\n     */\n\n  }, {\n    key: \"serialForEach\",\n    value: function () {\n      var _serialForEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(f) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.serialMapAsync(f).resolveWhile(function (x) {\n                  return x === true;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function serialForEach(_x3) {\n        return _serialForEach.apply(this, arguments);\n      }\n\n      return serialForEach;\n    }()\n    /**\n     * Groups elements into batches, represented as arrays of elements.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n     * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n     * form, which is needed for vectorized computation.\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `LazyIterator` of batches of elements, represented as arrays\n     *   of the original element type.\n     */\n\n  }, {\n    key: \"rowMajorBatch\",\n    value: function rowMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n    /**\n     * Groups elements into batches, represented in column-major form.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"column-major\" means that the resulting batch is a (potentially\n     * nested) structure representing the columns.  Each column entry, then,\n     * contains a collection of the values found in that column for a range of\n     * input elements.  This representation allows for vectorized computation, in\n     * contrast to the row-major form.\n     *\n     * The inputs should all have the same nested structure (i.e., of arrays and\n     * dicts).  The result is a single object with the same nested structure,\n     * where the leaves are arrays collecting the values of the inputs at that\n     * location (or, optionally, the result of a custom function applied to those\n     * arrays).\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @param zipFn: (optional) A function that expects an array of elements at a\n     *   single node of the object tree, and returns a `DeepMapResult`.  The\n     *   `DeepMapResult` either provides a result value for that node (i.e.,\n     *   representing the subtree), or indicates that the node should be processed\n     *   recursively.  The default zipFn recurses as far as possible and places\n     *   arrays at the leaves.\n     * @returns A `LazyIterator` of batches of elements, represented as an object\n     *   with collections at the leaves.\n     */\n\n  }, {\n    key: \"columnMajorBatch\",\n    value: function columnMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var zipFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : zipToList;\n      // First collect the desired number of input elements as a row-major batch.\n      var rowBatches = this.rowMajorBatch(batchSize, smallLastBatch); // Now 'rotate' or 'pivot' the data, collecting all values from each column\n      // in the batch (i.e., for each key within the elements) into an array.\n\n      return rowBatches.map(function (x) {\n        return deepZip(x, zipFn);\n      });\n    }\n    /**\n     * Concatenate this `LazyIterator` with another.\n     *\n     * @param iterator A `LazyIterator` to be concatenated onto this one.\n     * @param baseErrorHandler An optional function that can intercept `Error`s\n     *   raised during a `next()` call on the base stream.  This function can\n     *   decide whether the error should be propagated, whether the error should\n     *   be ignored, or whether the base stream should be terminated.\n     * @returns A `LazyIterator`.\n     */\n\n  }, {\n    key: \"concatenate\",\n    value: function concatenate(iterator, baseErrorHandler) {\n      return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n    /**\n     * Limits this stream to return at most `count` items.\n     *\n     * @param count The maximum number of items to provide from the stream. If\n     * a negative or undefined value is given, the entire stream is returned\n     *   unaltered.\n     */\n\n  }, {\n    key: \"take\",\n    value: function take(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n\n      return new TakeIterator(this, count);\n    }\n    /**\n     * Skips the first `count` items in this stream.\n     *\n     * @param count The number of items to skip.  If a negative or undefined\n     * value is given, the entire stream is returned unaltered.\n     */\n\n  }, {\n    key: \"skip\",\n    value: function skip(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n\n      return new SkipIterator(this, count);\n    }\n    /**\n     * Prefetch the first `bufferSize` items in this stream.\n     *\n     * Note this prefetches Promises, but makes no guarantees about when those\n     * Promises resolve.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     */\n\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(bufferSize) {\n      return new PrefetchIterator(this, bufferSize);\n    } // TODO(soergel): deep sharded shuffle, where supported\n\n    /**\n     * Randomly shuffles the elements of this stream.\n     *\n     * @param bufferSize: An integer specifying the number of elements from\n     * this stream from which the new stream will sample.\n     * @param seed: (Optional.) An integer specifying the random seed that\n     * will be used to create the distribution.\n     */\n\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(windowSize, seed) {\n      return new ShuffleIterator(this, windowSize, seed);\n    }\n    /**\n     * Force an iterator to execute serially: each next() call will await the\n     * prior one, so that they cannot execute concurrently.\n     */\n\n  }, {\n    key: \"serial\",\n    value: function serial() {\n      return new SerialIterator(this);\n    }\n  }]);\n\n  return LazyIterator;\n}(); // ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\n\nvar ArrayIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(ArrayIterator, _LazyIterator);\n\n  var _super = _createSuper(ArrayIterator);\n\n  function ArrayIterator(items) {\n    var _this;\n\n    _classCallCheck(this, ArrayIterator);\n\n    _this = _super.call(this);\n    _this.items = items;\n    _this.trav = 0;\n    return _this;\n  }\n\n  _createClass(ArrayIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Array of \".concat(this.items.length, \" items\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var item;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.trav >= this.items.length)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 2:\n                item = this.items[this.trav];\n                this.trav++;\n                return _context7.abrupt(\"return\", {\n                  value: deepClone(item),\n                  done: false\n                });\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function next() {\n        return _next.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }]);\n\n  return ArrayIterator;\n}(LazyIterator);\n\nvar FunctionCallIterator = /*#__PURE__*/function (_LazyIterator2) {\n  _inherits(FunctionCallIterator, _LazyIterator2);\n\n  var _super2 = _createSuper(FunctionCallIterator);\n\n  function FunctionCallIterator(nextFn) {\n    var _this2;\n\n    _classCallCheck(this, FunctionCallIterator);\n\n    _this2 = _super2.call(this);\n    _this2.nextFn = nextFn;\n    return _this2;\n  }\n\n  _createClass(FunctionCallIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Function call\";\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                return _context8.abrupt(\"return\", this.nextFn());\n\n              case 4:\n                _context8.prev = 4;\n                _context8.t0 = _context8[\"catch\"](0);\n                // Modify the error message but leave the stack trace intact\n                _context8.t0.message = \"Error thrown while iterating through a dataset: \".concat(_context8.t0.message);\n                throw _context8.t0;\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 4]]);\n      }));\n\n      function next() {\n        return _next2.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }]);\n\n  return FunctionCallIterator;\n}(LazyIterator);\n\nvar SerialIterator = /*#__PURE__*/function (_LazyIterator3) {\n  _inherits(SerialIterator, _LazyIterator3);\n\n  var _super3 = _createSuper(SerialIterator);\n\n  function SerialIterator(upstream) {\n    var _this3;\n\n    _classCallCheck(this, SerialIterator);\n\n    _this3 = _super3.call(this);\n    _this3.upstream = upstream;\n    _this3.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this3;\n  }\n\n  _createClass(SerialIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Serial\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this4.serialNext();\n                });\n                return _context9.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function next() {\n        return _next3.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this.upstream.next());\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function serialNext() {\n        return _serialNext.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return SerialIterator;\n}(LazyIterator);\n\nvar SkipIterator = /*#__PURE__*/function (_LazyIterator4) {\n  _inherits(SkipIterator, _LazyIterator4);\n\n  var _super4 = _createSuper(SkipIterator);\n\n  function SkipIterator(upstream, maxCount) {\n    var _this5;\n\n    _classCallCheck(this, SkipIterator);\n\n    _this5 = _super4.call(this);\n    _this5.upstream = upstream;\n    _this5.maxCount = maxCount; // Local state that should not be clobbered by out-of-order execution.\n\n    _this5.count = 0;\n    _this5.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this5;\n  }\n\n  _createClass(SkipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Skip\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var _this6 = this;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this6.serialNext();\n                });\n                return _context11.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function next() {\n        return _next4.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var skipped;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!(this.count++ < this.maxCount)) {\n                  _context12.next = 9;\n                  break;\n                }\n\n                _context12.next = 3;\n                return this.upstream.next();\n\n              case 3:\n                skipped = _context12.sent;\n\n                if (!skipped.done) {\n                  _context12.next = 6;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", skipped);\n\n              case 6:\n                tf.dispose(skipped.value);\n                _context12.next = 0;\n                break;\n\n              case 9:\n                return _context12.abrupt(\"return\", this.upstream.next());\n\n              case 10:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function serialNext() {\n        return _serialNext2.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return SkipIterator;\n}(LazyIterator);\n\nvar TakeIterator = /*#__PURE__*/function (_LazyIterator5) {\n  _inherits(TakeIterator, _LazyIterator5);\n\n  var _super5 = _createSuper(TakeIterator);\n\n  function TakeIterator(upstream, maxCount) {\n    var _this7;\n\n    _classCallCheck(this, TakeIterator);\n\n    _this7 = _super5.call(this);\n    _this7.upstream = upstream;\n    _this7.maxCount = maxCount;\n    _this7.count = 0;\n    return _this7;\n  }\n\n  _createClass(TakeIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Take\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!(this.count++ >= this.maxCount)) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 2:\n                return _context13.abrupt(\"return\", this.upstream.next());\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function next() {\n        return _next5.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }]);\n\n  return TakeIterator;\n}(LazyIterator); // Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\n\n\nvar RowMajorBatchIterator = /*#__PURE__*/function (_LazyIterator6) {\n  _inherits(RowMajorBatchIterator, _LazyIterator6);\n\n  var _super6 = _createSuper(RowMajorBatchIterator);\n\n  function RowMajorBatchIterator(upstream, batchSize) {\n    var _this8;\n\n    var enableSmallLastBatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    _classCallCheck(this, RowMajorBatchIterator);\n\n    _this8 = _super6.call(this);\n    _this8.upstream = upstream;\n    _this8.batchSize = batchSize;\n    _this8.enableSmallLastBatch = enableSmallLastBatch;\n    _this8.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this8;\n  }\n\n  _createClass(RowMajorBatchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> RowMajorBatch\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var _this9 = this;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this9.serialNext();\n                });\n                return _context14.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function next() {\n        return _next6.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        var batch, item;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                batch = [];\n\n              case 1:\n                if (!(batch.length < this.batchSize)) {\n                  _context15.next = 12;\n                  break;\n                }\n\n                _context15.next = 4;\n                return this.upstream.next();\n\n              case 4:\n                item = _context15.sent;\n\n                if (!item.done) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                if (!(this.enableSmallLastBatch && batch.length > 0)) {\n                  _context15.next = 8;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", {\n                  value: batch,\n                  done: false\n                });\n\n              case 8:\n                return _context15.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 9:\n                batch.push(item.value);\n                _context15.next = 1;\n                break;\n\n              case 12:\n                return _context15.abrupt(\"return\", {\n                  value: batch,\n                  done: false\n                });\n\n              case 13:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function serialNext() {\n        return _serialNext3.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return RowMajorBatchIterator;\n}(LazyIterator);\n\nvar FilterIterator = /*#__PURE__*/function (_LazyIterator7) {\n  _inherits(FilterIterator, _LazyIterator7);\n\n  var _super7 = _createSuper(FilterIterator);\n\n  function FilterIterator(upstream, predicate) {\n    var _this10;\n\n    _classCallCheck(this, FilterIterator);\n\n    _this10 = _super7.call(this);\n    _this10.upstream = upstream;\n    _this10.predicate = predicate;\n    _this10.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this10;\n  }\n\n  _createClass(FilterIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Filter\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var _this11 = this;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this11.serialNext();\n                });\n                return _context16.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function next() {\n        return _next7.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        var item;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!true) {\n                  _context17.next = 9;\n                  break;\n                }\n\n                _context17.next = 3;\n                return this.upstream.next();\n\n              case 3:\n                item = _context17.sent;\n\n                if (!(item.done || this.predicate(item.value))) {\n                  _context17.next = 6;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", item);\n\n              case 6:\n                tf.dispose(item.value);\n                _context17.next = 0;\n                break;\n\n              case 9:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function serialNext() {\n        return _serialNext4.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return FilterIterator;\n}(LazyIterator);\n\nvar MapIterator = /*#__PURE__*/function (_LazyIterator8) {\n  _inherits(MapIterator, _LazyIterator8);\n\n  var _super8 = _createSuper(MapIterator);\n\n  function MapIterator(upstream, transform) {\n    var _this12;\n\n    _classCallCheck(this, MapIterator);\n\n    _this12 = _super8.call(this);\n    _this12.upstream = upstream;\n    _this12.transform = transform;\n    return _this12;\n  }\n\n  _createClass(MapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Map\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var item, inputTensors, mapped, outputTensors, _iterator, _step, t;\n\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.upstream.next();\n\n              case 2:\n                item = _context18.sent;\n\n                if (!item.done) {\n                  _context18.next = 5;\n                  break;\n                }\n\n                return _context18.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 5:\n                inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n                // That's why we have to remember the input Tensors above, and then\n                // below dispose only those that were not passed through to the output.\n                // Note too that the transform function is responsible for tidying\n                // any intermediate Tensors.  Here we are concerned only about the\n                // inputs.\n\n                mapped = this.transform(item.value);\n                outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n                // TODO(soergel) move to tf.disposeExcept(in, out)?\n\n                _iterator = _createForOfIteratorHelper(inputTensors);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    t = _step.value;\n\n                    if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                      t.dispose();\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return _context18.abrupt(\"return\", {\n                  value: mapped,\n                  done: false\n                });\n\n              case 11:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function next() {\n        return _next8.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }]);\n\n  return MapIterator;\n}(LazyIterator);\n\nvar ErrorHandlingLazyIterator = /*#__PURE__*/function (_LazyIterator9) {\n  _inherits(ErrorHandlingLazyIterator, _LazyIterator9);\n\n  var _super9 = _createSuper(ErrorHandlingLazyIterator);\n\n  function ErrorHandlingLazyIterator(upstream, handler) {\n    var _this13;\n\n    _classCallCheck(this, ErrorHandlingLazyIterator);\n\n    _this13 = _super9.call(this);\n    _this13.upstream = upstream;\n    _this13.handler = handler;\n    _this13.count = 0;\n    _this13.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this13;\n  }\n\n  _createClass(ErrorHandlingLazyIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> handleErrors\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n        var _this14 = this;\n\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this14.serialNext();\n                });\n                return _context19.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function next() {\n        return _next9.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!true) {\n                  _context20.next = 13;\n                  break;\n                }\n\n                _context20.prev = 1;\n                _context20.next = 4;\n                return this.upstream.next();\n\n              case 4:\n                return _context20.abrupt(\"return\", _context20.sent);\n\n              case 7:\n                _context20.prev = 7;\n                _context20.t0 = _context20[\"catch\"](1);\n\n                if (this.handler(_context20.t0)) {\n                  _context20.next = 11;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 11:\n                _context20.next = 0;\n                break;\n\n              case 13:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[1, 7]]);\n      }));\n\n      function serialNext() {\n        return _serialNext5.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return ErrorHandlingLazyIterator;\n}(LazyIterator);\n\nvar AsyncMapIterator = /*#__PURE__*/function (_LazyIterator10) {\n  _inherits(AsyncMapIterator, _LazyIterator10);\n\n  var _super10 = _createSuper(AsyncMapIterator);\n\n  function AsyncMapIterator(upstream, transform) {\n    var _this15;\n\n    _classCallCheck(this, AsyncMapIterator);\n\n    _this15 = _super10.call(this);\n    _this15.upstream = upstream;\n    _this15.transform = transform;\n    return _this15;\n  }\n\n  _createClass(AsyncMapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> AsyncMap\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n        var item, inputTensors, mapped, outputTensors, _iterator2, _step2, t;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.upstream.next();\n\n              case 2:\n                item = _context21.sent;\n\n                if (!item.done) {\n                  _context21.next = 5;\n                  break;\n                }\n\n                return _context21.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 5:\n                inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n                // That's why we have to remember the input Tensors above, and then\n                // below dispose only those that were not passed through to the output.\n                // Note too that the transform function is responsible for tidying\n                // any intermediate Tensors.  Here we are concerned only about the\n                // inputs.\n\n                _context21.next = 8;\n                return this.transform(item.value);\n\n              case 8:\n                mapped = _context21.sent;\n                outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n                // TODO(soergel) move to tf.disposeExcept(in, out)?\n\n                _iterator2 = _createForOfIteratorHelper(inputTensors);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    t = _step2.value;\n\n                    if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                      t.dispose();\n                    }\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                return _context21.abrupt(\"return\", {\n                  value: mapped,\n                  done: false\n                });\n\n              case 13:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function next() {\n        return _next10.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }]);\n\n  return AsyncMapIterator;\n}(LazyIterator); // Iterators that maintain a queue of pending items\n// ============================================================================\n\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\n\n\nexport var OneToManyIterator = /*#__PURE__*/function (_LazyIterator11) {\n  _inherits(OneToManyIterator, _LazyIterator11);\n\n  var _super11 = _createSuper(OneToManyIterator);\n\n  function OneToManyIterator() {\n    var _this16;\n\n    _classCallCheck(this, OneToManyIterator);\n\n    _this16 = _super11.call(this);\n    _this16.outputQueue = new GrowingRingBuffer();\n    _this16.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this16;\n  }\n\n  _createClass(OneToManyIterator, [{\n    key: \"next\",\n    value: function () {\n      var _next11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n        var _this17 = this;\n\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this17.serialNext();\n                });\n                return _context22.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function next() {\n        return _next11.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                if (!(this.outputQueue.length() === 0)) {\n                  _context23.next = 7;\n                  break;\n                }\n\n                _context23.next = 3;\n                return this.pump();\n\n              case 3:\n                if (_context23.sent) {\n                  _context23.next = 5;\n                  break;\n                }\n\n                return _context23.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 5:\n                _context23.next = 0;\n                break;\n\n              case 7:\n                return _context23.abrupt(\"return\", {\n                  value: this.outputQueue.shift(),\n                  done: false\n                });\n\n              case 8:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function serialNext() {\n        return _serialNext6.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return OneToManyIterator;\n}(LazyIterator);\n\nvar FlatmapIterator = /*#__PURE__*/function (_OneToManyIterator) {\n  _inherits(FlatmapIterator, _OneToManyIterator);\n\n  var _super12 = _createSuper(FlatmapIterator);\n\n  function FlatmapIterator(upstream, transform) {\n    var _this18;\n\n    _classCallCheck(this, FlatmapIterator);\n\n    _this18 = _super12.call(this);\n    _this18.upstream = upstream;\n    _this18.transform = transform;\n    return _this18;\n  }\n\n  _createClass(FlatmapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Flatmap\");\n    }\n  }, {\n    key: \"pump\",\n    value: function () {\n      var _pump = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {\n        var item, inputTensors, mappedArray, outputTensors, _iterator3, _step3, t;\n\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.upstream.next();\n\n              case 2:\n                item = _context24.sent;\n\n                if (!item.done) {\n                  _context24.next = 5;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", false);\n\n              case 5:\n                inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n                // that's why we have to remember the input Tensors above, and then\n                // below dispose only those that were not passed through to the output.\n                // Note too that the transform function is responsible for tidying any\n                // intermediate Tensors.  Here we are concerned only about the inputs.\n\n                mappedArray = this.transform(item.value);\n                outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n                this.outputQueue.pushAll(mappedArray); // TODO(soergel) faster intersection, and deduplicate outputTensors\n                // TODO(soergel) move to tf.disposeExcept(in, out)?\n\n                _iterator3 = _createForOfIteratorHelper(inputTensors);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    t = _step3.value;\n\n                    if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                      t.dispose();\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                return _context24.abrupt(\"return\", true);\n\n              case 12:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function pump() {\n        return _pump.apply(this, arguments);\n      }\n\n      return pump;\n    }()\n  }]);\n\n  return FlatmapIterator;\n}(OneToManyIterator);\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\n\n\nexport var ChainedIterator = /*#__PURE__*/function (_LazyIterator12) {\n  _inherits(ChainedIterator, _LazyIterator12);\n\n  var _super13 = _createSuper(ChainedIterator);\n\n  function ChainedIterator(iterators, baseErrorHandler) {\n    var _this19;\n\n    _classCallCheck(this, ChainedIterator);\n\n    _this19 = _super13.call(this);\n    _this19.baseErrorHandler = baseErrorHandler; // Strict Promise execution order:\n    // a next() call may not even begin until the previous one completes.\n\n    _this19.lastRead = null; // Local state that should not be clobbered by out-of-order execution.\n\n    _this19.iterator = null;\n    _this19.moreIterators = iterators;\n    return _this19;\n  }\n\n  _createClass(ChainedIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n      return \"\".concat(upstreamSummaries, \" -> Chained\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                this.lastRead = this.readFromChain(this.lastRead);\n                return _context25.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function next() {\n        return _next12.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"readFromChain\",\n    value: function () {\n      var _readFromChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(lastRead) {\n        var iteratorResult, itemResult;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return lastRead;\n\n              case 2:\n                if (!(this.iterator == null)) {\n                  _context26.next = 10;\n                  break;\n                }\n\n                _context26.next = 5;\n                return this.moreIterators.next();\n\n              case 5:\n                iteratorResult = _context26.sent;\n\n                if (!iteratorResult.done) {\n                  _context26.next = 8;\n                  break;\n                }\n\n                return _context26.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 8:\n                this.iterator = iteratorResult.value;\n\n                if (this.baseErrorHandler != null) {\n                  this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n                }\n\n              case 10:\n                _context26.next = 12;\n                return this.iterator.next();\n\n              case 12:\n                itemResult = _context26.sent;\n\n                if (!itemResult.done) {\n                  _context26.next = 16;\n                  break;\n                }\n\n                this.iterator = null;\n                return _context26.abrupt(\"return\", this.readFromChain(lastRead));\n\n              case 16:\n                return _context26.abrupt(\"return\", itemResult);\n\n              case 17:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function readFromChain(_x4) {\n        return _readFromChain.apply(this, arguments);\n      }\n\n      return readFromChain;\n    }()\n  }]);\n\n  return ChainedIterator;\n}(LazyIterator);\nexport var ZipMismatchMode;\n\n(function (ZipMismatchMode) {\n  ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n  ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n  ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\n\n\nvar ZipIterator = /*#__PURE__*/function (_LazyIterator13) {\n  _inherits(ZipIterator, _LazyIterator13);\n\n  var _super14 = _createSuper(ZipIterator);\n\n  function ZipIterator(iterators) {\n    var _this20;\n\n    var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n\n    _classCallCheck(this, ZipIterator);\n\n    _this20 = _super14.call(this);\n    _this20.iterators = iterators;\n    _this20.mismatchMode = mismatchMode;\n    _this20.count = 0;\n    _this20.currentPromise = null;\n    return _this20;\n  }\n\n  _createClass(ZipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n      return \"{\".concat(upstreamSummaries, \"} -> Zip\");\n    }\n  }, {\n    key: \"nextState\",\n    value: function () {\n      var _nextState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(afterState) {\n        var numIterators, iteratorsDone, getNext, mapped;\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                getNext = function _getNext(container) {\n                  if (container instanceof LazyIterator) {\n                    var result = container.next();\n                    return {\n                      value: result.then(function (x) {\n                        numIterators++;\n\n                        if (x.done) {\n                          iteratorsDone++;\n                        }\n\n                        return x.value;\n                      }),\n                      recurse: false\n                    };\n                  } else {\n                    return {\n                      value: null,\n                      recurse: true\n                    };\n                  }\n                };\n\n                _context27.next = 3;\n                return afterState;\n\n              case 3:\n                // Collect underlying iterator \"done\" signals as a side effect in\n                // getNext()\n                numIterators = 0;\n                iteratorsDone = 0;\n                _context27.next = 7;\n                return deepMapAndAwaitAll(this.iterators, getNext);\n\n              case 7:\n                mapped = _context27.sent;\n\n                if (!(numIterators === iteratorsDone)) {\n                  _context27.next = 10;\n                  break;\n                }\n\n                return _context27.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 10:\n                if (!(iteratorsDone > 0)) {\n                  _context27.next = 16;\n                  break;\n                }\n\n                _context27.t0 = this.mismatchMode;\n                _context27.next = _context27.t0 === ZipMismatchMode.FAIL ? 14 : _context27.t0 === ZipMismatchMode.SHORTEST ? 15 : _context27.t0 === ZipMismatchMode.LONGEST ? 16 : 16;\n                break;\n\n              case 14:\n                throw new Error('Zipped streams should have the same length. ' + \"Mismatched at element \".concat(this.count, \".\"));\n\n              case 15:\n                return _context27.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 16:\n                this.count++;\n                return _context27.abrupt(\"return\", {\n                  value: mapped,\n                  done: false\n                });\n\n              case 18:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function nextState(_x5) {\n        return _nextState.apply(this, arguments);\n      }\n\n      return nextState;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                this.currentPromise = this.nextState(this.currentPromise);\n                return _context28.abrupt(\"return\", this.currentPromise);\n\n              case 2:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function next() {\n        return _next13.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }]);\n\n  return ZipIterator;\n}(LazyIterator); // Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\n\n\nexport var PrefetchIterator = /*#__PURE__*/function (_LazyIterator14) {\n  _inherits(PrefetchIterator, _LazyIterator14);\n\n  var _super15 = _createSuper(PrefetchIterator);\n\n  function PrefetchIterator(upstream, bufferSize) {\n    var _this21;\n\n    _classCallCheck(this, PrefetchIterator);\n\n    _this21 = _super15.call(this);\n    _this21.upstream = upstream;\n    _this21.bufferSize = bufferSize;\n    _this21.buffer = new RingBuffer(bufferSize);\n    return _this21;\n  }\n\n  _createClass(PrefetchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Prefetch\");\n    }\n    /**\n     * Refill the prefetch buffer.  Returns only after the buffer is full, or\n     * the upstream source is exhausted.\n     */\n\n  }, {\n    key: \"refill\",\n    value: function refill() {\n      while (!this.buffer.isFull()) {\n        var v = this.upstream.next();\n        this.buffer.push(v);\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.refill(); // This shift will never throw an error because the buffer is always\n      // full after a refill. If the stream is exhausted, the buffer will be\n      // full of Promises that will resolve to the end-of-stream signal.\n\n      return this.buffer.shift();\n    }\n  }]);\n\n  return PrefetchIterator;\n}(LazyIterator);\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\n\nexport var ShuffleIterator = /*#__PURE__*/function (_PrefetchIterator) {\n  _inherits(ShuffleIterator, _PrefetchIterator);\n\n  var _super16 = _createSuper(ShuffleIterator);\n\n  function ShuffleIterator(upstream, windowSize, seed) {\n    var _this22;\n\n    _classCallCheck(this, ShuffleIterator);\n\n    _this22 = _super16.call(this, upstream, windowSize);\n    _this22.upstream = upstream;\n    _this22.windowSize = windowSize; // Local state that should not be clobbered by out-of-order execution.\n\n    _this22.upstreamExhausted = false;\n    _this22.random = seedrandom.alea(seed || tf.util.now().toString());\n    _this22.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this22;\n  }\n\n  _createClass(ShuffleIterator, [{\n    key: \"next\",\n    value: function () {\n      var _next14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n        var _this23 = this;\n\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                // This sets this.lastRead to a new Promise right away, as opposed to\n                // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n                // would not work because this.nextRead would be updated only after the\n                // promise resolves.\n                this.lastRead = this.lastRead.then(function () {\n                  return _this23.serialNext();\n                });\n                return _context29.abrupt(\"return\", this.lastRead);\n\n              case 2:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n\n      function next() {\n        return _next14.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"randomInt\",\n    value: function randomInt(max) {\n      return Math.floor(this.random() * max);\n    }\n  }, {\n    key: \"chooseIndex\",\n    value: function chooseIndex() {\n      return this.randomInt(this.buffer.length());\n    }\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30() {\n        var chosenIndex, result;\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                // TODO(soergel): consider performance\n                if (!this.upstreamExhausted) {\n                  this.refill();\n                }\n\n              case 1:\n                if (this.buffer.isEmpty()) {\n                  _context30.next = 14;\n                  break;\n                }\n\n                chosenIndex = this.chooseIndex();\n                _context30.next = 5;\n                return this.buffer.shuffleExcise(chosenIndex);\n\n              case 5:\n                result = _context30.sent;\n\n                if (!result.done) {\n                  _context30.next = 10;\n                  break;\n                }\n\n                this.upstreamExhausted = true;\n                _context30.next = 12;\n                break;\n\n              case 10:\n                this.refill();\n                return _context30.abrupt(\"return\", result);\n\n              case 12:\n                _context30.next = 1;\n                break;\n\n              case 14:\n                return _context30.abrupt(\"return\", {\n                  value: null,\n                  done: true\n                });\n\n              case 15:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n\n      function serialNext() {\n        return _serialNext7.apply(this, arguments);\n      }\n\n      return serialNext;\n    }()\n  }]);\n\n  return ShuffleIterator;\n}(PrefetchIterator);","map":{"version":3,"sources":["../../src/iterators/lazy_iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer';\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems(items) {\n    return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start) {\n    let i = start;\n    return iteratorFromFunction(() => ({ value: i++, done: false }));\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction(func) {\n    return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n    return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n    return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n    return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport class LazyIterator {\n    /**\n     * Collect all remaining elements of a bounded stream into an array.\n     * Obviously this will succeed only for small streams that fit in memory.\n     * Useful for testing.\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    async toArray() {\n        const result = [];\n        let x = await this.next();\n        while (!x.done) {\n            result.push(x.value);\n            x = await this.next();\n        }\n        return result;\n    }\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    async toArrayForTest() {\n        const stream = this.prefetch(100);\n        const result = [];\n        let x = await stream.next();\n        while (!x.done) {\n            result.push(x.value);\n            x = await stream.next();\n        }\n        return result;\n    }\n    /**\n     * Draw items from the stream until it is exhausted.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n    async resolveFully() {\n        let x = await this.next();\n        while (!x.done) {\n            x = await this.next();\n        }\n    }\n    /**\n     * Draw items from the stream until it is exhausted, or a predicate fails.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n    async resolveWhile(predicate) {\n        let x = await this.next();\n        let shouldContinue = predicate(x.value);\n        while ((!x.done) && shouldContinue) {\n            x = await this.next();\n            shouldContinue = predicate(x.value);\n        }\n    }\n    /**\n     * Handles errors thrown on this stream using a provided handler function.\n     *\n     * @param handler A function that handles any `Error` thrown during a `next()`\n     *   call and returns true if the stream should continue (dropping the failed\n     *   call) or false if the stream should quietly terminate.  If the handler\n     *   itself throws (or rethrows) an `Error`, that will be propagated.\n     *\n     * @returns A `LazyIterator` of elements passed through from upstream,\n     *   possibly filtering or terminating on upstream `next()` calls that\n     *   throw an `Error`.\n     */\n    handleErrors(handler) {\n        return new ErrorHandlingLazyIterator(this, handler);\n    }\n    // TODO(soergel): Implement reduce() etc.\n    /**\n     * Filters this stream according to `predicate`.\n     *\n     * @param predicate A function mapping a stream element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `LazyIterator` of elements for which the predicate was true.\n     */\n    filter(predicate) {\n        return new FilterIterator(this, predicate);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    map(transform) {\n        return new MapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through an async 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a `Promise` for a\n     *   transformed stream element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    mapAsync(transform) {\n        return new AsyncMapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform, forcing serial execution.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n    serialMapAsync(transform) {\n        return new AsyncMapIterator(this, transform).serial();\n    }\n    /**\n     * Maps this stream through a 1-to-many transform.\n     *\n     * @param transform A function mapping a stream element to an array of\n     *   transformed elements.\n     *\n     * @returns A `DataStream` of transformed elements.\n     */\n    flatmap(transform) {\n        return new FlatmapIterator(this, transform);\n    }\n    /**\n     * Apply a function to every element of the stream.\n     *\n     * @param f A function to apply to each stream element.\n     */\n    async forEachAsync(f) {\n        return this.map(f).resolveFully();\n    }\n    /**\n     * Apply a function to every element of the stream, forcing serial execution.\n     *\n     * @param f A function to apply to each stream element.  Should return 'true'\n     *   to indicate that the stream should continue, or 'false' to cause it to\n     *   terminate.\n     */\n    async serialForEach(f) {\n        return this.serialMapAsync(f).resolveWhile(x => (x === true));\n    }\n    /**\n     * Groups elements into batches, represented as arrays of elements.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n     * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n     * form, which is needed for vectorized computation.\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `LazyIterator` of batches of elements, represented as arrays\n     *   of the original element type.\n     */\n    rowMajorBatch(batchSize, smallLastBatch = true) {\n        return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n    /**\n     * Groups elements into batches, represented in column-major form.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"column-major\" means that the resulting batch is a (potentially\n     * nested) structure representing the columns.  Each column entry, then,\n     * contains a collection of the values found in that column for a range of\n     * input elements.  This representation allows for vectorized computation, in\n     * contrast to the row-major form.\n     *\n     * The inputs should all have the same nested structure (i.e., of arrays and\n     * dicts).  The result is a single object with the same nested structure,\n     * where the leaves are arrays collecting the values of the inputs at that\n     * location (or, optionally, the result of a custom function applied to those\n     * arrays).\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @param zipFn: (optional) A function that expects an array of elements at a\n     *   single node of the object tree, and returns a `DeepMapResult`.  The\n     *   `DeepMapResult` either provides a result value for that node (i.e.,\n     *   representing the subtree), or indicates that the node should be processed\n     *   recursively.  The default zipFn recurses as far as possible and places\n     *   arrays at the leaves.\n     * @returns A `LazyIterator` of batches of elements, represented as an object\n     *   with collections at the leaves.\n     */\n    columnMajorBatch(batchSize, smallLastBatch = true, \n    // tslint:disable-next-line:no-any\n    zipFn = zipToList) {\n        // First collect the desired number of input elements as a row-major batch.\n        const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n        // Now 'rotate' or 'pivot' the data, collecting all values from each column\n        // in the batch (i.e., for each key within the elements) into an array.\n        return rowBatches.map(x => deepZip(x, zipFn));\n    }\n    /**\n     * Concatenate this `LazyIterator` with another.\n     *\n     * @param iterator A `LazyIterator` to be concatenated onto this one.\n     * @param baseErrorHandler An optional function that can intercept `Error`s\n     *   raised during a `next()` call on the base stream.  This function can\n     *   decide whether the error should be propagated, whether the error should\n     *   be ignored, or whether the base stream should be terminated.\n     * @returns A `LazyIterator`.\n     */\n    concatenate(iterator, baseErrorHandler) {\n        return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n    /**\n     * Limits this stream to return at most `count` items.\n     *\n     * @param count The maximum number of items to provide from the stream. If\n     * a negative or undefined value is given, the entire stream is returned\n     *   unaltered.\n     */\n    take(count) {\n        if (count < 0 || count == null) {\n            return this;\n        }\n        return new TakeIterator(this, count);\n    }\n    /**\n     * Skips the first `count` items in this stream.\n     *\n     * @param count The number of items to skip.  If a negative or undefined\n     * value is given, the entire stream is returned unaltered.\n     */\n    skip(count) {\n        if (count < 0 || count == null) {\n            return this;\n        }\n        return new SkipIterator(this, count);\n    }\n    /**\n     * Prefetch the first `bufferSize` items in this stream.\n     *\n     * Note this prefetches Promises, but makes no guarantees about when those\n     * Promises resolve.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     */\n    prefetch(bufferSize) {\n        return new PrefetchIterator(this, bufferSize);\n    }\n    // TODO(soergel): deep sharded shuffle, where supported\n    /**\n     * Randomly shuffles the elements of this stream.\n     *\n     * @param bufferSize: An integer specifying the number of elements from\n     * this stream from which the new stream will sample.\n     * @param seed: (Optional.) An integer specifying the random seed that\n     * will be used to create the distribution.\n     */\n    shuffle(windowSize, seed) {\n        return new ShuffleIterator(this, windowSize, seed);\n    }\n    /**\n     * Force an iterator to execute serially: each next() call will await the\n     * prior one, so that they cannot execute concurrently.\n     */\n    serial() {\n        return new SerialIterator(this);\n    }\n}\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\nclass ArrayIterator extends LazyIterator {\n    constructor(items) {\n        super();\n        this.items = items;\n        this.trav = 0;\n    }\n    summary() {\n        return `Array of ${this.items.length} items`;\n    }\n    async next() {\n        if (this.trav >= this.items.length) {\n            return { value: null, done: true };\n        }\n        const item = this.items[this.trav];\n        this.trav++;\n        return { value: deepClone(item), done: false };\n    }\n}\nclass FunctionCallIterator extends LazyIterator {\n    constructor(nextFn) {\n        super();\n        this.nextFn = nextFn;\n    }\n    summary() {\n        return `Function call`;\n    }\n    async next() {\n        try {\n            return this.nextFn();\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message =\n                `Error thrown while iterating through a dataset: ${e.message}`;\n            throw e;\n        }\n    }\n}\nclass SerialIterator extends LazyIterator {\n    constructor(upstream) {\n        super();\n        this.upstream = upstream;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Serial`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        return this.upstream.next();\n    }\n}\nclass SkipIterator extends LazyIterator {\n    constructor(upstream, maxCount) {\n        super();\n        this.upstream = upstream;\n        this.maxCount = maxCount;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.count = 0;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Skip`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n        // collecting next() promises in an Array and then waiting for\n        // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n        // maybe delayed GC.\n        while (this.count++ < this.maxCount) {\n            const skipped = await this.upstream.next();\n            // short-circuit if upstream is already empty\n            if (skipped.done) {\n                return skipped;\n            }\n            tf.dispose(skipped.value);\n        }\n        return this.upstream.next();\n    }\n}\nclass TakeIterator extends LazyIterator {\n    constructor(upstream, maxCount) {\n        super();\n        this.upstream = upstream;\n        this.maxCount = maxCount;\n        this.count = 0;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Take`;\n    }\n    async next() {\n        if (this.count++ >= this.maxCount) {\n            return { value: null, done: true };\n        }\n        return this.upstream.next();\n    }\n}\n// Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nclass RowMajorBatchIterator extends LazyIterator {\n    constructor(upstream, batchSize, enableSmallLastBatch = true) {\n        super();\n        this.upstream = upstream;\n        this.batchSize = batchSize;\n        this.enableSmallLastBatch = enableSmallLastBatch;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> RowMajorBatch`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        const batch = [];\n        while (batch.length < this.batchSize) {\n            const item = await this.upstream.next();\n            if (item.done) {\n                if (this.enableSmallLastBatch && batch.length > 0) {\n                    return { value: batch, done: false };\n                }\n                return { value: null, done: true };\n            }\n            batch.push(item.value);\n        }\n        return { value: batch, done: false };\n    }\n}\nclass FilterIterator extends LazyIterator {\n    constructor(upstream, predicate) {\n        super();\n        this.upstream = upstream;\n        this.predicate = predicate;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Filter`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        while (true) {\n            const item = await this.upstream.next();\n            if (item.done || this.predicate(item.value)) {\n                return item;\n            }\n            tf.dispose(item.value);\n        }\n    }\n}\nclass MapIterator extends LazyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Map`;\n    }\n    async next() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return { value: null, done: true };\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // That's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying\n        // any intermediate Tensors.  Here we are concerned only about the\n        // inputs.\n        const mapped = this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n        // TODO(soergel) faster intersection\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return { value: mapped, done: false };\n    }\n}\nclass ErrorHandlingLazyIterator extends LazyIterator {\n    constructor(upstream, handler) {\n        super();\n        this.upstream = upstream;\n        this.handler = handler;\n        this.count = 0;\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    summary() {\n        return `${this.upstream.summary()} -> handleErrors`;\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        while (true) {\n            try {\n                return await this.upstream.next();\n            }\n            catch (e) {\n                if (!this.handler(e)) {\n                    return { value: null, done: true };\n                }\n                // If the handler returns true, loop and fetch the next upstream item.\n                // If the upstream iterator throws an endless stream of errors, and if\n                // the handler says to ignore them, then we loop forever here.  That is\n                // the correct behavior-- it's up to the handler to decide when to stop.\n            }\n        }\n    }\n}\nclass AsyncMapIterator extends LazyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> AsyncMap`;\n    }\n    async next() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return { value: null, done: true };\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // That's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying\n        // any intermediate Tensors.  Here we are concerned only about the\n        // inputs.\n        const mapped = await this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mapped);\n        // TODO(soergel) faster intersection\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return { value: mapped, done: false };\n    }\n}\n// Iterators that maintain a queue of pending items\n// ============================================================================\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport class OneToManyIterator extends LazyIterator {\n    constructor() {\n        super();\n        this.outputQueue = new GrowingRingBuffer();\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    async serialNext() {\n        // Fetch so that the queue contains at least one item if possible.\n        // If the upstream source is exhausted, AND there are no items left in\n        // the output queue, then this stream is also exhausted.\n        while (this.outputQueue.length() === 0) {\n            // TODO(soergel): consider parallel reads.\n            if (!await this.pump()) {\n                return { value: null, done: true };\n            }\n        }\n        return { value: this.outputQueue.shift(), done: false };\n    }\n}\nclass FlatmapIterator extends OneToManyIterator {\n    constructor(upstream, transform) {\n        super();\n        this.upstream = upstream;\n        this.transform = transform;\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Flatmap`;\n    }\n    async pump() {\n        const item = await this.upstream.next();\n        if (item.done) {\n            return false;\n        }\n        const inputTensors = tf.tensor_util.getTensorsInContainer(item.value);\n        // Careful: the transform may mutate the item in place.\n        // that's why we have to remember the input Tensors above, and then\n        // below dispose only those that were not passed through to the output.\n        // Note too that the transform function is responsible for tidying any\n        // intermediate Tensors.  Here we are concerned only about the inputs.\n        const mappedArray = this.transform(item.value);\n        const outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n        this.outputQueue.pushAll(mappedArray);\n        // TODO(soergel) faster intersection, and deduplicate outputTensors\n        // TODO(soergel) move to tf.disposeExcept(in, out)?\n        for (const t of inputTensors) {\n            if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                t.dispose();\n            }\n        }\n        return true;\n    }\n}\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport class ChainedIterator extends LazyIterator {\n    constructor(iterators, baseErrorHandler) {\n        super();\n        this.baseErrorHandler = baseErrorHandler;\n        // Strict Promise execution order:\n        // a next() call may not even begin until the previous one completes.\n        this.lastRead = null;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.iterator = null;\n        this.moreIterators = iterators;\n    }\n    summary() {\n        const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n        return `${upstreamSummaries} -> Chained`;\n    }\n    async next() {\n        this.lastRead = this.readFromChain(this.lastRead);\n        return this.lastRead;\n    }\n    async readFromChain(lastRead) {\n        // Must await on the previous read since the previous read may have advanced\n        // the stream of streams, from which we need to read.\n        // This is unfortunate since we can't parallelize reads. Which means\n        // prefetching of chained streams is a no-op.\n        // One solution is to prefetch immediately upstream of this.\n        await lastRead;\n        if (this.iterator == null) {\n            const iteratorResult = await this.moreIterators.next();\n            if (iteratorResult.done) {\n                // No more streams to stream from.\n                return { value: null, done: true };\n            }\n            this.iterator = iteratorResult.value;\n            if (this.baseErrorHandler != null) {\n                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n            }\n        }\n        const itemResult = await this.iterator.next();\n        if (itemResult.done) {\n            this.iterator = null;\n            return this.readFromChain(lastRead);\n        }\n        return itemResult;\n    }\n}\nexport var ZipMismatchMode;\n(function (ZipMismatchMode) {\n    ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n    ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n    ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nclass ZipIterator extends LazyIterator {\n    constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {\n        super();\n        this.iterators = iterators;\n        this.mismatchMode = mismatchMode;\n        this.count = 0;\n        this.currentPromise = null;\n    }\n    summary() {\n        const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n        return `{${upstreamSummaries}} -> Zip`;\n    }\n    async nextState(afterState) {\n        // This chaining ensures that the underlying next() are not even called\n        // before the previous ones have resolved.\n        await afterState;\n        // Collect underlying iterator \"done\" signals as a side effect in\n        // getNext()\n        let numIterators = 0;\n        let iteratorsDone = 0;\n        function getNext(container) {\n            if (container instanceof LazyIterator) {\n                const result = container.next();\n                return {\n                    value: result.then(x => {\n                        numIterators++;\n                        if (x.done) {\n                            iteratorsDone++;\n                        }\n                        return x.value;\n                    }),\n                    recurse: false\n                };\n            }\n            else {\n                return { value: null, recurse: true };\n            }\n        }\n        const mapped = await deepMapAndAwaitAll(this.iterators, getNext);\n        if (numIterators === iteratorsDone) {\n            // The streams have all ended.\n            return { value: null, done: true };\n        }\n        if (iteratorsDone > 0) {\n            switch (this.mismatchMode) {\n                case ZipMismatchMode.FAIL:\n                    throw new Error('Zipped streams should have the same length. ' +\n                        `Mismatched at element ${this.count}.`);\n                case ZipMismatchMode.SHORTEST:\n                    return { value: null, done: true };\n                case ZipMismatchMode.LONGEST:\n                default:\n                // Continue.  The exhausted streams already produced value: null.\n            }\n        }\n        this.count++;\n        return { value: mapped, done: false };\n    }\n    async next() {\n        this.currentPromise = this.nextState(this.currentPromise);\n        return this.currentPromise;\n    }\n}\n// Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport class PrefetchIterator extends LazyIterator {\n    constructor(upstream, bufferSize) {\n        super();\n        this.upstream = upstream;\n        this.bufferSize = bufferSize;\n        this.buffer = new RingBuffer(bufferSize);\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Prefetch`;\n    }\n    /**\n     * Refill the prefetch buffer.  Returns only after the buffer is full, or\n     * the upstream source is exhausted.\n     */\n    refill() {\n        while (!this.buffer.isFull()) {\n            const v = this.upstream.next();\n            this.buffer.push(v);\n        }\n    }\n    next() {\n        this.refill();\n        // This shift will never throw an error because the buffer is always\n        // full after a refill. If the stream is exhausted, the buffer will be\n        // full of Promises that will resolve to the end-of-stream signal.\n        return this.buffer.shift();\n    }\n}\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport class ShuffleIterator extends PrefetchIterator {\n    constructor(upstream, windowSize, seed) {\n        super(upstream, windowSize);\n        this.upstream = upstream;\n        this.windowSize = windowSize;\n        // Local state that should not be clobbered by out-of-order execution.\n        this.upstreamExhausted = false;\n        this.random = seedrandom.alea(seed || tf.util.now().toString());\n        this.lastRead = Promise.resolve({ value: null, done: false });\n    }\n    async next() {\n        // This sets this.lastRead to a new Promise right away, as opposed to\n        // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n        // would not work because this.nextRead would be updated only after the\n        // promise resolves.\n        this.lastRead = this.lastRead.then(() => this.serialNext());\n        return this.lastRead;\n    }\n    randomInt(max) {\n        return Math.floor(this.random() * max);\n    }\n    chooseIndex() {\n        return this.randomInt(this.buffer.length());\n    }\n    async serialNext() {\n        // TODO(soergel): consider performance\n        if (!this.upstreamExhausted) {\n            this.refill();\n        }\n        while (!this.buffer.isEmpty()) {\n            const chosenIndex = this.chooseIndex();\n            const result = await this.buffer.shuffleExcise(chosenIndex);\n            if (result.done) {\n                this.upstreamExhausted = true;\n            }\n            else {\n                this.refill();\n                return result;\n            }\n        }\n        return { value: null, done: true };\n    }\n}\n//# sourceMappingURL=lazy_iterator.js.map"]},"metadata":{},"sourceType":"module"}