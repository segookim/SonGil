{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n  constructor(gpgpu) {\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0; // How many bytes that have been allocated\n    // are available for reuse.\n\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n\n  acquireTexture(shapeRC, usage, isPacked) {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture;\n\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n\n    this.usedTextures[shapeKey].push(newTexture);\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n    return newTexture;\n  }\n\n  releaseTexture(texture, shape, logicalTexType, isPacked) {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n\n    if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n\n    if (texIndex < 0) {\n      throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n    }\n\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  log() {\n    if (!this.logEnabled) {\n      return;\n    }\n\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated() {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree() {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures() {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures() {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n\n}\n\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  const glany = gl;\n\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  }\n\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  let numElements;\n\n  if (isPacked) {\n    const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n  } else {\n    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}","map":{"version":3,"sources":["../src/texture_manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n        const freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n    }\n    get numBytesAllocated() {\n        return this._numBytesAllocated;\n    }\n    get numBytesFree() {\n        return this._numBytesFree;\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    let numElements;\n    if (isPacked) {\n        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = width * height;\n    }\n    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(`Unknown physical texture type ${physicalTexType}`);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n//# sourceMappingURL=texture_manager.js.map"]},"metadata":{},"sourceType":"module"}