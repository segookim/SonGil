{"ast":null,"code":"import _classCallCheck from \"/Users/kimkiwoong/SonGil/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\n\nexport var MirrorPadPackedProgram = function MirrorPadPackedProgram(xShape, paddings, mode) {\n  _classCallCheck(this, MirrorPadPackedProgram);\n\n  this.variableNames = ['x'];\n  this.packedInputs = true;\n  this.packedOutput = true;\n  this.outputShape = paddings.map(function (p, i) {\n    return p[0]\n    /* beforePad */\n    + xShape[i] + p[1];\n  }\n  /* afterPad */\n  );\n  var rank = xShape.length;\n  var dtype = getCoordsDataType(rank);\n  var start = paddings.map(function (p) {\n    return p[0];\n  }).join(',');\n  var end = paddings.map(function (p, i) {\n    return p[0] + xShape[i];\n  }).join(',');\n  var coords = getChannels('rc', rank);\n  var source = getChannels('source', rank);\n  var cLimit = \"\".concat(coords[rank - 1], \" < \").concat(this.outputShape[rank - 1]);\n  var innerDims = rank === 1 ? 'source' : \"vec2(\".concat(source.slice(-2).join(), \")\");\n  var offset = mode === 'reflect' ? 0 : 1;\n  var mainLoop = '';\n\n  if (rank === 1) {\n    var padSetup = \"\\n        \".concat(dtype, \" source = rc;\\n        if (source < start) {\\n          source = start * 2 - source - \").concat(offset, \";\\n        } else if (source >= end) {\\n          source = (end - 1) * 2 - source + \").concat(offset, \";\\n        }\\n        source -= start;\\n      \");\n    mainLoop = \"\\n        \".concat(dtype, \" rc = outputLoc;\\n        \").concat(padSetup, \"\\n        result[0] = getChannel(getX(\").concat(source.join(), \"), \").concat(innerDims, \");\\n        \").concat(coords[rank - 1], \" += 1;\\n        if(\").concat(cLimit, \") {\\n          \").concat(padSetup, \"\\n          result[1] = getChannel(getX(\").concat(source.join(), \"), \").concat(innerDims, \");\\n        }\\n      \");\n  } else {\n    var _padSetup = \"\\n        \".concat(dtype, \" source = rc;\\n        \").concat(dtype, \" lt = \").concat(dtype, \"(lessThan(source, start));\\n        \").concat(dtype, \" gte = \").concat(dtype, \"(greaterThanEqual(source, end));\\n        \").concat(dtype, \" orig = 1 - (lt + gte);\\n        source = orig * source +\\n                lt * (start * 2 - source - \").concat(offset, \") +\\n                gte * ((end - 1) * 2 - source + \").concat(offset, \");\\n        source -= start;\\n      \");\n\n    mainLoop = \"\\n        \".concat(dtype, \" rc = outputLoc;\\n        \").concat(_padSetup, \"\\n        result[0] = getChannel(getX(\").concat(source.join(), \"), \").concat(innerDims, \");\\n        \").concat(coords[rank - 1], \" += 1;\\n        if(\").concat(cLimit, \") {\\n          \").concat(_padSetup, \"\\n          result[1] = getChannel(getX(\").concat(source.join(), \"), \").concat(innerDims, \");\\n        }\\n        rc = outputLoc;\\n        \").concat(coords[rank - 2], \" += 1;\\n        if(\").concat(coords[rank - 2], \" < \").concat(this.outputShape[rank - 2], \") {\\n          \").concat(_padSetup, \"\\n          result[2] = getChannel(getX(\").concat(source.join(), \"), \").concat(innerDims, \");\\n          \").concat(coords[rank - 1], \" += 1;\\n          if(\").concat(cLimit, \") {\\n            \").concat(_padSetup, \"\\n            result[3] = getChannel(getX(\").concat(source.join(), \"), \").concat(innerDims, \");\\n          }\\n        }\\n      \");\n  }\n\n  this.userCode = \"\\n      const \".concat(dtype, \" start = \").concat(dtype, \"(\").concat(start, \");\\n      const \").concat(dtype, \" end = \").concat(dtype, \"(\").concat(end, \");\\n\\n      void main() {\\n        \").concat(dtype, \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \").concat(mainLoop, \"\\n        setOutput(result);\\n      }\\n    \");\n};","map":{"version":3,"sources":["../src/mirror_pad_packed_gpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram {\n    constructor(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const offset = mode === 'reflect' ? 0 : 1;\n        let mainLoop = '';\n        if (rank === 1) {\n            const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        else {\n            const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n        }\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mirror_pad_packed_gpu.js.map"]},"metadata":{},"sourceType":"module"}